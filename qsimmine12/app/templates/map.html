<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8"/>
    <title>Редактор карты</title>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <link rel="stylesheet" href="/static/onest.font.css"/>
    <link rel="stylesheet" href="/static/leaflet.css"/>
    <script src="/static/leaflet.js"></script>
    <script src="/static/Leaflet.Editable.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.css"/>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.4/leaflet.draw.js"></script>
    <script src="https://unpkg.com/leaflet-snap@0.0.3/leaflet.snap.js"></script>

    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Onest', -apple-system, BlinkMacSystemFont, sans-serif;
        }

        #map {
            height: 100%;
        }

        .notification {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 30px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            font-weight: bold;
            text-align: center;
            max-width: 90%;
            font-size: 18px;
            border: 2px solid #007bff;
        }

        .error-message {
            background-color: #f8d7da;
            border-color: #dc3545;
            color: #721c24;
        }

        .marker-popup-content {
            text-align: center;
            font-weight: bold;
            padding: 5px;
        }

        /* Стили для редактора дорог */
        .road-toolbar {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 10px 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .toolbar-button {
            padding: 8px 12px;
            background: #4a86e8;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            white-space: nowrap;
        }

        .toolbar-button:hover {
            background: #3a76d8;
        }

        .toolbar-button.save {
            background: #28a745;
        }

        .toolbar-button.save:hover {
            background: #218838;
        }
    </style>
</head>
<body>
<div id="map"></div>

<script>
    // Глобальные переменные
    let map;
    let currentMode = null;
    let markerTypeToAdd = null;
    let markerIdToReplace = null;
    let isProcessingClick = false;
    const existingMarkers = {};
    let editablePolyline = null;
    let fixedStartPoint = null;
    let fixedEndPoint = null;
    let routeSegments = [];
    let oldMarker = null;

    // Для редактора дорог
    let drawControl = null;
    let drawnItems = null;

    // Иконки маркеров
    const icons = {
        Excavator: L.icon({
            iconUrl: '/static/icons/Excavator.svg',
            iconSize: [32, 32],
            iconAnchor: [16, 16],
            shadowSize: 0,
        }),
        Truck: L.icon({
            iconUrl: '/static/icons/Truck2.svg',
            iconSize: [32, 32],
            iconAnchor: [16, 32],
            shadowSize: 0,
        }),
        UnloadingSite: L.icon({
            iconUrl: '/static/icons/UnloadingSite.svg',
            iconSize: [32, 32],
            iconAnchor: [16, 16],
            shadowSize: 0,
        }),
        Quarry: L.divIcon({
            html: `<svg width="40" height="40" viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M0 16C0 7.16345 7.16344 0 16 0H84C92.8366 0 100 7.16344 100 16V84C100 92.8366 92.8366 100 84 100H16C7.16345 100 0 92.8366 0 84V16Z" fill="url(#paint0_linear_111_700)"/>
            <path d="M20 20L80 20L60 80L40 80L20 20Z" fill="#7C3C2D" stroke="#5A2D1F" stroke-width="2"/>
            <path d="M30 30L70 30L55 65L45 65L30 30Z" fill="#9C5D4D" stroke="#5A2D1F" stroke-width="1"/>
            <defs>
                <linearGradient id="paint0_linear_111_700" x1="0" y1="50" x2="100" y2="50" gradientUnits="userSpaceOnUse">
                    <stop stop-color="#EACDA3"/>
                    <stop offset="1" stop-color="#D6AE7B"/>
                </linearGradient>
            </defs>
        </svg>`,
            className: 'embedded-svg-icon-quarry',
            iconAnchor: [20, 40],
            popupAnchor: [0, 0],
            tooltipAnchor: [0, 15],
            shadowSize: 0,
        }),
        Parking: L.icon({
            iconUrl: '/static/icons/Parking.svg',
            iconSize: [32, 32],
            iconAnchor: [16, 32],
            shadowSize: 0,
        }),
        FuelStation: L.icon({
            iconUrl: '/static/icons/FuelStation.svg',
            iconSize: [32, 32],
            iconAnchor: [16, 32],
            shadowSize: 0,
        }),
    };

    // Инициализация после полной загрузки DOM
    document.addEventListener('DOMContentLoaded', async () => {
        try {
            const urlParams = new URLSearchParams(window.location.search);
            const type = urlParams.get('type');
            markerIdToReplace = urlParams.get('id');
            const defaultCenter = [58.172541, 59.815387];
            map = L.map('map', {attributionControl: false}).setView(defaultCenter, 15);

            L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles © Esri'
            }).addTo(map);

            await loadExistingMarkers();

            if (type === 'Route') {
                initRouteEditor(urlParams);
            } else if (type === 'Road') {
                initRoadEditor();
            } else if (type && icons[type]) {
                activateMarkerPlacementMode(type);
                const markerKey = `${type}_${markerIdToReplace}`;
                if (existingMarkers[markerKey]) {
                    oldMarker = existingMarkers[markerKey];
                    oldMarker.setOpacity(0.5);
                }
            } else {
                throw new Error('Тип операции не указан или не поддерживается');
            }
        } catch (error) {
            showNotification(`Ошибка: ${error.message}`, true);
            setTimeout(() => window.close(), 3000);
        }
    });

    // Инициализация редактора маршрутов
    function initRouteEditor(urlParams) {
        try {
            const routeId = urlParams.get('id');
            if (routeId) {
                const storageKey = `routeSegments_${routeId}`;
                const segmentsData = sessionStorage.getItem(storageKey);
                if (segmentsData) {
                    try {
                        routeSegments = JSON.parse(segmentsData);
                        sessionStorage.removeItem(storageKey);
                    } catch (e) {
                        console.error('Ошибка парсинга сегментов', e);
                    }
                }
            }

            let startLat, startLng, endLat, endLng;
            if (routeSegments.length > 0) {
                startLat = routeSegments[0].start[0];
                startLng = routeSegments[0].start[1];
                endLat = routeSegments[routeSegments.length - 1].end[0];
                endLng = routeSegments[routeSegments.length - 1].end[1];
            } else {
                startLat = parseFloat(urlParams.get('start_lat'));
                startLng = parseFloat(urlParams.get('start_lng'));
                endLat = parseFloat(urlParams.get('end_lat'));
                endLng = parseFloat(urlParams.get('end_lng'));
                if (isNaN(endLat) || isNaN(endLng)) {
                    endLat = startLat;
                    endLng = startLng;
                }
            }

            if (isNaN(startLat) || isNaN(startLng)) {
                throw new Error('Не указаны начальные координаты маршрута');
            }

            createControlPanel();
            addFixedPoints(startLat, startLng, endLat, endLng);
            if (routeSegments.length > 0) {
                createEditableRouteFromSegments(routeSegments);
            } else {
                createEditableRoute(startLat, startLng, endLat, endLng);
            }

            showNotification('Кликайте по линии, чтобы добавлять точки. Перетаскивайте точки для изменения маршрута.');
            currentMode = 'route';
        } catch (error) {
            showNotification(error.message, true);
        }
    }

    function createEditableRouteFromSegments(segments) {
        const points = [];
        if (segments.length > 0) {
            points.push(segments[0].start);
            segments.forEach(segment => {
                points.push(segment.end);
            });
        }
        if (!map.editTools) {
            map.editTools = new L.Editable(map);
        }
        const polyline = L.polyline(points, {
            color: '#007bff',
            weight: 5,
            opacity: 0.7,
            editable: true
        }).addTo(map);
        editablePolyline = polyline;
        polyline.enableEdit();
        polyline.on('editable:editing', sendRouteUpdate);
        polyline.on('editable:vertex:dragend editable:vertex:deleted editable:vertex:new', sendRouteUpdate);
        setTimeout(sendRouteUpdate, 500);
    }

    // =================================================================
    // ИНИЦИАЛИЗАЦИЯ РЕДАКТОРА ДОРОГ (ИЗМЕНЕНО)
    // =================================================================
    function initRoadEditor() {
        try {
            createRoadToolbar();
            showNotification('Для создания ответвления начните рисовать новую линию и поднесите курсор к существующей.');
            currentMode = 'road';

            // Слой для всех нарисованных дорог
            drawnItems = new L.FeatureGroup();
            map.addLayer(drawnItems);

            // NEW: Настройка для "прилипания" (snapping)
            const snapOptions = {
                snapDistance: 15, // Дистанция прилипания в пикселях
                guideLayers: [drawnItems], // Слой, к которому будем прилипать
            };

            // Настройка контроллера Leaflet.Draw с включенным Snap
            drawControl = new L.Control.Draw({
                draw: {
                    polyline: {
                        shapeOptions: { color: '#007bff', weight: 5 },
                        showLength: true,
                        metric: true,
                        snap: snapOptions // Активируем snap для режима рисования
                    },
                    polygon: false, rectangle: false, circle: false, marker: false, circlemarker: false
                },
                edit: {
                    featureGroup: drawnItems,
                    edit: { snap: snapOptions }, // Активируем snap для режима редактирования
                    remove: true
                }
            });
            map.addControl(drawControl);

            // Обработчики событий для дорог
            map.on(L.Draw.Event.CREATED, function (e) {
                const layer = e.layer;
                drawnItems.addLayer(layer);
                sendRoadUpdate();
            });

            map.on(L.Draw.Event.EDITED, function (e) {
                sendRoadUpdate();
            });

            map.on(L.Draw.Event.DELETED, function (e) {
                sendRoadUpdate();
            });

        } catch (error) {
            showNotification(error.message, true);
        }
    }

    // =================================================================
    // ПАНЕЛЬ ИНСТРУМЕНТОВ РЕДАКТОРА ДОРОГ (ИЗМЕНЕНО)
    // =================================================================
    function createRoadToolbar() {
        const toolbar = document.createElement('div');
        toolbar.className = 'road-toolbar';
        toolbar.innerHTML = `
            <button id="save-road" class="toolbar-button save">Сохранить дорогу</button>
            <button id="close-editor" class="toolbar-button">Закрыть</button>
        `;
        document.body.appendChild(toolbar);
        document.getElementById('save-road').addEventListener('click', saveRoad);
        document.getElementById('close-editor').addEventListener('click', closeEditor);
    }

    // =================================================================
    // ОТПРАВКА ОБНОВЛЕНИЙ ДОРОГИ (ИЗМЕНЕНО)
    // =================================================================
    function sendRoadUpdate() {
    if (!drawnItems) return;
    try {
        const features = [];
        drawnItems.eachLayer(layer => {
            if (layer instanceof L.Polyline) {
                const latlngs = layer.getLatLngs();
                if (latlngs.length < 2) return;
                for (let i = 0; i < latlngs.length - 1; i++) {
                    const start = latlngs[i];
                    const end = latlngs[i + 1];
                    const length = Math.round(map.distance(start, end));
                    features.push({
                        type: "Feature",
                        properties: { length: length, direction: "=" },
                        // Исправлено: правильный порядок координат для GeoJSON [lng, lat]
                        geometry: {
                            type: "LineString",
                            coordinates: [[start.lng, start.lat], [end.lng, end.lat]]
                        }
                    });
                }
            }
        });
        const geoJSON = { type: "FeatureCollection", features: features };
        if (window.opener) {
            window.opener.postMessage({ type: 'roadUpdated', geoJSON: geoJSON }, '*');
        }
    } catch (error) {
        console.error('Ошибка отправки обновления дороги:', error);
    }
}

    // =================================================================
    // СОХРАНЕНИЕ ДОРОГИ (ИЗМЕНЕНО)
    // =================================================================
    function saveRoad() {
    if (!drawnItems || drawnItems.getLayers().length === 0) {
        showNotification('Не нарисовано ни одного участка дороги для сохранения.', true);
        return;
    }
    try {
        const features = [];
        drawnItems.eachLayer(layer => {
            if (layer instanceof L.Polyline) {
                const latlngs = layer.getLatLngs();
                if (latlngs.length < 2) return;
                for (let i = 0; i < latlngs.length - 1; i++) {
                    const start = latlngs[i];
                    const end = latlngs[i + 1];
                    const length = Math.round(map.distance(start, end));
                    features.push({
                        type: "Feature",
                        properties: { length: length, direction: "=" },
                        // Исправлено: правильный порядок координат для GeoJSON [lng, lat]
                        geometry: {
                            type: "LineString",
                            coordinates: [[start.lng, start.lat], [end.lng, end.lat]]
                        }
                    });
                }
            }
        });
        if (features.length === 0) {
            showNotification('Дорожная сеть должна содержать хотя бы один сегмент.', true);
            return;
        }
        const geoJSON = { type: "FeatureCollection", features: features };
        const urlParams = new URLSearchParams(window.location.search);
        const quarry_id = urlParams.get('quarry_id');
        const data = {
            action: 'create',
            type: 'road_net',
            data: {
                quarry_id: quarry_id || 1,
                geojson_data: geoJSON
            }
        };
        fetch('/api/object', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data)
        })
        .then(response => response.json())
        .then(result => {
            if (result.success) {
                showNotification('Дорожная сеть успешно сохранена!');
            } else {
                showNotification('Ошибка при сохранении: ' + result.message, true);
            }
        })
        .catch(error => {
            console.error('Ошибка:', error);
            showNotification('Произошла сетевая ошибка при сохранении.', true);
        });
    } catch (error) {
        console.error('Ошибка сохранения дороги:', error);
        showNotification('Произошла внутренняя ошибка при подготовке данных.', true);
    }
}


    // --- ОСТАЛЬНОЙ КОД БЕЗ ИЗМЕНЕНИЙ ---

    async function loadExistingMarkers() {
        try {
            const response = await fetch('/api/quarry-data');
            if (!response.ok) throw new Error('Ошибка загрузки данных карьера');
            const data = await response.json();

            data.quarry_list.forEach(quarry => {

                if (quarry.center_lat && quarry.center_lon) {
                    addExistingMarker({
                        id: quarry.id,
                        name: quarry.name,
                        type: 'Quarry',
                        lat: quarry.center_lat,
                        lon: quarry.center_lon
                    });
                }
                quarry.shovel_list.forEach(shovel => {
                    addExistingMarker({ id: shovel.id, name: shovel.name, type: 'Excavator', lat: shovel.initial_lat, lon: shovel.initial_lon });
                });
                quarry.unload_list.forEach(unload => {
                    addExistingMarker({ id: unload.id, name: unload.name, type: 'UnloadingSite', lat: unload.initial_lat, lon: unload.initial_lon });
                });
                quarry.truck_list.forEach(truck => {
                    addExistingMarker({ id: truck.id, name: truck.name, type: 'Truck', lat: truck.initial_lat, lon: truck.initial_lon });
                });
                quarry.fuel_station_list.forEach(fuel_station => {
                    addExistingMarker({ id: fuel_station.id, name: fuel_station.name, type: 'FuelStation', lat: fuel_station.initial_lat, lon: fuel_station.initial_lon });
                });
                quarry.shift_change_area_list.forEach(shift_change_area => {
                    addExistingMarker({ id: shift_change_area.id, name: shift_change_area.name, type: 'Parking', lat: shift_change_area.initial_lat, lon: shift_change_area.initial_lon });
                });
            });
        } catch (error) {
            console.error('Ошибка загрузки данных:', error);
            showNotification('Не удалось загрузить данные карьера', true);
        }
    }

    function addExistingMarker(marker) {
        const markerKey = `${marker.type}_${marker.id}`;
        const displayLat = parseFloat(marker.lat.toFixed(6));
        const displayLng = parseFloat(marker.lon.toFixed(6));
        const markerObj = L.marker([marker.lat, marker.lon], {
            icon: icons[marker.type] || icons.Truck
        }).addTo(map);
        markerObj.bindPopup(`
            <div class="marker-popup-content">
              <div>${marker.name}</div>
              <div>(${displayLat}, ${displayLng})</div>
              <div><small>${getMarkerTypeName(marker.type)}</small></div>
            </div>
        `);
        existingMarkers[markerKey] = markerObj;
    }

    function createControlPanel() {
        const panel = document.createElement('div');
        panel.className = 'control-panel';
        panel.innerHTML = `<button id="close-editor" class="control-button">Закрыть редактор</button>`;
        document.body.appendChild(panel);
        document.getElementById('close-editor').addEventListener('click', closeEditor);
    }

    function addFixedPoints(startLat, startLng, endLat, endLng) {
        fixedStartPoint = L.marker([startLat, startLng], {
            icon: icons.Excavator,
            draggable: false
        }).addTo(map).bindPopup('Начало маршрута (фиксировано)');
        if (startLat !== endLat || startLng !== endLng) {
            fixedEndPoint = L.marker([endLat, endLng], {
                icon: icons.UnloadingSite,
                draggable: false
            }).addTo(map).bindPopup('Конец маршрута (фиксировано)');
        }
    }

    function createEditableRoute(startLat, startLng, endLat, endLng) {
        const points = [[startLat, startLng], [endLat, endLng]];
        if (!map.editTools) {
            map.editTools = new L.Editable(map);
        }
        const polyline = L.polyline(points, {
            color: '#007bff',
            weight: 5,
            opacity: 0.7,
            editable: true
        }).addTo(map);
        editablePolyline = polyline;
        polyline.enableEdit();
        polyline.on('editable:editing', sendRouteUpdate);
        polyline.on('editable:vertex:dragend editable:vertex:deleted editable:vertex:new', sendRouteUpdate);
        setTimeout(sendRouteUpdate, 500);
    }

    function activateMarkerPlacementMode(type) {
        currentMode = 'marker';
        markerTypeToAdd = type;
        showNotification(`Кликните на карте, чтобы разместить ${getMarkerTypeName(type)}`);
        map.on('click', handleMarkerPlacement);
    }

    function getMarkerTypeName(type) {
        const names = {
            Quarry: 'карьер',
            Excavator: 'экскаватор',
            Truck: 'самосвал',
            UnloadingSite: 'место разгрузки',
            Parking: 'парковку',
            FuelStation: 'заправку'
        };
        return names[type] || type;
    }

    function showNotification(message, isError = false) {
        const existing = document.querySelector('.notification');
        if (existing) existing.remove();
        const notification = document.createElement('div');
        notification.className = 'notification';
        notification.textContent = message;
        if (isError) {
            notification.classList.add('error-message');
        }
        document.body.appendChild(notification);
        if (!isError) {
            setTimeout(() => {
                notification.style.opacity = '0';
                setTimeout(() => notification.remove(), 500);
            }, 5000);
        }
    }

    async function handleMarkerPlacement(e) {
        if (isProcessingClick) return;
        isProcessingClick = true;
        const urlParams = new URLSearchParams(window.location.search);
        const isQuarry = urlParams.get('isQuarry') === 'true';
        const lat = parseFloat(e.latlng.lat.toFixed(6));
        const lng = parseFloat(e.latlng.lng.toFixed(6));
        try {
            if (oldMarker) {
                map.removeLayer(oldMarker);
                const markerKey = `${markerTypeToAdd}_${markerIdToReplace}`;
                delete existingMarkers[markerKey];
                oldMarker = null;
            }
            L.marker(e.latlng, { icon: icons[markerTypeToAdd] }).addTo(map);
            showNotification(`${getMarkerTypeName(markerTypeToAdd)} размещен! Окно закроется через 1 секунду...`);
            if (window.opener) {
                window.opener.postMessage({
                    type: 'markerAdded',
                    markerType: markerTypeToAdd,
                    coordinates: {lat, lng},
                    isQuarry: isQuarry
                }, '*');
            }
            setTimeout(() => window.close(), 1000);
        } catch (error) {
            console.error('Ошибка:', error);
            showNotification('Произошла ошибка при добавлении маркера', true);
        } finally {
            isProcessingClick = false;
        }
    }

    function sendRouteUpdate() {
        if (!editablePolyline) return;
        try {
            const latlngs = editablePolyline.getLatLngs();
            const newSegments = [];
            for (let i = 0; i < latlngs.length - 1; i++) {
                const existingSegment = routeSegments[i] || {};
                newSegments.push({
                    start: [parseFloat(latlngs[i].lat.toFixed(6)), parseFloat(latlngs[i].lng.toFixed(6))],
                    end: [parseFloat(latlngs[i+1].lat.toFixed(6)), parseFloat(latlngs[i+1].lng.toFixed(6))],
                    speed_empty: existingSegment.speed_empty || 35,
                    speed_loaded: existingSegment.speed_loaded || 18,
                    slope: existingSegment.slope || 0
                });
            }
            routeSegments = newSegments;
            if (window.opener) {
                window.opener.postMessage({ type: 'routeUpdated', segments: routeSegments }, '*');
            }
        } catch (error) {
            console.error('Ошибка отправки маршрута:', error);
        }
    }

    function closeEditor() {
        if (window.opener) {
            window.opener.postMessage({ type: 'routeEditorClosed' }, '*');
        }
        window.close();
    }

    window.addEventListener('beforeunload', () => {
        const urlParams = new URLSearchParams(window.location.search);
        const routeId = urlParams.get('id');
        if (routeId) {
            sessionStorage.removeItem(`routeSegments_${routeId}`);
        }
        if (window.opener) {
            const messageType = {
                marker: 'markerWindowClosed',
                route: 'routeEditorClosed',
                road: 'roadEditorClosed'
            }[currentMode];

            if (messageType) {
                window.opener.postMessage({ type: messageType }, '*');
            }
        }
    });
</script>
</body>
</html>