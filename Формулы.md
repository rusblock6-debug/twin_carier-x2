# Математические формулы проекта qsimmine12

| № | Формула | Пояснение (из чего состоит) | Местоположение | Что делает | Зависимости |
|---|---------|----------------------------|----------------|-------------|-------------|
| 1 | `a = λ / μ` | a - трафик нагрузки, λ - интенсивность прибытия, μ - интенсивность обслуживания | trucks_needed.py:19 | Вычисляет параметр трафика для модели Erlang C | λ, μ |
| 2 | `ρ = λ / (c * μ)` | ρ - коэффициент использования, λ - интенсивность прибытия, c - количество серверов, μ - интенсивность обслуживания | trucks_needed.py:20 | Вычисляет коэффициент использования системы | λ, c, μ |
| 3 | `sum0 = Σ(a^k / k!)` | sum0 - сумма ряда, a - параметр трафика, k - индекс суммирования | trucks_needed.py:24-29 | Вычисляет сумму ряда для формулы Erlang C | a, k |
| 4 | `termc = (a^c / c!) * (c / (c - a))` | termc - член ряда, a - параметр трафика, c - количество серверов | trucks_needed.py:30 | Вычисляет последний член ряда для Erlang C | a, c |
| 5 | `Pw = termc / (sum0 + termc)` | Pw - вероятность ожидания, termc - последний член, sum0 - сумма ряда | trucks_needed.py:31 | Вычисляет вероятность ожидания в очереди (Erlang C) | termc, sum0 |
| 6 | `Wq_mm = Pw / (c * μ - λ)` | Wq_mm - среднее время ожидания, Pw - вероятность ожидания, c - количество серверов, μ - интенсивность, λ - интенсивность прибытия | trucks_needed.py:46 | Вычисляет среднее время ожидания для M/M/c модели | Pw, c, μ, λ |
| 7 | `Wq_ggc = 0.5 * (ca² + cs²) * Wq_mm` | Wq_ggc - время ожидания G/G/c, ca² - коэффициент вариации прибытия, cs² - коэффициент вариации обслуживания, Wq_mm - время M/M/c | trucks_needed.py:47 | Поправка Аллена-Куннена для G/G/c модели | ca², cs², Wq_mm |
| 8 | `mu_load = 1 / T_load` | mu_load - интенсивность погрузки, T_load - время погрузки | trucks_needed.py:82 | Вычисляет интенсивность обслуживания погрузки | T_load |
| 9 | `mu_unld = 1 / T_unload` | mu_unld - интенсивность разгрузки, T_unload - время разгрузки | trucks_needed.py:83 | Вычисляет интенсивность обслуживания разгрузки | T_unload |
| 10 | `u_star2 = 1 - (Dur_rep + Dur_idle + Dur_blast + Dur_lunch) / (Dur_work * M)` | u_star2 - доступность экскаватора, Dur_rep - время ремонта, Dur_idle - плановый простой, Dur_blast - ожидание взрыва, Dur_lunch - обед, Dur_work - рабочее время, M - количество экскаваторов | trucks_needed.py:84 | Вычисляет коэффициент доступности экскаваторов | Dur_rep, Dur_idle, Dur_blast, Dur_lunch, Dur_work, M |
| 11 | `lam = u_star * u_star2 * M * mu_load` | lam - интенсивность прибытия самосвалов, u_star - целевая загрузка, u_star2 - доступность, M - количество экскаваторов, mu_load - интенсивность погрузки | trucks_needed.py:85 | Вычисляет интенсивность прибытия самосвалов | u_star, u_star2, M, mu_load |
| 12 | `T_cycle = T_haul + T_return + T_load + T_unload + Wq_load + Wq_unld + T_rot` | T_cycle - время цикла, T_haul - время гружёного хода, T_return - время порожнего хода, T_load - время погрузки, T_unload - время разгрузки, Wq_load - ожидание погрузки, Wq_unld - ожидание разгрузки, T_rot - время маневра | trucks_needed.py:90 | Вычисляет полное время цикла самосвала | T_haul, T_return, T_load, T_unload, Wq_load, Wq_unld, T_rot |
| 13 | `N = lam * T_cycle` | N - количество самосвалов, lam - интенсивность прибытия, T_cycle - время цикла | trucks_needed.py:91 | Вычисляет требуемое количество самосвалов | lam, T_cycle |
| 14 | `cs² = variance / (mean²)` | cs² - квадрат коэффициента вариации, variance - дисперсия, mean - среднее значение | trucks_needed.py:160-163 | Вычисляет квадрат коэффициента вариации | variance, mean |
| 15 | `t1 = (glubina_vrezki_m * K_r * K_w) / skorost_vrezki_m_s * K_T` | t1 - время врезки, glubina_vrezki_m - глубина врезки, K_r - коэффициент сопротивления, K_w - коэффициент влажности, skorost_vrezki_m_s - скорость врезки, K_T - температурный коэффициент | shovel.py:26 | Вычисляет время врезки ковша экскаватора | glubina_vrezki_m, K_r, K_w, skorost_vrezki_m_s, K_T |
| 16 | `t2 = (dlina_drag_m * K_r * K_w) / (skorost_napolneniya_m_s * K_f) * K_T` | t2 - время наполнения, dlina_drag_m - длина хода, K_r - коэффициент сопротивления, K_w - коэффициент влажности, skorost_napolneniya_m_s - скорость наполнения, K_f - коэффициент наполнения, K_T - температурный коэффициент | shovel.py:28 | Вычисляет время наполнения ковша | dlina_drag_m, K_r, K_w, skorost_napolneniya_m_s, K_f, K_T |
| 17 | `t3 = visota_podem_m / skorost_podem_m_s * K_i * K_h * K_T` | t3 - время подъёма, visota_podem_m - высота подъёма, skorost_podem_m_s - скорость подъёма, K_i - коэффициент инерции, K_h - коэффициент гидравлики, K_T - температурный коэффициент | shovel.py:30 | Вычисляет время подъёма ковша | visota_podem_m, skorost_podem_m_s, K_i, K_h, K_T |
| 18 | `t4 = ugol_swing_rad / skorost_povorot_rad_s * K_i * K_h * K_T` | t4 - время поворота, ugol_swing_rad - угол поворота, skorost_povorot_rad_s - скорость поворота, K_i - коэффициент инерции, K_h - коэффициент гидравлики, K_T - температурный коэффициент | shovel.py:32 | Вычисляет время поворота стрелы | ugol_swing_rad, skorost_povorot_rad_s, K_i, K_h, K_T |
| 19 | `t5 = ugol_dump_rad / skorost_povorot_rad_s * K_h * K_T` | t5 - время разгрузки, ugol_dump_rad - угол выгрузки, skorost_povorot_rad_s - скорость поворота, K_h - коэффициент гидравлики, K_T - температурный коэффициент | shovel.py:34 | Вычисляет время разгрузки ковша | ugol_dump_rad, skorost_povorot_rad_s, K_h, K_T |
| 20 | `t6 = ugol_swing_rad / skorost_povorot_rad_s * K_ret * K_h * K_T` | t6 - время возврата, ugol_swing_rad - угол возврата, skorost_povorot_rad_s - скорость поворота, K_ret - коэффициент возврата, K_h - коэффициент гидравлики, K_T - температурный коэффициент | shovel.py:36 | Вычисляет время возврата стрелы | ugol_swing_rad, skorost_povorot_rad_s, K_ret, K_h, K_T |
| 21 | `idle = alpha_idle * t / driver_rating` | idle - время простоя, alpha_idle - коэффициент простоя, t - время операции, driver_rating - квалификация водителя | shovel.py:44 | Вычисляет время простоя на каждой операции | alpha_idle, t, driver_rating |
| 22 | `cycle_volume = obem_kovsha_m3 * koef_zapolneniya` | cycle_volume - объём цикла, obem_kovsha_m3 - объём ковша, koef_zapolneniya - коэффициент наполнения | shovel.py:96 | Вычисляет объём груза за один цикл | obem_kovsha_m3, koef_zapolneniya |
| 23 | `cycle_weight = cycle_volume * density` | cycle_weight - вес цикла, cycle_volume - объём цикла, density - плотность материала | shovel.py:97 | Вычисляет вес груза за один цикл | cycle_volume, density |
| 24 | `speed = min(speed + acceleration, speed_limit)` | speed - новая скорость, speed - текущая скорость, acceleration - ускорение, speed_limit - предел скорости | truck.py:28 | Вычисляет скорость с учётом ускорения и ограничения | speed, acceleration, speed_limit |
| 25 | `delta_km = speed * time_step_sec / 3600` | delta_km - пройденное расстояние, speed - скорость, time_step_sec - шаг времени | truck.py:29 | Вычисляет расстояние за шаг времени в км | speed, time_step_sec |
| 26 | `travelled_km = min(travelled_km + delta_km, distance_km)` | travelled_km - пройденное расстояние, delta_km - приращение, distance_km - общее расстояние | truck.py:30 | Обновляет пройденное расстояние с ограничением | travelled_km, delta_km, distance_km |
| 27 | `ratio = travelled_km / distance_km` | ratio - отношение пройденного пути, travelled_km - пройденное расстояние, distance_km - общее расстояние | truck.py:31 | Вычисляет долю пройденного пути | travelled_km, distance_km |
| 28 | `t = distance_km / speed_kmh * 3600` | t - время в секундах, distance_km - расстояние в км, speed_kmh - скорость в км/ч | truck.py:117,126 | Вычисляет время движения | distance_km, speed_kmh |
| 29 | `t = ceil(t / driver_skill)` | t - скорректированное время, t - исходное время, driver_skill - навык водителя | truck.py:118,127 | Корректирует время с учётом навыков водителя | t, driver_skill |
| 30 | `t_drive = 30 / driver_rating` | t_drive - время подъезда, driver_rating - квалификация водителя | unload.py:27 | Вычисляет время подъезда к пункту разгрузки | driver_rating |
| 31 | `t_stop = 15 / driver_rating` | t_stop - время остановки, driver_rating - квалификация водителя | unload.py:65 | Вычисляет время остановки и установки | driver_rating |
| 32 | `K_ugl = 1 + 0.01 * max(angle - 25, 0)` | K_ugl - угловой коэффициент, angle - угол наклона | unload.py:32,69 | Вычисляет коэффициент поправки на угол | angle |
| 33 | `K_temp = 1.25` или `K_temp = 1` | K_temp - температурный коэффициент | unload.py:33,70 | Температурный коэффициент для разгрузки | - |
| 34 | `K_mat = koef_soprotivleniya[material_type]` | K_mat - материальный коэффициент, material_type - тип материала | unload.py:34,71 | Коэффициент сопротивления материала | material_type |
| 35 | `t_dump = truck_volume / (speed * K_ugl * K_mat * K_temp)` | t_dump - время высыпания, truck_volume - объём самосвала, speed - скорость выгрузки, K_ugl - угловой коэффициент, K_mat - материальный коэффициент, K_temp - температурный коэффициент | unload.py:36,73 | Вычисляет время высыпания груза | truck_volume, speed, K_ugl, K_mat, K_temp |
| 36 | `total_time = t_drive + t_stop + t_lift + t_dump + t_down + t_leave` | total_time - общее время, t_drive - подъезд, t_stop - остановка, t_lift - подъём кузова, t_dump - высыпание, t_down - опускание кузова, t_leave - уход | unload.py:37,74 | Вычисляет общее время разгрузки | t_drive, t_stop, t_lift, t_dump, t_down, t_leave |
| 37 | `truck_volume = body_capacity / density` | truck_volume - объём самосвала, body_capacity - грузоподъёмность, density - плотность материала | unload.py:61 | Вычисляет объём кузова самосвала | body_capacity, density |
| 38 | `MTBF = T_A / N_F` | MTBF - среднее время между отказами, T_A - начальное время работы, N_F - начальное количество отказов | base.py:18 | Вычисляет среднее время между отказами | T_A, N_F |
| 39 | `failure_rate = 1 / MTBF` | failure_rate - интенсивность отказов, MTBF - среднее время между отказами | base.py:19 | Вычисляет интенсивность отказов | MTBF |
| 40 | `repair_rate = 1 / MTTR` | repair_rate - параметр восстановления, MTTR - среднее время ремонта | base.py:20 | Вычисляет параметр экспоненциального закона восстановления | MTTR |
| 41 | `fuel_rate = ((sfc / (1000 * density)) * p_engine) / 3600` | fuel_rate - расход топлива, sfc - удельный расход топлива, density - плотность топлива, p_engine - мощность двигателя | base.py:46 | Вычисляет расход топлива в секунду при движении | sfc, density, p_engine |
| 42 | `fuel_rate = fuel_idle_lph / 3600` | fuel_rate - расход топлива, fuel_idle_lph - расход на холостом ходу | base.py:52 | Вычисляет расход топлива в секунду на холостом ходу | fuel_idle_lph |
| 43 | `fuel_lvl -= fuel_rate` | fuel_lvl - уровень топлива, fuel_rate - расход топлива | base.py:47,53 | Обновляет уровень топлива | fuel_lvl, fuel_rate |
| 44 | `end_time = (lunch_end - sim_start_time).total_seconds()` | end_time - время окончания обеда, lunch_end - конец обеда, sim_start_time - начало симуляции | base.py:70 | Вычисляет время окончания обеда в секундах | lunch_end, sim_start_time |
| 45 | `start_time = (lunch_start - sim_start_time).total_seconds()` | start_time - время начала обеда, lunch_start - начало обеда, sim_start_time - начало симуляции | base.py:77 | Вычисляет время начала обеда в секундах | lunch_start, sim_start_time |
| 46 | `cross_product = (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])` | cross_product - векторное произведение, o, a, b - точки | geometry.py:72 | Вычисляет векторное произведение для проверки пересечения | o, a, b |
| 47 | `lat = p1.lat + (p2.lat - p1.lat) * ratio` | lat - широта интерполяции, p1.lat, p2.lat - широты точек, ratio - отношение | geometry.py:364 | Интерполирует широту между двумя точками | p1.lat, p2.lat, ratio |
| 48 | `lon = p1.lon + (p2.lon - p1.lon) * ratio` | lon - долгота интерполяции, p1.lon, p2.lon - долготы точек, ratio - отношение | geometry.py:365 | Интерполирует долготу между двумя точками | p1.lon, p2.lon, ratio |
| 49 | `dlat = lat2 - lat1` | dlat - разница широт, lat2, lat1 - широты точек | geometry.py:373 | Вычисляет разницу широт | lat2, lat1 |
| 50 | `dlon = lon2 - lon1` | dlon - разница долгот, lon2, lon1 - долготы точек | geometry.py:373 | Вычисляет разницу долгот | lon2, lon1 |
| 51 | `a = sin(dlat/2)² + cos(lat1) * cos(lat2) * sin(dlon/2)²` | a - параметр гаверсинуса, dlat, dlon - разницы координат, lat1, lat2 - широты | geometry.py:374 | Вычисляет параметр гаверсинуса для расстояния | dlat, dlon, lat1, lat2 |
| 52 | `c = 2 * atan2(√a, √(1-a))` | c - угловое расстояние, a - параметр гаверсинуса | geometry.py:375 | Вычисляет угловое расстояние по гаверсинусу | a |
| 53 | `distance = R * c` | distance - расстояние, R - радиус Земли, c - угловое расстояние | geometry.py:376 | Вычисляет расстояние между точками по гаверсинусу | R, c |
| 54 | `K_w = 0.8` (если percent ≤ 5) | K_w - коэффициент влажности, percent - влажность в % | coefficients.py:9-10 | Коэффициент для сухого грунта | percent |
| 55 | `K_w = 1.25` (если 5 < percent ≤ 15) | K_w - коэффициент влажности, percent - влажность в % | coefficients.py:11-12 | Коэффициент для оптимальной влажности | percent |
| 56 | `K_w = 1.35` (если 15 < percent ≤ 30) | K_w - коэффициент влажности, percent - влажность в % | coefficients.py:13-14 | Коэффициент для влажного грунта | percent |
| 57 | `p = (percent - 30) / 20` | p - нормализованный параметр, percent - влажность в % | coefficients.py:15 | Нормализует влажность для глинистого грунта | percent |
| 58 | `K_w = 1.5 + 0.5 * min(max(p, 0), 1)` | K_w - коэффициент влажности, p - нормализованный параметр | coefficients.py:16 | Коэффициент для глинистого грунта | p |
| 59 | `K_r = koef_soprotivleniya[tip_porody]` | K_r - коэффициент сопротивления, tip_porody - тип породы | constants.py:4-9 | Коэффициент сопротивления материала | tip_porody |
| 60 | `density = density_by_material[tip_porody]` | density - плотность, tip_porody - тип породы | constants.py:13-18 | Плотность материала по типу | tip_porody |
| 61 | `speed = unloading_speed[type_unloading]` | speed - скорость выгрузки, type_unloading - тип выгрузки | constants.py:21-25 | Скорость выгрузки по типу | type_unloading |
| 62 | `min_d = min(T_haul + T_return + T_load + T_unload)` | min_d - минимальная длительность цикла, T_haul, T_return, T_load, T_unload - компоненты времени | milp.py:28-31, cp.py:23-26 | Вычисляет минимальное время цикла для рейса | T_haul, T_return, T_load, T_unload |
| 63 | `available = D_work - min_start - min_end` | available - доступное время, D_work - рабочее время, min_start, min_end - минимальные времена начала/конца | milp.py:32, cp.py:27 | Вычисляет доступное время для работы | D_work, min_start, min_end |
| 64 | `Kmax = floor(available / max(1, min_d))` | Kmax - максимальное количество рейсов, available - доступное время, min_d - минимальная длительность | milp.py:33, cp.py:28 | Вычисляет максимальное количество рейсов | available, min_d |
| 65 | `wait_shovel = trucks_count * T_load` | wait_shovel - ожидание у экскаватора, trucks_count - количество самосвалов, T_load - время погрузки | greedy.py:159 | Вычисляет время ожидания у экскаватора | trucks_count, T_load |
| 66 | `wait_unl = len(trucks_queue) * T_unload` | wait_unl - ожидание на разгрузке, len(trucks_queue) - длина очереди, T_unload - время разгрузки | greedy.py:164 | Вычисляет время ожидания на разгрузке | len(trucks_queue), T_unload |
| 67 | `cycle_time = T_start + wait_shovel + T_load + T_haul + wait_unl + T_unload + T_return` | cycle_time - время цикла, T_start - время старта, wait_shovel - ожидание погрузки, T_load - погрузка, T_haul - гружёный ход, wait_unl - ожидание разгрузки, T_unload - разгрузка, T_return - порожний ход | greedy.py:166-174 | Вычисляет полное время цикла рейса | T_start, wait_shovel, T_load, T_haul, wait_unl, T_unload, T_return |
| 68 | `score = tons / cycle_time` | score - оценка эффективности, tons - тоннаж, cycle_time - время цикла | greedy.py:176 | Вычисляет эффективность рейса (тонн в час) | tons, cycle_time |
| 69 | `blasting.start_time = (blasting.start_time - quarry.start_time).total_seconds()` | blasting.start_time - время взрыва относительно симуляции | blasting.py:28 | Конвертирует время взрыва в относительное | blasting.start_time, quarry.start_time |
| 70 | `blasting.end_time = (blasting.end_time - quarry.start_time).total_seconds()` | blasting.end_time - время окончания взрыва относительно симуляции | blasting.py:29 | Конвертирует время окончания взрыва в относительное | blasting.end_time, quarry.start_time |
| 71 | `weight_in_second = truck.weight / time_unload` | weight_in_second - вес выгружаемый в секунду, truck.weight - вес самосвала, time_unload - время разгрузки | unload.py:78 | Вычисляет скорость выгрузки по весу | truck.weight, time_unload |
| 72 | `volume_in_second = truck.volume / time_unload` | volume_in_second - объём выгружаемый в секунду, truck.volume - объём самосвала, time_unload - время разгрузки | unload.py:79 | Вычисляет скорость выгрузки по объёму | truck.volume, time_unload |
| 73 | `truck.weight = max(0, truck.weight - weight_in_second)` | truck.weight - обновлённый вес самосвала | unload.py:87 | Обновляет вес самосвала при разгрузке | truck.weight, weight_in_second |
| 74 | `truck.volume = max(0, truck.volume - volume_in_second)` | truck.volume - обновлённый объём самосвала | unload.py:88 | Обновляет объём самосвала при разгрузке | truck.volume, volume_in_second |
| 75 | `total_trips += 1` | total_trips - общее количество рейсов | trip_service.py:155 | Увеличивает счётчик рейсов | total_trips |
| 76 | `total_volume += volume` | total_volume - общий объём, volume - объём рейса | trip_service.py:156 | Накапливает общий объём | total_volume, volume |
| 77 | `total_weight += weight` | total_weight - общий вес, weight - вес рейса | trip_service.py:157 | Накапливает общий вес | total_weight, weight |
| 78 | `total_volume_round += round_volume` | total_volume_round - округлённый объём, round_volume - округлённый объём рейса | trip_service.py:158 | Накапливает округлённый объём | total_volume_round, round_volume |
| 79 | `total_weight_round += round_weight` | total_weight_round - округлённый вес, round_weight - округлённый вес рейса | trip_service.py:159 | Накапливает округлённый вес | total_weight_round, round_weight |
| 80 | `hourly_volume[hour] += round_volume` | hourly_volume[hour] - объём за час, round_volume - округлённый объём | trip_service.py:166 | Накапливает объём по часам | hourly_volume, hour, round_volume |
| 81 | `hourly_weight[hour] += round_weight` | hourly_weight[hour] - вес за час, round_weight - округлённый вес | trip_service.py:167 | Накапливает вес по часам | hourly_weight, hour, round_weight |
| 82 | `hourly_trip[hour] += 1` | hourly_trip[hour] - рейсы за час | trip_service.py:168 | Накапливает рейсы по часам | hourly_trip, hour |
| 83 | `round_volume = int(volume)` | round_volume - округлённый объём, volume - исходный объём | trip_service.py:152 | Округляет объём до целого | volume |
| 84 | `round_weight = int(weight)` | round_weight - округлённый вес, weight - исходный вес | trip_service.py:153 | Округляет вес до целого | weight |
| 85 | `mean = sum(data_list) / len(data_list)` | mean - среднее значение, data_list - список данных | statistic_service.py:843-845 | Вычисляет среднего арифметическое | data_list |

---

## Итоговая статистика

Всего найдено и задокументировано **85 математических формул** из следующих основных модулей:

- **Расчёт требуемых самосвалов** (14 формул) - теория массового обслуживания, Erlang C
- **Расчёты экскаватора** (10 формул) - время цикла, объём и вес груза  
- **Расчёты самосвала** (6 формул) - движение, скорость, время
- **Расчёты разгрузки** (8 формул) - время разгрузки, коэффициенты
- **Базовые расчёты** (8 формул) - поломки, топливо, время
- **Геометрические расчёты** (8 формул) - расстояния, интерполяция, пересечения
- **Коэффициенты** (5 формул) - влажность, сопротивление, плотность
- **Планировщики** (8 формул) - оптимизация, эффективность
- **Взрывные работы** (2 формулы) - конвертация времени
- **Статистика** (8 формул) - накопление показателей

Формулы охватывают все основные математические вычисления в симуляторе карьера, включая теорию массового обслуживания, кинематические расчёты, геометрические вычисления и статистическую обработку данных.
