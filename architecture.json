{
  "metadata": {
    "project_root": "D:\\Work\\twin_carier_x2\\qsimmine12",
    "total_components": 261,
    "total_relationships": 266
  },
  "components": [
    {
      "id": "class:DXFConverter@app/dxf_converter.py",
      "name": "DXFConverter",
      "type": "class",
      "layer": "Прочее",
      "file_path": "app/dxf_converter.py",
      "docstring": "",
      "methods": [
        "__init__",
        "convert_coords",
        "safe_geojson_coords",
        "extract_elevation_from_str",
        "process_line",
        "process_polyline",
        "process_lwpolyline",
        "convert_dxf_to_geojson"
      ],
      "source_code": "class DXFConverter:\n\n    def __init__(self, anchor_lat: float, anchor_lon: float, anchor_height: float | None) -> None:\n        self.anchor_lat = anchor_lat\n        self.anchor_lon = anchor_lon\n        self.anchor_height = anchor_height\n\n    def convert_coords(self, x: float, y: float, z: float | None = None) -> tuple[float, float, float | None]:\n        lat, lon, alt = local_to_global(\n            x, y, z, self.anchor_lat, self.anchor_lon, self.anchor_height\n        )\n        return lat, lon, alt\n\n    def safe_geojson_coords(\n            self,\n            x: float,\n            y: float,\n            z: float | None\n    ) -> tuple[float, float] | tuple[float, float, float]:\n        if z is None:\n            return (y, x)\n        return (y, x, z)\n\n    def extract_elevation_from_str(self, layer_name: str) -> float | None:\n        \"\"\"Extract elevation from layer name\"\"\"\n        # Look for elevation patterns like \"Горизонт_100м\", \"205м\", etc.\n        elevation_match = re.search(r'(\\d+)м', layer_name)\n        if elevation_match:\n            elevation = float(elevation_match.group(1))\n            return elevation\n        return None\n\n    def process_line(self, line: Line, layer_name: str, elevation: float | None) -> dict:\n        \"\"\"Process LINE entity\"\"\"\n\n        start_coords = self.convert_coords(*line.dxf.start.xyz)\n        start_coords_safe = self.safe_geojson_coords(*start_coords)\n        end_coords = self.convert_coords(*line.dxf.end.xyz)\n        end_coords_safe = self.safe_geojson_coords(*end_coords)\n\n        feature = {\n            'type': 'Feature',\n            'properties': {\n                'name': layer_name,\n                'elevation': elevation\n            },\n            'geometry': {\n                'type': 'LineString',\n                'coordinates': [start_coords_safe, end_coords_safe]\n            }\n        }\n        return feature\n\n    def process_polyline(self, polyline: Polyline, layer_name: str, elevation: float | None) -> dict | None:\n        \"\"\"Process POLYLINE entity\"\"\"\n\n        coords_list = []\n        for vertex in polyline.vertices:\n            coords = self.convert_coords(*vertex.dxf.location.xyz)\n            coords_safe = self.safe_geojson_coords(*coords)\n            coords_list.append(coords_safe)\n        if len(coords_list) < 2:\n            return\n\n        feature = {\n            'type': 'Feature',\n            'properties': {\n                'name': layer_name,\n                'elevation': elevation\n            },\n            'geometry': {\n                'type': 'LineString',\n                'coordinates': coords_list\n            }\n        }\n        return feature\n\n    def process_lwpolyline(self, lwpolyline: LWPolyline, layer_name: str, elevation: float | None) -> dict | None:\n        \"\"\"Process LWPOLYLINE entity\"\"\"\n\n        coords_list = []\n        for point in lwpolyline.get_points():\n            coords = self.convert_coords(point[0], point[1], lwpolyline.dxf.elevation)\n            coords_safe = self.safe_geojson_coords(*coords)\n            coords_list.append(coords_safe)\n        if len(coords_list) < 2:\n            return\n\n        feature = {\n            'type': 'Feature',\n            'properties': {\n                'name': layer_name,\n                'elevation': elevation\n            },\n            'geometry': {\n                'type': 'LineString',\n                'coordinates': coords_list\n            }\n        }\n        return feature\n\n    def convert_dxf_to_geojson(self, dxf_file: pathlib.Path) -> dict:\n        \"\"\"Convert DXF file to GeoJSON format\"\"\"\n\n        logger.info('Loading DXF-file for conversion to GeoJSON: %s', dxf_file)\n\n        # Try different encodings\n        for encoding in ('cp1251', 'utf-8', 'latin1'):\n            try:\n                doc = ezdxf_readfile(dxf_file, encoding=encoding, errors='strict')\n                logger.info('Loaded DXF-file with encoding: %s', encoding)\n                break\n            except Exception:\n                logger.exception('Failed to load DXF-file with encoding: %s', encoding)\n                continue\n        else:\n            raise Exception('Failed to load DXF-file with any encoding')\n\n        model_space = doc.modelspace()\n\n        layer_entities: dict[str, list[DXFGraphic]] = {}\n        total_entities = 0\n\n        # Group entities by layer\n        for entity in model_space:\n            layer_name = entity.dxf.layer\n            if layer_name not in layer_entities:\n                layer_entities[layer_name] = []\n            layer_entities[layer_name].append(entity)\n            total_entities += 1\n\n        logger.info('Found %s objects within %s layers', total_entities, len(layer_entities))\n\n        features = []\n        feature_collection = {\n            'type': 'FeatureCollection',\n            'features': features\n        }\n\n        # Process entities by layer\n        for layer_name, entities in layer_entities.items():\n            logger.info('Processing layer: %s (%s objects)', layer_name, len(entities))\n            elevation = self.extract_elevation_from_str(layer_name)\n\n            for entity in entities:\n                dxf_type = entity.dxftype()\n                match dxf_type:\n                    case 'LINE':\n                        features.append(self.process_line(entity, layer_name, elevation))\n                    case 'POLYLINE':\n                        features.append(self.process_polyline(entity, layer_name, elevation))\n                    case 'LWPOLYLINE':\n                        features.append(self.process_lwpolyline(entity, layer_name, elevation))\n                    case _:\n                        logger.warning('Skipping entity with type: %s', dxf_type)\n\n        logger.info('Finished conversion of DXF-file: %s (total features %s)', dxf_file, len(features))\n        return feature_collection",
      "imports": [],
      "calls": [
        "get_points",
        "logger",
        "modelspace",
        "process_lwpolyline",
        "re",
        "exception",
        "local_to_global",
        "layer_entities",
        "float",
        "self",
        "coords_list",
        "warning",
        "ezdxf_readfile",
        "safe_geojson_coords",
        "process_polyline",
        "extract_elevation_from_str",
        "Exception",
        "info",
        "len",
        "search",
        "group",
        "append",
        "elevation_match",
        "process_line",
        "items",
        "convert_coords",
        "lwpolyline",
        "dxftype",
        "doc",
        "features",
        "entity"
      ]
    },
    {
      "id": "class:PayloadType@app/enums.py",
      "name": "PayloadType",
      "type": "class",
      "layer": "Перечисления",
      "file_path": "app/enums.py",
      "docstring": "",
      "methods": [],
      "source_code": "class PayloadType(enum.StrEnum):\n    GRAVEL = enum.auto()\n    SAND = enum.auto()\n    CLAY = enum.auto()\n    WET_ORE = enum.auto()",
      "imports": [],
      "calls": [
        "auto",
        "enum"
      ]
    },
    {
      "id": "class:UnloadType@app/enums.py",
      "name": "UnloadType",
      "type": "class",
      "layer": "Перечисления",
      "file_path": "app/enums.py",
      "docstring": "",
      "methods": [],
      "source_code": "class UnloadType(enum.StrEnum):\n    HYDRAULIC = enum.auto()\n    MECHANICAL = enum.auto()\n    GRAVITY = enum.auto()",
      "imports": [],
      "calls": [
        "auto",
        "enum"
      ]
    },
    {
      "id": "class:TrailType@app/enums.py",
      "name": "TrailType",
      "type": "class",
      "layer": "Перечисления",
      "file_path": "app/enums.py",
      "docstring": "",
      "methods": [],
      "source_code": "class TrailType(enum.StrEnum):\n    COMMON = enum.auto()\n    UNCOMMON = enum.auto()\n    SPECIAL = enum.auto()",
      "imports": [],
      "calls": [
        "auto",
        "enum"
      ]
    },
    {
      "id": "class:ObjectActionRequest@app/forms.py",
      "name": "ObjectActionRequest",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [],
      "source_code": "class ObjectActionRequest(BaseModel):\n    action: str\n    type: str\n    data: Dict[str, Any]",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:LocationMixin@app/forms.py",
      "name": "LocationMixin",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [],
      "source_code": "class LocationMixin(BaseModel):\n    initial_lat: Optional[float] = Field(None, ge=-90, le=90)\n    initial_lon: Optional[float] = Field(None, ge=-180, le=180)\n    initial_height: Optional[float] = Field(None, ge=-6000, le=8000)",
      "imports": [],
      "calls": [
        "Field"
      ]
    },
    {
      "id": "class:TemplateRefMixin@app/forms.py",
      "name": "TemplateRefMixin",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [
        "verify_template_bond"
      ],
      "source_code": "class TemplateRefMixin(BaseModel):\n    template_id: Optional[int] = None\n\n    # метаданные класса\n    template_model: ClassVar[Optional[Type[Any]]] = None\n    template_fields_class: ClassVar[Optional[Type[Any]]] = None\n\n    def verify_template_bond(self, orm_obj) -> None:\n        \"\"\"\n        Если orm_obj.template_id установлен, проверяем, совпадают ли поля шаблона и объекта.\n        Если нет — обнуляем связь.\n        \"\"\"\n        if not orm_obj or not getattr(orm_obj, 'template_id', None):\n            return\n\n        db.flush()\n        field_names = collect_model_field_names(self.__class__.__dict__.get('template_fields_class', type(self)))\n        for field_name in field_names:\n            if hasattr(orm_obj, field_name) and hasattr(orm_obj, 'template') and getattr(orm_obj, field_name) != getattr(orm_obj.template, field_name):\n                orm_obj.template_id = None\n                break",
      "imports": [],
      "calls": [
        "db",
        "flush",
        "collect_model_field_names",
        "get",
        "type",
        "hasattr",
        "getattr"
      ]
    },
    {
      "id": "class:TemplateMixin@app/forms.py",
      "name": "TemplateMixin",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [
        "verify_template_bond_reversed"
      ],
      "source_code": "class TemplateMixin(BaseModel):\n    templatable_model: ClassVar[Optional[Type[Any]]] = None\n    template_fields_class: ClassVar[Optional[Type[Any]]] = None\n\n    def verify_template_bond_reversed(self, orm_obj) -> None:\n        \"\"\"\n        Если у текущего шаблона изменились поля — удалить связь template_id у всех привязанных объектов.\n        \"\"\"\n        if not orm_obj or not getattr(orm_obj, 'id', None):\n            return\n\n        field_names = collect_model_field_names(self.template_fields_class or type(self))\n        for field_name in field_names:\n            value_now = getattr(orm_obj, field_name, None)\n            value_new = getattr(self, field_name, None)\n            if value_now != value_new:\n                db.execute(\n                    update(self.templatable_model).where(\n                        self.templatable_model.template_id == orm_obj.id\n                    ).values(template_id=None)\n                )\n                break",
      "imports": [],
      "calls": [
        "db",
        "collect_model_field_names",
        "execute",
        "values",
        "where",
        "update",
        "getattr",
        "type"
      ]
    },
    {
      "id": "class:QuarryRefMixin@app/forms.py",
      "name": "QuarryRefMixin",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [],
      "source_code": "class QuarryRefMixin(BaseModel):\n    quarry_id: Optional[int] = None",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ScheduleMixin@app/forms.py",
      "name": "ScheduleMixin",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "Методы для создания/удаления расписаний.\nЭти методы возвращают JSONResponse (чтобы удобно использовать в FastAPI).",
      "methods": [
        "delete_schedule_items",
        "handle_schedule_create",
        "handle_schedule_delete"
      ],
      "source_code": "class ScheduleMixin(BaseModel):\n    \"\"\"\n    Методы для создания/удаления расписаний.\n    Эти методы возвращают JSONResponse (чтобы удобно использовать в FastAPI).\n    \"\"\"\n\n    @staticmethod\n    def delete_schedule_items(obj_data: Dict[str, Any], model, enterprise_tz: ZoneInfo) -> int:\n        quarry_id = obj_data.get('quarry_id')\n        date_str = obj_data.get('startDate')\n        work_shift_info = obj_data.get('workShift')\n\n        if not all([quarry_id, date_str, work_shift_info]):\n            raise ValueError(\"Missing quarry_id, startDate, or workShift in obj_data for deletion\")\n\n        quarry = db.get(Quarry, quarry_id)\n        if not quarry or not quarry.shift_config:\n            raise ValueError(f\"Quarry {quarry_id} not found or has no shift_config\")\n\n        filter_date = datetime.strptime(date_str, '%Y-%m-%d').date()\n        shift_logic = ShiftLogic.factory(quarry.shift_config)\n\n        target_begin_offset = work_shift_info.get('begin_offset')\n        target_end_offset = work_shift_info.get('end_offset')\n\n        if target_begin_offset is None or target_end_offset is None:\n            raise ValueError(\"workShift missing begin_offset or end_offset\")\n\n        shifts_for_date = shift_logic.for_date(filter_date, enterprise_tz)\n\n        target_shift = None\n        for shift in shifts_for_date:\n            if (shift.begin_offset.total_seconds() // 60 == target_begin_offset and\n                    shift.end_offset.total_seconds() // 60 == target_end_offset):\n                target_shift = shift\n                break\n\n        if not target_shift:\n            raise ValueError(f\"Shift with begin_offset {target_begin_offset} and end_offset {target_end_offset} not found for date {date_str}\")\n\n        shift_start_enterprise = target_shift.begin_time\n        shift_end_enterprise = target_shift.end_time\n\n        shift_start_utc = shift_start_enterprise.astimezone(ZoneInfo('UTC'))\n        shift_end_utc = shift_end_enterprise.astimezone(ZoneInfo('UTC'))\n\n        deleted = db.execute(\n            delete(model).where(\n                model.quarry_id == quarry_id,\n                model.start_time < shift_end_utc,\n                shift_start_utc < model.end_time\n            )\n        ).rowcount\n        return deleted\n\n    def handle_schedule_create(self, obj_data: Dict[str, Any], model, schedule_type: str):\n        enterprise_tz = ZoneInfo(os.getenv('TZ', 'UTC'))\n        try:\n            deleted_count = self.delete_schedule_items(obj_data, model, enterprise_tz)\n\n            created_ids: List[int] = []\n\n            if schedule_type == 'blasting':\n                timeline_items = obj_data.get('timelineItems', [])\n                items_with_coords = []\n                for item in timeline_items:\n                    if not item.get('type') == 'background':\n                        if not item.get('coordinates'):\n                            return JSONResponse(\n                                {'success': False, 'error': f'У одной из записей отсутствуют координаты {schedule_type} работ'},\n                                status_code=400\n                            )\n                        items_with_coords.append(item)\n\n                for i, item in enumerate(items_with_coords):\n                    schedule_obj = model()\n                    schedule_obj.quarry_id = obj_data['quarry_id']\n                    start_time = datetime.fromisoformat(item['start'].replace('Z', '+00:00'))\n                    end_time = datetime.fromisoformat(item['end'].replace('Z', '+00:00'))\n                    schedule_obj.start_time = start_time\n                    schedule_obj.end_time = end_time\n                    coordinates = [\n                        [coord['lng'], coord['lat']]\n                        for coord in item.get('coordinates', [])\n                    ]\n                    if coordinates and coordinates[0] != coordinates[-1]:\n                        coordinates.append(coordinates[0])\n                    geojson = {\n                        \"type\": \"FeatureCollection\",\n                        \"features\": [{\n                            \"type\": \"Feature\",\n                            \"geometry\": {\n                                \"type\": \"Polygon\",\n                                \"coordinates\": [coordinates]\n                            },\n                            \"properties\": {\n                                \"id\": item.get('id'),\n                                \"group\": item.get('group'),\n                                \"content\": item.get('content', ''),\n                                \"timeline_index\": i\n                            }\n                        }]\n                    }\n                    schedule_obj.geojson_data = geojson\n                    db.add(schedule_obj)\n                    created_ids.append(schedule_obj.id)\n\n            elif schedule_type == 'planned_idle':\n                equipment_timelines = obj_data.get('equipmentTimelines', [])\n                for eq_timeline in equipment_timelines:\n                    if not eq_timeline.get('items'):\n                        continue\n\n                    vehicle_type = eq_timeline.get('equipmentType')\n                    vehicle_id = eq_timeline.get('equipmentId')\n\n                    for item in eq_timeline.get('items', []):\n                        schedule_obj = model()\n                        schedule_obj.quarry_id = obj_data['quarry_id']\n                        schedule_obj.vehicle_type = vehicle_type\n                        schedule_obj.vehicle_id = vehicle_id\n\n                        start_time = datetime.fromisoformat(item['start'].replace('Z', '+00:00'))\n                        end_time = datetime.fromisoformat(item['end'].replace('Z', '+00:00'))\n                        schedule_obj.start_time = start_time\n                        schedule_obj.end_time = end_time\n\n                        db.add(schedule_obj)\n                        created_ids.append(schedule_obj.id)\n            else:\n                return JSONResponse({'success': False, 'error': f'Unsupported schedule type for creation: {schedule_type}'}, status_code=400)\n\n            db.commit()\n            return JSONResponse({\n                'success': True,\n                'ids': created_ids,\n                'count': len(created_ids),\n                'deleted_count': deleted_count\n            })\n\n        except Exception as e:\n            db.rollback()\n            return JSONResponse({'success': False, 'error': f'Error processing {schedule_type} records: {str(e)}'}, status_code=500)\n\n    def handle_schedule_delete(self, obj_data: Dict[str, Any], model, schedule_type: str):\n        enterprise_tz = ZoneInfo(os.getenv('TZ', 'UTC'))\n        try:\n            deleted_count = self.delete_schedule_items(obj_data, model, enterprise_tz)\n            db.commit()\n            return JSONResponse({\n                'success': True,\n                'deleted_count': deleted_count,\n                'message': f'Успешно удалено {deleted_count} записей {schedule_type}'\n            })\n        except Exception as e:\n            db.rollback()\n            return JSONResponse({'success': False, 'error': f'Error deleting {schedule_type} records: {str(e)}'}, status_code=500)",
      "imports": [],
      "calls": [
        "strptime",
        "replace",
        "coordinates",
        "ValueError",
        "execute",
        "add",
        "astimezone",
        "factory",
        "date",
        "enumerate",
        "obj_data",
        "self",
        "ShiftLogic",
        "items_with_coords",
        "JSONResponse",
        "getenv",
        "ZoneInfo",
        "all",
        "rollback",
        "os",
        "len",
        "fromisoformat",
        "model",
        "created_ids",
        "append",
        "shift_start_enterprise",
        "where",
        "delete",
        "eq_timeline",
        "db",
        "datetime",
        "work_shift_info",
        "total_seconds",
        "commit",
        "get",
        "str",
        "shift_logic",
        "item",
        "delete_schedule_items",
        "shift_end_enterprise",
        "for_date"
      ]
    },
    {
      "id": "class:BaseObjectSchema@app/forms.py",
      "name": "BaseObjectSchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [
        "validate_name_unique",
        "instantiate_object"
      ],
      "source_code": "class BaseObjectSchema(BaseModel):\n    id: Optional[int] = Field(None, ge=1, description=\"ID должен быть >= 1 (опционально)\")\n    name: str = Field(None, min_length=1, max_length=100, description=\"Имя 1..100 символов\")\n\n    model: ClassVar[Type[BaseObject]] = BaseObject\n\n    # внутренний ORM-объект, не поле Pydantic\n    _obj: Any = PrivateAttr(default=None)\n\n    def validate_name_unique(self):\n        \"\"\"Проверка уникальности имени — вызывать из роутера перед сохранением.\"\"\"\n        if not self.name:\n            return\n        inner_stmt = exists(1).where(self.model.name == self.name)\n        if self.id:\n            inner_stmt = inner_stmt.where(self.model.id != self.id)\n        name_exists = db.execute(select(inner_stmt)).scalar()\n        if name_exists:\n            raise HTTPException(status_code=400, detail='Запись с таким названием уже существует')\n\n    def instantiate_object(self):\n        \"\"\"\n        Возвращает ORM-объект: если id задан — загружает, иначе создаёт новый и добавляет в сессию.\n        \"\"\"\n        if getattr(self, '_obj', None) is not None:\n            return self._obj\n\n        if self.id:\n            self._obj = db.execute(select(self.model).where(self.model.id == self.id)).scalar()\n        else:\n            self._obj = self.model()\n            db.add(self._obj)\n        return self._obj",
      "imports": [],
      "calls": [
        "PrivateAttr",
        "self",
        "db",
        "exists",
        "execute",
        "model",
        "add",
        "where",
        "select",
        "Field",
        "getattr",
        "scalar",
        "HTTPException",
        "inner_stmt"
      ]
    },
    {
      "id": "class:BaseVehicleSchema@app/forms.py",
      "name": "BaseVehicleSchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [],
      "source_code": "class BaseVehicleSchema(BaseObjectSchema):\n    is_calc_enabled: Optional[bool] = None",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:BlastingSchema@app/forms.py",
      "name": "BlastingSchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [
        "populate_obj"
      ],
      "source_code": "class BlastingSchema(QuarryRefMixin, ScheduleMixin, BaseObjectSchema):\n    geojson_data: Optional[Dict] = None\n    start_time: Optional[datetime] = None\n    end_time: Optional[datetime] = None\n\n    model: ClassVar[Type[Blasting]] = Blasting\n\n    def populate_obj(self, orm_obj):\n        if self.name is not None:\n            orm_obj.name = self.name\n        if self.geojson_data is not None:\n            orm_obj.geojson_data = self.geojson_data\n        if self.start_time is not None:\n            orm_obj.start_time = self.start_time\n        if self.end_time is not None:\n            orm_obj.end_time = self.end_time",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ScenarioSchema@app/forms.py",
      "name": "ScenarioSchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [
        "check_end_after_start"
      ],
      "source_code": "class ScenarioSchema(BaseObjectSchema):\n    start_time: Optional[datetime] = None\n    end_time: Optional[datetime] = None\n    is_auto_truck_distribution: Optional[bool] = Field(default=True)\n    is_calc_reliability_enabled: Optional[bool] = Field(default=False)\n\n    quarry_id: Optional[int] = None\n    trails: Optional[List[Dict]] = []\n\n    model: ClassVar[Type[Scenario]] = Scenario\n\n    @field_validator('end_time')\n    @classmethod\n    def check_end_after_start(cls, v, info):\n        start = info.data.get('start_time')\n        if start and v and v <= start:\n            raise ValueError('Конец сценария должен быть позже начала')\n        return v",
      "imports": [],
      "calls": [
        "ValueError",
        "field_validator",
        "get",
        "Field"
      ]
    },
    {
      "id": "class:ShovelArgsMixin@app/forms.py",
      "name": "ShovelArgsMixin",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [
        "check_payload"
      ],
      "source_code": "class ShovelArgsMixin(BaseModel):\n    bucket_volume: Optional[float] = Field(None, ge=0)\n    bucket_lift_speed: Optional[float] = Field(None, ge=0)\n    arm_turn_angle: Optional[float] = Field(None, ge=0)\n    arm_turn_speed: Optional[float] = Field(None, ge=0)\n    bucket_dig_speed: Optional[float] = Field(None, ge=0)\n    bucket_fill_speed: Optional[float] = Field(None, ge=0)\n    bucket_fill_coef: Optional[float] = Field(None, ge=0)\n    arm_inertia_coef: Optional[float] = Field(None, ge=0)\n    return_move_coef: Optional[float] = Field(None, ge=0)\n    payload_type: Optional[str] = None\n    initial_operating_time: Optional[int] = Field(None, ge=0)\n    initial_failure_count: Optional[int] = Field(None, ge=0)\n    average_repair_duration: Optional[int] = Field(None, ge=0)\n\n    @field_validator('payload_type')\n    @classmethod\n    def check_payload(cls, v):\n        if v is None:\n            return v\n        if v not in list(PayloadType):\n            raise ValueError('Invalid payload_type')\n        return v",
      "imports": [],
      "calls": [
        "list",
        "field_validator",
        "ValueError",
        "Field"
      ]
    },
    {
      "id": "class:ShovelTemplateSchema@app/forms.py",
      "name": "ShovelTemplateSchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [],
      "source_code": "class ShovelTemplateSchema(TemplateMixin, ShovelArgsMixin, BaseObjectSchema):\n    model: ClassVar[Type[ShovelTemplate]] = ShovelTemplate\n    templatable_model: ClassVar[Type[Shovel]] = Shovel\n    template_fields_class: ClassVar[Type[ShovelArgsMixin]] = ShovelArgsMixin",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ShovelSchema@app/forms.py",
      "name": "ShovelSchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [],
      "source_code": "class ShovelSchema(QuarryRefMixin, TemplateRefMixin, ShovelArgsMixin, LocationMixin, BaseVehicleSchema):\n    model: ClassVar[Type[Shovel]] = Shovel\n    template_model: ClassVar[Type[ShovelTemplate]] = ShovelTemplate\n    template_fields_class: ClassVar[Type[ShovelArgsMixin]] = ShovelArgsMixin",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:TruckArgsMixin@app/forms.py",
      "name": "TruckArgsMixin",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [],
      "source_code": "class TruckArgsMixin(BaseModel):\n    body_capacity: Optional[float] = Field(None, ge=0)\n    speed_empty: Optional[float] = Field(None, ge=0)\n    speed_loaded: Optional[float] = Field(None, ge=0)\n    initial_operating_time: Optional[int] = Field(None, ge=0)\n    initial_failure_count: Optional[int] = Field(None, ge=0)\n    average_repair_duration: Optional[int] = Field(None, ge=0)\n\n    fuel_capacity: Optional[float] = Field(None, ge=0)\n    fuel_threshold_critical: Optional[float] = Field(None, ge=0)\n    fuel_threshold_planned: Optional[float] = Field(None, ge=0)\n    fuel_level: Optional[float] = Field(None, ge=0)\n    fuel_idle_lph: Optional[float] = Field(None, ge=0)\n    fuel_specific_consumption: Optional[float] = Field(None, ge=0)\n    fuel_density: Optional[float] = Field(None, ge=0)\n    engine_power_kw: Optional[float] = Field(None, ge=0)",
      "imports": [],
      "calls": [
        "Field"
      ]
    },
    {
      "id": "class:TruckTemplateSchema@app/forms.py",
      "name": "TruckTemplateSchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [],
      "source_code": "class TruckTemplateSchema(TemplateMixin, TruckArgsMixin, BaseObjectSchema):\n    model: ClassVar[Type[TruckTemplate]] = TruckTemplate\n    templatable_model: ClassVar[Type[Truck]] = Truck\n    template_fields_class: ClassVar[Type[TruckArgsMixin]] = TruckArgsMixin",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:TruckSchema@app/forms.py",
      "name": "TruckSchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [],
      "source_code": "class TruckSchema(QuarryRefMixin, TemplateRefMixin, TruckArgsMixin, LocationMixin, BaseVehicleSchema):\n    model: ClassVar[Type[Truck]] = Truck\n    template_model: ClassVar[Type[TruckTemplate]] = TruckTemplate\n    template_fields_class: ClassVar[Type[TruckArgsMixin]] = TruckArgsMixin",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:UnloadArgsMixin@app/forms.py",
      "name": "UnloadArgsMixin",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [
        "check_unload_type",
        "check_payload"
      ],
      "source_code": "class UnloadArgsMixin(BaseModel):\n    unload_type: Optional[str] = None\n    capacity: Optional[int] = Field(None, ge=0)\n    angle: Optional[float] = None\n    payload_type: Optional[str] = None\n    trucks_at_once: Optional[int] = Field(None, ge=0)\n    initial_operating_time: Optional[int] = Field(None, ge=0)\n    initial_failure_count: Optional[int] = Field(None, ge=0)\n    average_repair_duration: Optional[int] = Field(None, ge=0)\n\n    @field_validator('unload_type')\n    @classmethod\n    def check_unload_type(cls, v):\n        if v is None:\n            return v\n        if v not in list(UnloadType):\n            raise ValueError('Invalid unload_type')\n        return v\n\n    @field_validator('payload_type')\n    @classmethod\n    def check_payload(cls, v):\n        if v is None:\n            return v\n        if v not in list(PayloadType):\n            raise ValueError('Invalid payload_type')\n        return v",
      "imports": [],
      "calls": [
        "list",
        "field_validator",
        "ValueError",
        "Field"
      ]
    },
    {
      "id": "class:UnloadTemplateSchema@app/forms.py",
      "name": "UnloadTemplateSchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [],
      "source_code": "class UnloadTemplateSchema(TemplateMixin, UnloadArgsMixin, BaseObjectSchema):\n    model: ClassVar[Type[UnloadTemplate]] = UnloadTemplate\n    templatable_model: ClassVar[Type[Unload]] = Unload\n    template_fields_class: ClassVar[Type[UnloadArgsMixin]] = UnloadArgsMixin",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:UnloadSchema@app/forms.py",
      "name": "UnloadSchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [],
      "source_code": "class UnloadSchema(QuarryRefMixin, TemplateRefMixin, UnloadArgsMixin, LocationMixin, BaseObjectSchema):\n    model: ClassVar[Type[Unload]] = Unload\n    template_model: ClassVar[Type[UnloadTemplate]] = UnloadTemplate\n    template_fields_class: ClassVar[Type[UnloadArgsMixin]] = UnloadArgsMixin",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:IdleAreaSchema@app/forms.py",
      "name": "IdleAreaSchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [
        "validate_logic"
      ],
      "source_code": "class IdleAreaSchema(QuarryRefMixin, LocationMixin, BaseObjectSchema):\n    is_lunch_area: Optional[bool] = None\n    is_shift_change_area: Optional[bool] = None\n    is_blast_waiting_area: Optional[bool] = None\n    is_repair_area: Optional[bool] = None\n\n    model: ClassVar[Type[IdleArea]] = IdleArea\n\n    def validate_logic(self):\n        if not any([self.is_lunch_area, self.is_shift_change_area, self.is_blast_waiting_area, self.is_repair_area]):\n            raise HTTPException(status_code=400, detail='Хотя бы одно из полей должно быть выбрано: зона обеда, пересменки или ожидания взрыва.')",
      "imports": [],
      "calls": [
        "HTTPException",
        "any"
      ]
    },
    {
      "id": "class:FuelStationArgsMixin@app/forms.py",
      "name": "FuelStationArgsMixin",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [],
      "source_code": "class FuelStationArgsMixin(BaseModel):\n    num_pumps: Optional[int] = Field(None, ge=0)\n    flow_rate: Optional[float] = Field(None, ge=0)",
      "imports": [],
      "calls": [
        "Field"
      ]
    },
    {
      "id": "class:FuelStationTemplateSchema@app/forms.py",
      "name": "FuelStationTemplateSchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [],
      "source_code": "class FuelStationTemplateSchema(TemplateMixin, FuelStationArgsMixin, BaseObjectSchema):\n    model: ClassVar[Type[FuelStationTemplate]] = FuelStationTemplate\n    templatable_model: ClassVar[Type[FuelStation]] = FuelStation\n    template_fields_class: ClassVar[Type[FuelStationArgsMixin]] = FuelStationArgsMixin",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:FuelStationSchema@app/forms.py",
      "name": "FuelStationSchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [],
      "source_code": "class FuelStationSchema(QuarryRefMixin, TemplateRefMixin, FuelStationArgsMixin, LocationMixin, BaseObjectSchema):\n    model: ClassVar[Type[FuelStation]] = FuelStation\n    template_model: ClassVar[Type[FuelStationTemplate]] = FuelStationTemplate\n    template_fields_class: ClassVar[Type[FuelStationArgsMixin]] = FuelStationArgsMixin",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:TrailSchema@app/forms.py",
      "name": "TrailSchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [
        "check_trail_type"
      ],
      "source_code": "class TrailSchema(BaseObjectSchema):\n    trail_type: Optional[str] = None\n    shovel_id: Optional[int] = None\n    unload_id: Optional[int] = None\n    raw_graph: Optional[str] = None\n\n    model: ClassVar[Type[Trail]] = Trail\n\n    @field_validator('trail_type')\n    @classmethod\n    def check_trail_type(cls, v):\n        if v is None:\n            return v\n        if v not in list(TrailType):\n            raise ValueError('Invalid trail_type')\n        return v",
      "imports": [],
      "calls": [
        "field_validator",
        "ValueError",
        "list"
      ]
    },
    {
      "id": "class:QuarrySchema@app/forms.py",
      "name": "QuarrySchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [
        "validate_timezone",
        "validate_shift_config",
        "validate_complex_rules"
      ],
      "source_code": "class QuarrySchema(BaseObjectSchema):\n    center_lat: Optional[float] = Field(None, ge=-90, le=90)\n    center_lon: Optional[float] = Field(None, ge=-180, le=180)\n    center_height: Optional[float] = Field(None, ge=-6000, le=8000)\n    timezone: Optional[str] = None\n    shift_config: Optional[Union[str, Mapping[str, Any], List[Mapping[str, Any]]]] = None\n    work_break_duration: Optional[int] = Field(None, ge=0)\n    work_break_rate: Optional[int] = Field(None, ge=0)\n    lunch_break_offset: Optional[int] = Field(None, ge=0)\n    lunch_break_duration: Optional[int] = Field(None, ge=0)\n    shift_change_offset: Optional[int] = Field(None, ge=0)\n    shift_change_duration: Optional[int] = Field(None, ge=0)\n\n    model: ClassVar[Type[Quarry]] = Quarry\n\n    def validate_timezone(self):\n        if self.timezone is None:\n            return\n        try:\n            ZoneInfo(self.timezone)\n        except (TypeError, ZoneInfoNotFoundError) as exc:\n            raise HTTPException(status_code=400, detail='Given value must be a valid time zone key')\n\n    def validate_shift_config(self):\n        if self.shift_config is None:\n            return\n        try:\n            ShiftLogic.validate_shift_config(self.shift_config)\n        except ShiftConfigException as exc:\n            exc_msg = 'Given value must be a valid shift configuration'\n            if exc.args:\n                exc_msg = f'{exc_msg}. {exc.args[0]}'\n            raise HTTPException(status_code=400, detail=exc_msg)\n\n    def validate_complex_rules(self):\n        orm_obj = self.instantiate_object()\n        if not orm_obj:\n            return\n\n        shift_config = self.shift_config if self.shift_config is not None else getattr(orm_obj, 'shift_config', None)\n        shift_logic = ShiftLogic.factory(shift_config)\n        shifts_list = shift_logic.for_date(date(2011, 7, 9))\n\n        def value_from_form_or_obj(field_name):\n            val = getattr(self, field_name)\n            if val is not None:\n                return val\n            return getattr(orm_obj, field_name)\n\n        def offset_td(field_name):\n            return timedelta(minutes=value_from_form_or_obj(field_name))\n\n        lunch_break_offset = offset_td('lunch_break_offset')\n        lunch_break_duration = offset_td('lunch_break_duration')\n        lunch_break_offset_end = lunch_break_offset + lunch_break_duration\n\n        for shift in shifts_list:\n            if lunch_break_offset >= shift.length or lunch_break_offset_end > shift.length:\n                raise HTTPException(status_code=400, detail='Перерыв на обед должен целиком помещаться во все смены')\n\n        shift_change_offset = offset_td('shift_change_offset')\n        shift_change_duration = offset_td('shift_change_duration')\n        shift_change_offset_end = shift_change_offset + shift_change_duration\n\n        for shift in shifts_list:\n            if (shift_change_offset != timedelta(minutes=0) and shift_change_offset_end != shift.length) or shift_change_offset_end > shift.length:\n                raise HTTPException(status_code=400, detail='Пересменка должна целиком помещаться во все смены и быть причалена к их началу или окончанию')\n\n        if (shift_change_offset <= lunch_break_offset < shift_change_offset_end) or (lunch_break_offset <= shift_change_offset < lunch_break_offset_end):\n            raise HTTPException(status_code=400, detail='Обеденный перерыв и пересменка не должны пересекаться')",
      "imports": [],
      "calls": [
        "ZoneInfo",
        "self",
        "offset_td",
        "value_from_form_or_obj",
        "timedelta",
        "ShiftLogic",
        "shift_logic",
        "instantiate_object",
        "factory",
        "date",
        "Field",
        "HTTPException",
        "for_date",
        "validate_shift_config",
        "getattr"
      ]
    },
    {
      "id": "class:RoadNetSchema@app/forms.py",
      "name": "RoadNetSchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [
        "validate_logic",
        "save_geojson_data"
      ],
      "source_code": "class RoadNetSchema(QuarryRefMixin, BaseObjectSchema):\n    geojson_data: Any = None\n    geojson_points_data: Optional[str] = None\n\n    _graph: Any = PrivateAttr(default=None)\n    _points_graph: Any = PrivateAttr(default=None)\n\n    model: ClassVar[Type[RoadNet]] = RoadNet\n\n    def validate_logic(self):\n        if self.quarry_id is None:\n            if self.geojson_data is not None:\n                raise HTTPException(status_code=400, detail='Failed to validate road net - other fields of form are invalid')\n\n        if self.geojson_data is not None:\n            try:\n                self._graph = RoadNetFactory(\n                    schema_validator=BaseSchemaValidator(schema=FEATURE_COLLECTION_POINT_LINESTRING),\n                    cleaner=RoadNetCleaner(self.quarry_id),\n                    graph_validator=None,\n                ).create_from_geojson(\n                    geojson_data=self.geojson_data,\n                )\n            except RoadNetException as exc:\n                err_msg = 'Given value must be a valid road net'\n                if exc.args:\n                    err_msg = f'{err_msg}. {exc.args[0]}'\n\n        if self.geojson_points_data is not None:\n            try:\n                self._points_graph = RoadNetFactory(\n                    schema_validator=BaseSchemaValidator(schema=FEATURE_COLLECTION_POINT),\n                    cleaner=RoadNetCleaner(self.quarry_id),\n                    graph_validator=None,\n                ).validate_points_bonds(\n                    geojson_data=self.geojson_points_data\n                )\n            except RoadNetException as exc:\n                err_msg = 'Given value must be a valid point bonds'\n                if exc.args:\n                    err_msg = f'{err_msg}. {exc.args[0]}'\n\n    def save_geojson_data(self, orm_obj):\n        if self._graph:\n            rn_logic = RoadNetGraph(self._graph.graph)\n        else:\n            rn_logic = RoadNetFactory(\n                schema_validator=BaseSchemaValidator(schema=FEATURE_COLLECTION_POINT_LINESTRING),\n                cleaner=RoadNetCleaner(orm_obj.quarry_id),\n                graph_validator=None,\n            ).create_from_geojson(\n                geojson_data=self.geojson_data,\n            )\n\n        if self._points_graph:\n            rn_logic.update_graph_bonds(self._points_graph)\n        orm_obj.geojson_data = rn_logic.graph_to_geojson()",
      "imports": [],
      "calls": [
        "PrivateAttr",
        "RoadNetCleaner",
        "BaseSchemaValidator",
        "RoadNetGraph",
        "create_from_geojson",
        "validate_points_bonds",
        "update_graph_bonds",
        "graph_to_geojson",
        "RoadNetFactory",
        "rn_logic",
        "HTTPException"
      ]
    },
    {
      "id": "class:MapOverlaySchema@app/forms.py",
      "name": "MapOverlaySchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [
        "validate_source_file_id_unique",
        "validate_convert_overlay_possible",
        "convert_dxf"
      ],
      "source_code": "class MapOverlaySchema(QuarryRefMixin, BaseObjectSchema):\n    is_active: Optional[bool] = None\n    anchor_lat: Optional[float] = Field(None, ge=-90, le=90)\n    anchor_lon: Optional[float] = Field(None, ge=-180, le=180)\n    anchor_height: Optional[float] = Field(None, ge=-6000, le=8000)\n    color: Optional[str] = None\n    source_file_id: Optional[int] = None\n    convert_overlay: Optional[bool] = Field(default=False)\n\n    model: ClassVar[Type[MapOverlay]] = MapOverlay\n\n    def validate_source_file_id_unique(self):\n        if self.source_file_id is None:\n            return\n        inner_stmt = exists(1).where(self.model.source_file_id == self.source_file_id)\n        if self.id:\n            inner_stmt = inner_stmt.where(self.model.id != self.id)\n        already_exists = db.execute(select(inner_stmt)).scalar()\n        if already_exists:\n            raise HTTPException(status_code=400, detail='Подложка карты, указывающая на этот файл, уже существует')\n\n    def validate_convert_overlay_possible(self):\n        if not self.convert_overlay:\n            return\n        if self.source_file_id is None and self.id:\n            source_file_id = db.execute(select(self.model.source_file_id).where(self.model.id == self.id)).scalar()\n        else:\n            source_file_id = self.source_file_id\n        if not source_file_id:\n            raise HTTPException(status_code=400, detail='Невозможно произвести конвертацию - исходный DXF-файл отсутствует')\n\n    def convert_dxf(self, orm_obj):\n        if not self.convert_overlay:\n            return\n        stmt = select(UploadedFile.path).where(UploadedFile.id == orm_obj.source_file_id)\n        result = db.execute(stmt)\n        source_file_path = result.scalar()\n        if not source_file_path:\n            return\n        if orm_obj.anchor_lat is None or orm_obj.anchor_lon is None:\n            stmt = select(Quarry.center_lat, Quarry.center_lon, Quarry.center_height).where(\n                Quarry.id == orm_obj.quarry_id)\n            result = db.execute(stmt).first()\n            anchor_lat, anchor_lon, anchor_height = result\n        else:\n            anchor_lat, anchor_lon, anchor_height = orm_obj.anchor_lat, orm_obj.anchor_lon, orm_obj.anchor_height\n\n        source_file_path = Path(source_file_path)\n        dxf_conv = DXFConverter(anchor_lat, anchor_lon, anchor_height)\n        feature_collection = dxf_conv.convert_dxf_to_geojson(source_file_path)\n        orm_obj.geojson_data = feature_collection",
      "imports": [],
      "calls": [
        "db",
        "DXFConverter",
        "first",
        "convert_dxf_to_geojson",
        "exists",
        "execute",
        "result",
        "where",
        "select",
        "Field",
        "scalar",
        "HTTPException",
        "Path",
        "dxf_conv",
        "inner_stmt"
      ]
    },
    {
      "id": "class:PlannedIdleSchema@app/forms.py",
      "name": "PlannedIdleSchema",
      "type": "class",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "",
      "methods": [
        "vehicle_type_allowed",
        "validate_vehicle_id_exists",
        "validate_no_time_overlap"
      ],
      "source_code": "class PlannedIdleSchema(QuarryRefMixin, ScheduleMixin, BaseObjectSchema):\n    vehicle_type: Optional[str] = None\n    vehicle_id: Optional[int] = None\n    start_time: Optional[datetime] = None\n    end_time: Optional[datetime] = None\n\n    model: ClassVar[Type[PlannedIdle]] = PlannedIdle\n\n    @field_validator('vehicle_type')\n    @classmethod\n    def vehicle_type_allowed(cls, v):\n        if v is None:\n            return v\n        if v not in PlannedIdle.valid_vehicle_types:\n            raise ValueError('Invalid vehicle type')\n        return v\n\n    def validate_vehicle_id_exists(self):\n        if not self.vehicle_id:\n            return\n        vehicle_model = next(\n            filter(lambda m: m.__tablename__ == self.vehicle_type, self.model.valid_vehicle_models),\n            None\n        )\n        if vehicle_model:\n            stmt = select(exists(1).where(vehicle_model.id == self.vehicle_id))\n            vehicle_exists = db.execute(stmt).scalar()\n            if not vehicle_exists:\n                raise HTTPException(status_code=400, detail='Техника с таким типом и идентификатором не найдена')\n\n    def validate_no_time_overlap(self):\n        if self.start_time is None or self.end_time is None:\n            return\n        if self.start_time >= self.end_time:\n            raise HTTPException(status_code=400, detail='Время окончания простоя должно превышать время начала')\n\n        inner_stmt = exists(1).where(\n            self.model.vehicle_type == self.vehicle_type,\n            self.model.vehicle_id == self.vehicle_id,\n            or_(\n                and_(\n                    self.model.start_time <= self.start_time,\n                    self.start_time < self.model.end_time\n                ),\n                and_(\n                    self.start_time <= self.model.start_time,\n                    self.model.start_time < self.end_time\n                )\n            )\n        )\n        if self.id:\n            inner_stmt = inner_stmt.where(self.model.id != self.id)\n        idle_exists = db.execute(select(inner_stmt)).scalar()\n        if idle_exists:\n            raise HTTPException(status_code=400, detail='Простой не должен пересекаться с другими простоями этой же техники')",
      "imports": [],
      "calls": [
        "db",
        "HTTPException",
        "exists",
        "ValueError",
        "execute",
        "or_",
        "field_validator",
        "where",
        "select",
        "and_",
        "scalar",
        "filter",
        "next",
        "inner_stmt"
      ]
    },
    {
      "id": "function:collect_model_field_names@app/forms.py",
      "name": "collect_model_field_names",
      "type": "function",
      "layer": "Формы/Валидация",
      "file_path": "app/forms.py",
      "docstring": "Возвращает имена полей Pydantic-схемы.",
      "source_code": "def collect_model_field_names(schema_cls: type) -> List[str]:\n    \"\"\"\n    Возвращает имена полей Pydantic-схемы.\n    \"\"\"\n    if hasattr(schema_cls, '__fields__'):\n        return list(schema_cls.__fields__.keys())\n    return [k for k in dir(schema_cls) if not k.startswith('_')]",
      "imports": [],
      "calls": [
        "dir",
        "k",
        "keys",
        "hasattr",
        "list",
        "startswith"
      ]
    },
    {
      "id": "function:calc_distance@app/geo_utils.py",
      "name": "calc_distance",
      "type": "function",
      "layer": "Прочее",
      "file_path": "app/geo_utils.py",
      "docstring": "",
      "source_code": "def calc_distance(\n        coord0: tuple[float, float, float | None],\n        coord1: tuple[float, float, float | None],\n        geod: Geod | None = None\n) -> float:\n    if geod is None:\n        geod = Geod(ellps='WGS84')\n    # distance 2d\n    az_f, az_b, distance = geod.inv(coord0[0], coord0[1], coord1[0], coord1[1])\n    if coord0[2] is not None and coord1[2] is not None:\n        # distance 3d\n        distance = math.hypot(distance, coord1[2] - coord0[2])\n    return distance",
      "imports": [],
      "calls": [
        "Geod",
        "inv",
        "hypot",
        "math",
        "geod"
      ]
    },
    {
      "id": "function:local_to_global@app/geo_utils.py",
      "name": "local_to_global",
      "type": "function",
      "layer": "Прочее",
      "file_path": "app/geo_utils.py",
      "docstring": "",
      "source_code": "def local_to_global(\n        x: float,\n        y: float,\n        z: float | None,\n        lat0: float,\n        lon0: float,\n        alt0: float | None\n) -> tuple[float, float, float | None]:\n    rad = 0 * math.pi / 180\n    cos_r = math.cos(rad)\n    sin_r = math.sin(rad)\n    rx = x * cos_r - y * sin_r\n    ry = x * sin_r + y * cos_r\n\n    metersPerDegree = 111000\n    delta_lat = ry / metersPerDegree\n    delta_lon = rx / (metersPerDegree * math.cos(lat0 * math.pi / 180))\n\n    if z is not None and alt0 is not None:\n        alt = alt0 + z\n    else:\n        alt = None\n\n    return lat0 + delta_lat, lon0 + delta_lon, alt",
      "imports": [],
      "calls": [
        "math",
        "cos",
        "sin"
      ]
    },
    {
      "id": "function:read_root@app/main.py",
      "name": "read_root",
      "type": "function",
      "layer": "Прочее",
      "file_path": "app/main.py",
      "docstring": "",
      "source_code": "def read_root():\n    return {\"message\": \"QSimMine API запущен! Перейди в /docs\"}",
      "imports": [],
      "calls": [
        "get",
        "app"
      ]
    },
    {
      "id": "class:Base@app/models.py",
      "name": "Base",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "",
      "methods": [],
      "source_code": "class Base(DeclarativeBase):\n    metadata = MetaData(naming_convention={\n        \"ix\": \"ix_%(column_0_label)s\",\n        \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n        \"ck\": \"ck_%(table_name)s_%(constraint_name)s\",\n        \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n        \"pk\": \"pk_%(table_name)s\",\n    })",
      "imports": [],
      "calls": [
        "MetaData"
      ]
    },
    {
      "id": "class:DefaultValuesMixin@app/models.py",
      "name": "DefaultValuesMixin",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Миксин для сбора значений по умолчанию",
      "methods": [
        "collect_default_values",
        "collect_default_values_of_all_models"
      ],
      "source_code": "class DefaultValuesMixin:\n    \"\"\"Миксин для сбора значений по умолчанию\"\"\"\n\n    @classmethod\n    def collect_default_values(cls) -> dict[str, Any]:\n        # cls: db.Model\n        result = {}\n        # field: Column\n        for field in cls.__table__.columns.values():\n            if getattr(field.default, 'is_scalar', False):\n                result[field.name] = field.default.arg\n        return result\n\n    @classmethod\n    def collect_default_values_of_all_models(cls):\n        # cls: db.Model\n\n        result = {}\n        # mapper: Mapper\n\n        for mapper in Base.registry.mappers:\n            if issubclass(mapper.class_, cls):\n                dv_dict = mapper.class_.collect_default_values()\n                if dv_dict:\n                    result[mapper.class_.__tablename__] = dv_dict\n        return result",
      "imports": [],
      "calls": [
        "getattr",
        "collect_default_values",
        "issubclass",
        "values"
      ]
    },
    {
      "id": "class:LocationMixin@app/models.py",
      "name": "LocationMixin",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Миксин для локации",
      "methods": [
        "initial_location",
        "set_location"
      ],
      "source_code": "class LocationMixin:\n    \"\"\"Миксин для локации\"\"\"\n\n    initial_lat: Mapped[float] = mapped_column(default=0.0)\n    \"\"\"Исходная широта, °\"\"\"\n    initial_lon: Mapped[float] = mapped_column(default=0.0)\n    \"\"\"Исходная долгота, °\"\"\"\n    initial_height: Mapped[float] = mapped_column(default=0.0)\n    \"\"\"Исходная высота, м\"\"\"\n\n    @property\n    def initial_location(self) -> List[float]:\n        return [self.initial_lat, self.initial_lon, self.initial_height]\n    \n    location = initial_location\n\n    def set_location(self, location: List[float]) -> None:\n        if len(location) == 2:\n            lat, lon = location\n            self.initial_lat = lat\n            self.initial_lon = lon\n        elif len(location) == 3:\n            lat, lon, height = location\n            self.initial_lat = lat\n            self.initial_lon = lon\n            self.initial_height = height",
      "imports": [],
      "calls": [
        "len",
        "mapped_column"
      ]
    },
    {
      "id": "class:BaseObject@app/models.py",
      "name": "BaseObject",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Абстрактная базовая модель для объектов",
      "methods": [
        "__repr__"
      ],
      "source_code": "class BaseObject(Base):\n    \"\"\"Абстрактная базовая модель для объектов\"\"\"\n\n    __abstract__ = True\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    \"\"\"ID\"\"\"\n    name: Mapped[str] = mapped_column(String(100))\n    \"\"\"Название\"\"\"\n\n    created_at: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True), default=utc_now, server_default=func.now()\n    )\n    \"\"\"Таймштамп создания\"\"\"\n    updated_at: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True), default=utc_now, server_default=func.now(), onupdate=utc_now\n    )\n    \"\"\"Таймштамп изменения\"\"\"\n\n    def __repr__(self):\n        return f'<{self.__class__.__name__} {self.id}: {self.name}>'",
      "imports": [],
      "calls": [
        "mapped_column",
        "now",
        "String",
        "func",
        "DateTime"
      ]
    },
    {
      "id": "class:BaseVehicle@app/models.py",
      "name": "BaseVehicle",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Абстрактная базовая модель для транспортных средств",
      "methods": [],
      "source_code": "class BaseVehicle(BaseObject):\n    \"\"\"Абстрактная базовая модель для транспортных средств\"\"\"\n\n    __abstract__ = True\n\n    is_calc_enabled: Mapped[bool] = mapped_column(Boolean, default=True)\n    \"\"\"Включён ли расчёт по физическим параметрам и справочным характеристикам\"\"\"",
      "imports": [],
      "calls": [
        "mapped_column"
      ]
    },
    {
      "id": "class:Blasting@app/models.py",
      "name": "Blasting",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Расписание взрывных работ",
      "methods": [],
      "source_code": "class Blasting(BaseObject):\n    \"\"\"Расписание взрывных работ\"\"\"\n\n    __tablename__ = \"blasting\"\n\n    name = None\n\n    geojson_data: Mapped[dict] = mapped_column(JSONB, default={}, server_default='{}')\n    \"\"\"Геозона проведения взрывных работ (GeoJSON)\"\"\"\n\n    start_time: Mapped[datetime] = mapped_column(DateTime(timezone=True))\n    \"\"\"Начало взрывных работ\"\"\"\n    end_time: Mapped[datetime] = mapped_column(DateTime(timezone=True))\n    \"\"\"Окончание взрывных работ\"\"\"\n\n    quarry_id: Mapped[int] = mapped_column(ForeignKey('quarry.id', ondelete='CASCADE'))\n    \"\"\"ID карьера\"\"\"\n    quarry: Mapped['Quarry'] = relationship(back_populates='blasting_list')\n    \"\"\"Карьер\"\"\"",
      "imports": [],
      "calls": [
        "relationship",
        "ForeignKey",
        "mapped_column",
        "DateTime"
      ]
    },
    {
      "id": "class:ShovelArgsMixin@app/models.py",
      "name": "ShovelArgsMixin",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Основные параметры экскаватора для обсчёта симуляции",
      "methods": [],
      "source_code": "class ShovelArgsMixin:\n    \"\"\"Основные параметры экскаватора для обсчёта симуляции\"\"\"\n\n    bucket_volume: Mapped[float] = mapped_column(default=1.2)\n    \"\"\"Объём ковша (obem_kovsha_m3), м³\"\"\"\n    bucket_lift_speed: Mapped[float] = mapped_column(default=0.6)\n    \"\"\"Скорость подъёма ковша (skorost_podem_m_s), м/с\"\"\"\n    arm_turn_angle: Mapped[float] = mapped_column(default=90, server_default='90')\n    \"\"\"Количество градусов в одном обороте (arm_turn_angle)\"\"\"\n    arm_turn_speed: Mapped[float] = mapped_column(default=0.8)\n    \"\"\"Угловая скорость поворота стрелы (skorost_povorot_rad_s), рад/с\"\"\"\n    bucket_dig_speed: Mapped[float] = mapped_column(default=0.15)\n    \"\"\"Скорость врезки ковша в грунт (skorost_vrezki_m_s), м/с\"\"\"\n    bucket_fill_speed: Mapped[float] = mapped_column(default=0.07)\n    \"\"\"Скорость наполнения ковша (skorost_napolneniya_m_s), м/с\"\"\"\n    bucket_fill_coef: Mapped[float] = mapped_column(default=0.9)\n    \"\"\"Коэффициент заполнения ковша (koef_zapolneniya)\"\"\"\n    arm_inertia_coef: Mapped[float] = mapped_column(default=1.2)\n    \"\"\"Коэффициент инерции стрелы (koef_inertsii)\"\"\"\n    return_move_coef: Mapped[float] = mapped_column(default=0.85)\n    \"\"\"Коэффициент возвратного движения (koef_vozvrata)\"\"\"\n    payload_type: Mapped[PayloadType] = mapped_column(default=PayloadType.GRAVEL)\n    \"\"\"Тип груза (tip_porody)\"\"\"\n    initial_operating_time: Mapped[int] = mapped_column(default=12, server_default='12')\n    \"\"\"Продолжительность безотказной работы (на начало моделирования), час\"\"\"\n    initial_failure_count: Mapped[int] = mapped_column(default=100, server_default='100')\n    \"\"\"Зафиксировано отказов (на начало моделирования), шт\"\"\"\n    average_repair_duration: Mapped[int] = mapped_column(default=8, server_default='8')\n    \"\"\"Средняя продолжительность ремонта, мин\"\"\"",
      "imports": [],
      "calls": [
        "mapped_column"
      ]
    },
    {
      "id": "class:ShovelTemplate@app/models.py",
      "name": "ShovelTemplate",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Шаблон экскаватора",
      "methods": [],
      "source_code": "class ShovelTemplate(DefaultValuesMixin, ShovelArgsMixin, BaseObject):\n    \"\"\"Шаблон экскаватора\"\"\"\n\n    __tablename__ = \"shovel_template\"\n\n    shovels: Mapped[List['Shovel']] = relationship(back_populates='template')\n    \"\"\"Экскаваторы\"\"\"",
      "imports": [],
      "calls": [
        "relationship"
      ]
    },
    {
      "id": "class:Shovel@app/models.py",
      "name": "Shovel",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Экскаватор",
      "methods": [],
      "source_code": "class Shovel(DefaultValuesMixin, ShovelArgsMixin, LocationMixin, BaseVehicle):\n    \"\"\"Экскаватор\"\"\"\n\n    __tablename__ = \"shovel\"\n\n    template_id: Mapped[Optional[int]] = mapped_column(ForeignKey('shovel_template.id', ondelete='SET NULL'))\n    \"\"\"ID шаблона\"\"\"\n    template: Mapped[Optional['ShovelTemplate']] = relationship(back_populates='shovels')\n    \"\"\"Шаблон\"\"\"\n\n    quarry_id: Mapped[int] = mapped_column(ForeignKey('quarry.id', ondelete='CASCADE'))\n    \"\"\"ID карьера\"\"\"\n    quarry: Mapped['Quarry'] = relationship(back_populates='shovels')\n    \"\"\"Карьер\"\"\"\n\n    trails: Mapped[List['Trail']] = relationship(back_populates='shovel')\n    \"\"\"Маршруты\"\"\"",
      "imports": [],
      "calls": [
        "relationship",
        "ForeignKey",
        "mapped_column"
      ]
    },
    {
      "id": "class:TruckArgsMixin@app/models.py",
      "name": "TruckArgsMixin",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Основные параметры самосвала для обсчёта симуляции",
      "methods": [],
      "source_code": "class TruckArgsMixin:\n    \"\"\"Основные параметры самосвала для обсчёта симуляции\"\"\"\n\n    body_capacity: Mapped[float] = mapped_column(default=10.0)\n    \"\"\"Грузоподъемность кузова, т\"\"\"\n    speed_empty: Mapped[float] = mapped_column(default=35.0)\n    \"\"\"Скорость порожним (speed_empty_kmh), км/ч\"\"\"\n    speed_loaded: Mapped[float] = mapped_column(default=18.0)\n    \"\"\"Скорость гружёным (speed_loaded_kmh), км/ч\"\"\"\n    initial_operating_time: Mapped[int] = mapped_column(default=12, server_default='12')\n    \"\"\"Продолжительность безотказной работы (на начало моделирования), час\"\"\"\n    initial_failure_count: Mapped[int] = mapped_column(default=50, server_default='50')\n    \"\"\"Зафиксировано отказов (на начало моделирования), шт\"\"\"\n    average_repair_duration: Mapped[int] = mapped_column(default=4, server_default='4')\n    \"\"\"Средняя продолжительность ремонта, мин\"\"\"\n\n    # --- топливная модель ---\n    fuel_capacity: Mapped[float] = mapped_column(default=200, server_default='200')\n    \"\"\"Объем бака, л\"\"\"\n    fuel_threshold_critical: Mapped[float] = mapped_column(default=50, server_default='50')\n    \"\"\"Критический уровень топлива, л (0.25 * fuel_capacity)\"\"\"\n    fuel_threshold_planned: Mapped[float] = mapped_column(default=80, server_default='80')\n    \"\"\"Порог плановой заправки, л (0.4 * fuel_capacity)\"\"\"\n    fuel_level: Mapped[float] = mapped_column(default=200, server_default='200')\n    \"\"\"Стартовый уровень топлива, л\"\"\"\n    fuel_idle_lph: Mapped[float] = mapped_column(default=15, server_default='15')\n    \"\"\"Холостой расход топлива, л/ч\"\"\"\n    fuel_specific_consumption: Mapped[float] = mapped_column(default=205, server_default='205')\n    \"\"\"Удельный расход топлива при номинальной мощности, г/кВт*ч\"\"\"\n    fuel_density: Mapped[float] = mapped_column(default=0.82, server_default='0.82')\n    \"\"\"Плотность топлива при 15 °C, кг/л\"\"\"\n    engine_power_kw: Mapped[float] = mapped_column(default=1716, server_default='1716')\n    \"\"\"Мощность двигателя, кВт\"\"\"",
      "imports": [],
      "calls": [
        "mapped_column"
      ]
    },
    {
      "id": "class:TruckTemplate@app/models.py",
      "name": "TruckTemplate",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Шаблон самосвала",
      "methods": [],
      "source_code": "class TruckTemplate(DefaultValuesMixin, TruckArgsMixin, BaseObject):\n    \"\"\"Шаблон самосвала\"\"\"\n\n    __tablename__ = \"truck_template\"\n\n    trucks: Mapped[List['Truck']] = relationship(back_populates='template')\n    \"\"\"Самосвалы\"\"\"",
      "imports": [],
      "calls": [
        "relationship"
      ]
    },
    {
      "id": "class:Truck@app/models.py",
      "name": "Truck",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Самосвал",
      "methods": [],
      "source_code": "class Truck(DefaultValuesMixin, TruckArgsMixin, LocationMixin, BaseVehicle):\n    \"\"\"Самосвал\"\"\"\n\n    __tablename__ = \"truck\"\n\n    template_id: Mapped[Optional[int]] = mapped_column(ForeignKey('truck_template.id', ondelete='SET NULL'))\n    \"\"\"ID шаблона\"\"\"\n    template: Mapped[Optional['TruckTemplate']] = relationship(back_populates='trucks')\n    \"\"\"Шаблон\"\"\"\n\n    quarry_id: Mapped[int] = mapped_column(ForeignKey('quarry.id', ondelete='CASCADE'))\n    \"\"\"ID карьера\"\"\"\n    quarry: Mapped['Quarry'] = relationship(back_populates='trucks')\n    \"\"\"Карьер\"\"\"\n\n    trail_associations: Mapped[List['TrailTruckAssociation']] = relationship(\n        back_populates='truck', cascade='all, delete-orphan'\n    )\n    \"\"\"Маршруты\"\"\"",
      "imports": [],
      "calls": [
        "relationship",
        "ForeignKey",
        "mapped_column"
      ]
    },
    {
      "id": "class:UnloadArgsMixin@app/models.py",
      "name": "UnloadArgsMixin",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Основные параметры пункта разгрузки для обсчёта симуляции",
      "methods": [],
      "source_code": "class UnloadArgsMixin:\n    \"\"\"Основные параметры пункта разгрузки для обсчёта симуляции\"\"\"\n\n    unload_type: Mapped[UnloadType] = mapped_column(default=UnloadType.HYDRAULIC)\n    \"\"\"Тип (type_unloading)\"\"\"\n    capacity: Mapped[int] = mapped_column(default=100000000)\n    \"\"\"Вместимость (capacity), т\"\"\"\n    angle: Mapped[float] = mapped_column(default=25.0)\n    \"\"\"Угол наклона платформы (angle), °\"\"\"\n    payload_type: Mapped[PayloadType] = mapped_column(default=PayloadType.GRAVEL)\n    \"\"\"Тип груза (material_type)\"\"\"\n    trucks_at_once: Mapped[int] = mapped_column(default=100, server_default='100')\n    \"\"\"Одновременно разгружающихся АС, шт\"\"\"\n    initial_operating_time: Mapped[int] = mapped_column(default=24, server_default='24')\n    \"\"\"Продолжительность безотказной работы (на начало моделирования), час\"\"\"\n    initial_failure_count: Mapped[int] = mapped_column(default=50, server_default='50')\n    \"\"\"Зафиксировано отказов (на начало моделирования), шт\"\"\"\n    average_repair_duration: Mapped[int] = mapped_column(default=24, server_default='24')\n    \"\"\"Средняя продолжительность ремонта, мин\"\"\"",
      "imports": [],
      "calls": [
        "mapped_column"
      ]
    },
    {
      "id": "class:UnloadTemplate@app/models.py",
      "name": "UnloadTemplate",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Шаблон пункта разгрузки",
      "methods": [],
      "source_code": "class UnloadTemplate(DefaultValuesMixin, UnloadArgsMixin, BaseObject):\n    \"\"\"Шаблон пункта разгрузки\"\"\"\n\n    __tablename__ = \"unload_template\"\n\n    unloads: Mapped[List['Unload']] = relationship(back_populates='template')\n    \"\"\"Пункты разгрузки\"\"\"",
      "imports": [],
      "calls": [
        "relationship"
      ]
    },
    {
      "id": "class:Unload@app/models.py",
      "name": "Unload",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Пункт разгрузки",
      "methods": [],
      "source_code": "class Unload(DefaultValuesMixin, UnloadArgsMixin, LocationMixin, BaseObject):\n    \"\"\"Пункт разгрузки\"\"\"\n\n    __tablename__ = \"unload\"\n\n    template_id: Mapped[Optional[int]] = mapped_column(ForeignKey('unload_template.id', ondelete='SET NULL'))\n    \"\"\"ID шаблона\"\"\"\n    template: Mapped[Optional['UnloadTemplate']] = relationship(back_populates='unloads')\n    \"\"\"Шаблон\"\"\"\n\n    quarry_id: Mapped[int] = mapped_column(ForeignKey('quarry.id', ondelete='CASCADE'))\n    \"\"\"ID карьера\"\"\"\n    quarry: Mapped['Quarry'] = relationship(back_populates='unloads')\n    \"\"\"Карьер\"\"\"\n\n    trails: Mapped[List['Trail']] = relationship(back_populates='unload')\n    \"\"\"Маршруты\"\"\"",
      "imports": [],
      "calls": [
        "relationship",
        "ForeignKey",
        "mapped_column"
      ]
    },
    {
      "id": "class:FuelStationArgsMixin@app/models.py",
      "name": "FuelStationArgsMixin",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Основные параметры заправки для обсчёта симуляции",
      "methods": [],
      "source_code": "class FuelStationArgsMixin:\n    \"\"\"Основные параметры заправки для обсчёта симуляции\"\"\"\n\n    num_pumps: Mapped[int] = mapped_column(default=2, server_default='2')\n    \"\"\"Количество пистолетов, шт\"\"\"\n    flow_rate: Mapped[float] = mapped_column(default=2.0, server_default='2.0')\n    \"\"\"Скорость подачи топлива, л/сек\"\"\"",
      "imports": [],
      "calls": [
        "mapped_column"
      ]
    },
    {
      "id": "class:FuelStationTemplate@app/models.py",
      "name": "FuelStationTemplate",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Шаблон заправки",
      "methods": [],
      "source_code": "class FuelStationTemplate(DefaultValuesMixin, FuelStationArgsMixin, BaseObject):\n    \"\"\"Шаблон заправки\"\"\"\n\n    __tablename__ = \"fuel_station_template\"\n\n    fuel_stations: Mapped[List['FuelStation']] = relationship(back_populates='template')\n    \"\"\"Заправки\"\"\"",
      "imports": [],
      "calls": [
        "relationship"
      ]
    },
    {
      "id": "class:FuelStation@app/models.py",
      "name": "FuelStation",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Заправка",
      "methods": [],
      "source_code": "class FuelStation(DefaultValuesMixin, FuelStationArgsMixin, LocationMixin, BaseObject):\n    \"\"\"Заправка\"\"\"\n\n    __tablename__ = \"fuel_station\"\n\n    template_id: Mapped[Optional[int]] = mapped_column(\n        ForeignKey('fuel_station_template.id', ondelete='SET NULL')\n    )\n    \"\"\"ID шаблона\"\"\"\n    template: Mapped[Optional['FuelStationTemplate']] = relationship(back_populates='fuel_stations')\n    \"\"\"Шаблон\"\"\"\n\n    quarry_id: Mapped[int] = mapped_column(ForeignKey('quarry.id', ondelete='CASCADE'))\n    \"\"\"ID карьера\"\"\"\n    quarry: Mapped['Quarry'] = relationship(back_populates='fuel_stations')\n    \"\"\"Карьер\"\"\"",
      "imports": [],
      "calls": [
        "relationship",
        "ForeignKey",
        "mapped_column"
      ]
    },
    {
      "id": "class:IdleArea@app/models.py",
      "name": "IdleArea",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Зона ожидания (пересменки, обеда и т.д.)",
      "methods": [
        "types"
      ],
      "source_code": "class IdleArea(DefaultValuesMixin, LocationMixin, BaseObject):\n    \"\"\"Зона ожидания (пересменки, обеда и т.д.)\"\"\"\n\n    __tablename__ = \"idle_area\"\n\n    quarry_id: Mapped[int] = mapped_column(ForeignKey('quarry.id', ondelete='CASCADE'))\n    \"\"\"ID карьера\"\"\"\n    quarry: Mapped['Quarry'] = relationship(back_populates='idle_areas')\n    \"\"\"Карьер\"\"\"\n\n    is_lunch_area: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)\n    is_shift_change_area: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)\n    is_blast_waiting_area: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)\n    is_repair_area: Mapped[bool] = mapped_column(Boolean, default=False, nullable=False)\n\n    @property\n    def types(self) -> List[str]:\n        types_list = []\n        if self.is_lunch_area:\n            types_list.append(\"зона обеда\")\n        if self.is_shift_change_area:\n            types_list.append(\"зона пересменки\")\n        if self.is_blast_waiting_area:\n            types_list.append(\"зона ожидания взрыва\")\n        if self.is_repair_area:\n            types_list.append(\"зона ремонта\")\n        return types_list",
      "imports": [],
      "calls": [
        "relationship",
        "mapped_column",
        "types_list",
        "append",
        "ForeignKey"
      ]
    },
    {
      "id": "class:Trail@app/models.py",
      "name": "Trail",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Маршрут",
      "methods": [
        "__repr__"
      ],
      "source_code": "class Trail(Base):\n    \"\"\"Маршрут\"\"\"\n\n    __tablename__ = \"trail\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    \"\"\"ID\"\"\"\n    trail_type: Mapped[TrailType] = mapped_column(default=TrailType.COMMON)\n    \"\"\"Тип\"\"\"\n    raw_graph: Mapped[str] = mapped_column(Text, default='')\n    \"\"\"Сырой граф\"\"\"\n\n    shovel_id: Mapped[int] = mapped_column(ForeignKey('shovel.id', ondelete='CASCADE'))\n    \"\"\"ID экскаватора\"\"\"\n    shovel: Mapped['Shovel'] = relationship(back_populates='trails')\n    \"\"\"Экскаватор\"\"\"\n\n    unload_id: Mapped[int] = mapped_column(ForeignKey('unload.id', ondelete='CASCADE'))\n    \"\"\"ID пункта разгрузки\"\"\"\n    unload: Mapped['Unload'] = relationship(back_populates='trails')\n    \"\"\"Пункт разгрузки\"\"\"\n\n    truck_associations: Mapped[List['TrailTruckAssociation']] = relationship(\n        back_populates='trail', cascade='all, delete-orphan'\n    )\n    \"\"\"Самосвалы\"\"\"\n\n    def __repr__(self):\n        return f'<{self.__class__.__name__} {self.id}: Shovel {self.shovel_id}, Unload {self.unload_id}>'",
      "imports": [],
      "calls": [
        "relationship",
        "ForeignKey",
        "mapped_column"
      ]
    },
    {
      "id": "class:TrailTruckAssociation@app/models.py",
      "name": "TrailTruckAssociation",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Ассоциация (промежуточная m2m модель) между маршрутом и самосвалом",
      "methods": [
        "__repr__"
      ],
      "source_code": "class TrailTruckAssociation(Base):\n    \"\"\"Ассоциация (промежуточная m2m модель) между маршрутом и самосвалом\"\"\"\n\n    __tablename__ = \"trail_truck_association\"\n\n    scenario_id: Mapped[int] = mapped_column(ForeignKey('scenario.id', ondelete='CASCADE'), primary_key=True)\n    \"\"\"ID сценария\"\"\"\n    scenario: Mapped['Scenario'] = relationship(back_populates='truck_associations')\n    \"\"\"Сценарий\"\"\"\n\n    trail_id: Mapped[int] = mapped_column(ForeignKey('trail.id', ondelete='CASCADE'), primary_key=True)\n    \"\"\"ID маршрута\"\"\"\n    trail: Mapped['Trail'] = relationship(back_populates='truck_associations')\n    \"\"\"Маршрут\"\"\"\n\n    truck_id: Mapped[int] = mapped_column(ForeignKey('truck.id', ondelete='CASCADE'), primary_key=True)\n    \"\"\"ID самосвала\"\"\"\n    truck: Mapped['Truck'] = relationship(back_populates='trail_associations')\n    \"\"\"Самосвал\"\"\"\n\n    def __repr__(self):\n        return f'<{self.__class__.__name__}: Trail {self.trail_id}, Truck {self.truck_id}>'",
      "imports": [],
      "calls": [
        "relationship",
        "ForeignKey",
        "mapped_column"
      ]
    },
    {
      "id": "class:Quarry@app/models.py",
      "name": "Quarry",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Карьер",
      "methods": [],
      "source_code": "class Quarry(DefaultValuesMixin, BaseObject):\n    \"\"\"Карьер\"\"\"\n\n    __tablename__ = \"quarry\"\n\n    center_lat: Mapped[float] = mapped_column(default=0.0, server_default='0.0')\n    \"\"\"Широта центра карьера, °\"\"\"\n    center_lon: Mapped[float] = mapped_column(default=0.0, server_default='0.0')\n    \"\"\"Долгота центра карьера, °\"\"\"\n    center_height: Mapped[float] = mapped_column(default=0.0, server_default='0.0')\n    \"\"\"Высота центра карьера, м\"\"\"\n    timezone: Mapped[str] = mapped_column(String(100), default=TZ, server_default=TZ)\n    \"\"\"Часовой пояс\"\"\"\n    shift_config: Mapped[list] = mapped_column(\n        JSON, default=COMMON_SHIFT_CONFIG, server_default=json.dumps(COMMON_SHIFT_CONFIG)\n    )\n    \"\"\"Разметка смен на сдвигах\"\"\"\n    work_break_duration: Mapped[int] = mapped_column(default=10, server_default='10')\n    \"\"\"Продолжительность перерывов, мин\"\"\"\n    work_break_rate: Mapped[int] = mapped_column(default=1, server_default='1')\n    \"\"\"Частота возникновения перерывов, шт/час\"\"\"\n    lunch_break_offset: Mapped[int] = mapped_column(default=360, server_default='360')\n    \"\"\"Сдвиг обеденного перерыва от начала смены, мин\"\"\"\n    lunch_break_duration: Mapped[int] = mapped_column(default=60, server_default='60')\n    \"\"\"Продолжительность обеденного перерыва, мин\"\"\"\n    shift_change_offset: Mapped[int] = mapped_column(default=690, server_default='690')\n    \"\"\"Сдвиг пересменки от начала смены, мин\"\"\"\n    shift_change_duration: Mapped[int] = mapped_column(default=30, server_default='30')\n    \"\"\"Продолжительность пересменки, мин\"\"\"\n\n    shovels: Mapped[List['Shovel']] = relationship(back_populates='quarry')\n    trucks: Mapped[List['Truck']] = relationship(back_populates='quarry')\n    \"\"\"Самосвалы\"\"\"\n    unloads: Mapped[List['Unload']] = relationship(back_populates='quarry')\n    \"\"\"Пункты разгрузки\"\"\"\n    fuel_stations: Mapped[List['FuelStation']] = relationship(back_populates='quarry')\n    \"\"\"Заправки\"\"\"\n    idle_areas: Mapped[List['IdleArea']] = relationship(back_populates='quarry')\n    \"\"\"Площадки пересменки/обеда/ожидания взрыва\"\"\"\n    scenarios: Mapped[List['Scenario']] = relationship(back_populates='quarry')\n    \"\"\"Сценарии карьера\"\"\"\n    blasting_list: Mapped[List['Blasting']] = relationship(back_populates='quarry')\n    \"\"\"Расписание взрывных работ\"\"\"\n\n    road_nets: Mapped[List['RoadNet']] = relationship(back_populates='quarry')\n    \"\"\"Дорожные сети\"\"\"\n    map_overlays: Mapped[List['MapOverlay']] = relationship(back_populates='quarry')\n    \"\"\"Подложки для карты\"\"\"",
      "imports": [],
      "calls": [
        "relationship",
        "mapped_column",
        "String",
        "json",
        "dumps"
      ]
    },
    {
      "id": "class:Scenario@app/models.py",
      "name": "Scenario",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Сценарий для моделирования",
      "methods": [],
      "source_code": "class Scenario(DefaultValuesMixin, BaseObject):\n    \"\"\"Сценарий для моделирования\"\"\"\n\n    __tablename__ = \"scenario\"\n\n    start_time: Mapped[datetime] = mapped_column(DateTime(timezone=True))\n    \"\"\"Начало сценария\"\"\"\n    end_time: Mapped[datetime] = mapped_column(DateTime(timezone=True))\n    \"\"\"Конец сценария\"\"\"\n    is_auto_truck_distribution: Mapped[bool] = mapped_column(Boolean, default=True)\n    \"\"\"Режим распределения автосамосвалов: True - автоматический, False - ручной\"\"\"\n\n    is_calc_reliability_enabled: Mapped[bool] = mapped_column(Boolean, default=False, server_default='false')\n    \"\"\"Активирован ли расчёт достоверного результата\"\"\"\n    process_num: Mapped[int | None] = mapped_column()\n    \"\"\"Размер пула процессов для параллельного запуска симуляций (None/null - авто), шт\"\"\"\n\n    init_runs_num: Mapped[int] = mapped_column(default=15, server_default='15')\n    \"\"\"Начальное количество результатов для этапной оценки стабильности, шт\"\"\"\n    step_runs_num: Mapped[int] = mapped_column(default=15, server_default='15')\n    \"\"\"Шаг прироста количества результатов, шт\"\"\"\n    max_runs_num: Mapped[int] = mapped_column(default=105, server_default='105')\n    \"\"\"Предельное количество результатов, шт\"\"\"\n\n    alpha: Mapped[float] = mapped_column(default=0.05, server_default='0.05')\n    \"\"\"Уровень α (0.05 → 95% предиктивный интервал)\"\"\"\n    r_target: Mapped[float] = mapped_column(default=0.05, server_default='0.05')\n    \"\"\"Порог относительной половины ширины t-интервала\"\"\"\n    delta_target: Mapped[float] = mapped_column(default=0.01, server_default='0.01')\n    \"\"\"Порог относительного сдвига медианы между этапами\"\"\"\n    consecutive: Mapped[int] = mapped_column(default=2, server_default='2')\n    \"\"\"Сколько раз подряд должны быть соблюдены оба порога, шт\"\"\"\n    boot_b: Mapped[int] = mapped_column(default=5000, server_default='5000')\n    \"\"\"Число пересэмплирований для бутстрэпа, шт\"\"\"\n\n    quarry_id: Mapped[int] = mapped_column(ForeignKey('quarry.id', ondelete='CASCADE'))\n    \"\"\"ID карьера\"\"\"\n    quarry: Mapped['Quarry'] = relationship(back_populates='scenarios')\n    \"\"\"Карьер\"\"\"\n\n    truck_associations: Mapped[List['TrailTruckAssociation']] = relationship(back_populates='scenario')\n    \"\"\"Маршруты сценария\"\"\"",
      "imports": [],
      "calls": [
        "relationship",
        "ForeignKey",
        "mapped_column",
        "DateTime"
      ]
    },
    {
      "id": "class:RoadNet@app/models.py",
      "name": "RoadNet",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Дорожная сеть",
      "methods": [
        "__repr__"
      ],
      "source_code": "class RoadNet(BaseObject):\n    \"\"\"Дорожная сеть\"\"\"\n\n    __tablename__ = \"road_net\"\n\n    name = None\n\n    geojson_data: Mapped[dict] = mapped_column(JSONB, default={}, server_default=text(\"'{}'::jsonb\"))\n    \"\"\"Граф дорог и связи с объектами (GeoJSON)\"\"\"\n\n    quarry_id: Mapped[int] = mapped_column(ForeignKey('quarry.id', ondelete='CASCADE'))\n    \"\"\"ID карьера\"\"\"\n    quarry: Mapped['Quarry'] = relationship(back_populates='road_nets')\n    \"\"\"Карьер\"\"\"\n\n    def __repr__(self):\n        return f'<{self.__class__.__name__} {self.id}>'",
      "imports": [],
      "calls": [
        "relationship",
        "ForeignKey",
        "mapped_column",
        "text"
      ]
    },
    {
      "id": "class:UploadedFile@app/models.py",
      "name": "UploadedFile",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Загруженный файл",
      "methods": [
        "__repr__",
        "delete_with_file"
      ],
      "source_code": "class UploadedFile(Base):\n    \"\"\"Загруженный файл\"\"\"\n\n    __tablename__ = \"uploaded_file\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    \"\"\"ID\"\"\"\n    name: Mapped[str] = mapped_column(String(255), unique=True)\n    \"\"\"Имя\"\"\"\n    path: Mapped[str] = mapped_column(String(4096))\n    \"\"\"Путь\"\"\"\n    size: Mapped[int] = mapped_column()\n    \"\"\"Размер\"\"\"\n    created_at: Mapped[datetime] = mapped_column(\n        DateTime(timezone=True), default=utc_now, server_default=func.now()\n    )\n    \"\"\"Таймштамп создания\"\"\"\n\n    def __repr__(self):\n        return f'<{self.__class__.__name__}: {self.name}>'\n\n    @classmethod\n    def delete_with_file(\n        cls, session: scoped_session[Session], id_: int | None = None, name: str | None = None\n    ) -> bool:\n        if not id_ and not name:\n            return False\n        if id_:\n            where_expr = cls.id == id_\n        else:\n            where_expr = cls.name == name\n\n        deleted_path = session.execute(\n            delete(cls).where(where_expr).returning(cls.path)\n        ).scalar()\n        if deleted_path is None:\n            return False\n\n        pathlib.Path(deleted_path).resolve().unlink(missing_ok=True)\n        return True",
      "imports": [],
      "calls": [
        "session",
        "pathlib",
        "mapped_column",
        "execute",
        "returning",
        "unlink",
        "String",
        "now",
        "resolve",
        "func",
        "where",
        "DateTime",
        "delete",
        "scalar",
        "Path"
      ]
    },
    {
      "id": "class:MapOverlay@app/models.py",
      "name": "MapOverlay",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Подложка карты",
      "methods": [],
      "source_code": "class MapOverlay(DefaultValuesMixin, BaseObject):\n    \"\"\"Подложка карты\"\"\"\n\n    __tablename__ = \"map_overlay\"\n\n    is_active: Mapped[bool] = mapped_column(default=True, server_default='true')\n    \"\"\"Доступна для отображения?\"\"\"\n\n    geojson_data: Mapped[Optional[dict]] = mapped_column(JSONB)\n    \"\"\"Данные подложки (GeoJSON)\"\"\"\n    anchor_lat: Mapped[Optional[float]] = mapped_column()\n    \"\"\"Широта привязки, °\"\"\"\n    anchor_lon: Mapped[Optional[float]] = mapped_column()\n    \"\"\"Долгота привязки, °\"\"\"\n    anchor_height: Mapped[Optional[float]] = mapped_column()\n    \"\"\"Высота привязки, м\"\"\"\n    color: Mapped[str] = mapped_column(String(9), default='#212121FF', server_default='#212121FF')\n    \"\"\"Цвет отрисовки (RGBA hex)\"\"\"\n    color_regex = r'^#[A-F0-9]{8}$'\n\n    source_file_id: Mapped[Optional[int]] = mapped_column(\n        ForeignKey('uploaded_file.id', ondelete='SET NULL'), unique=True\n    )\n    \"\"\"ID исходного файла\"\"\"\n    source_file: Mapped[Optional['UploadedFile']] = relationship()\n    \"\"\"Исходный файл\"\"\"\n\n    quarry_id: Mapped[int] = mapped_column(ForeignKey('quarry.id', ondelete='CASCADE'))\n    \"\"\"ID карьера\"\"\"\n    quarry: Mapped['Quarry'] = relationship(back_populates='map_overlays')\n    \"\"\"Карьер\"\"\"\n\n    __table_args__ = (\n        CheckConstraint(\n            or_(\n                geojson_data.is_not(None),\n                source_file_id.is_not(None),\n            ),\n            'source_file_or_geojson_data_is_not_null'\n        ),\n        CheckConstraint(\n            color.regexp_match(color_regex),\n            'color_is_rgba_hex'\n        ),\n    )",
      "imports": [],
      "calls": [
        "relationship",
        "mapped_column",
        "color",
        "or_",
        "String",
        "geojson_data",
        "CheckConstraint",
        "is_not",
        "source_file_id",
        "regexp_match",
        "ForeignKey"
      ]
    },
    {
      "id": "class:PlannedIdle@app/models.py",
      "name": "PlannedIdle",
      "type": "class",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "Плановый простой",
      "methods": [],
      "source_code": "class PlannedIdle(BaseObject):\n    \"\"\"Плановый простой\"\"\"\n\n    __tablename__ = \"planned_idle\"\n\n    name = None\n\n    vehicle_type: Mapped[str] = mapped_column(String(100))\n    \"\"\"Тип техники (Generic FK)\"\"\"\n    vehicle_id: Mapped[int] = mapped_column()\n    \"\"\"ID техники (Generic FK)\"\"\"\n    valid_vehicle_models = (Truck, Shovel)\n    \"\"\"Допустимая техника, модели (Generic FK)\"\"\"\n    valid_vehicle_types = tuple(m.__tablename__ for m in valid_vehicle_models)\n    \"\"\"Допустимая техника, типы (Generic FK)\"\"\"\n\n    start_time: Mapped[datetime] = mapped_column(DateTime(timezone=True))\n    \"\"\"Начало простоя\"\"\"\n    end_time: Mapped[datetime] = mapped_column(DateTime(timezone=True))\n    \"\"\"Окончание простоя\"\"\"\n\n    quarry_id: Mapped[int] = mapped_column(ForeignKey('quarry.id', ondelete='CASCADE'))\n    \"\"\"ID карьера\"\"\"\n    quarry: Mapped['Quarry'] = relationship()\n    \"\"\"Карьер\"\"\"\n\n    __table_args__ = (\n        Index('vehicle_type_id', vehicle_type, vehicle_id),\n        Index('time_range', start_time, end_time),\n        CheckConstraint(\n            vehicle_type.in_(valid_vehicle_types),\n            'vehicle_type_is_valid'\n        ),\n    )",
      "imports": [],
      "calls": [
        "relationship",
        "tuple",
        "mapped_column",
        "Index",
        "vehicle_type",
        "String",
        "CheckConstraint",
        "DateTime",
        "in_",
        "ForeignKey"
      ]
    },
    {
      "id": "function:validate_schedule_type@app/models.py",
      "name": "validate_schedule_type",
      "type": "function",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "",
      "source_code": "def validate_schedule_type(type: str):\n    if not type or type not in TYPE_SCHEDULE_MAP:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Invalid type. Valid types are: {list(TYPE_SCHEDULE_MAP.keys())}\",\n        )\n    return type",
      "imports": [],
      "calls": [
        "TYPE_SCHEDULE_MAP",
        "HTTPException",
        "keys",
        "list"
      ]
    },
    {
      "id": "function:validate_object_type@app/models.py",
      "name": "validate_object_type",
      "type": "function",
      "layer": "Модели данных",
      "file_path": "app/models.py",
      "docstring": "",
      "source_code": "def validate_object_type(type: str):\n    all_object_types = list(TYPE_SCHEDULE_MAP.keys()) + list(TYPE_MODEL_MAP.keys())\n    if not type or type not in all_object_types:\n        raise HTTPException(\n            status_code=400,\n            detail=f\"Invalid type. Valid types are: {list(TYPE_MODEL_MAP.keys())}\",\n        )\n    return type",
      "imports": [],
      "calls": [
        "TYPE_MODEL_MAP",
        "TYPE_SCHEDULE_MAP",
        "keys",
        "list",
        "HTTPException"
      ]
    },
    {
      "id": "class:RoadNetCleaner@app/road_net.py",
      "name": "RoadNetCleaner",
      "type": "class",
      "layer": "Прочее",
      "file_path": "app/road_net.py",
      "docstring": "",
      "methods": [
        "__init__",
        "clean",
        "__clean_graph_bonds_by_schema",
        "__clean_graph_bonds_by_data"
      ],
      "source_code": "class RoadNetCleaner(BaseRoadNetCleaner):\n\n    def __init__(self, quarry_id: int):\n        self.quarry_id = quarry_id\n\n    def clean(self, graph: RoadNetGraph, *args, **kwargs) -> None:\n        self.__clean_graph_bonds_by_schema(graph)\n        self.__clean_graph_bonds_by_data(graph)\n\n    @staticmethod\n    def __clean_graph_bonds_by_schema(graph: RoadNetGraph) -> None:\n        \"\"\"\n        Internal helper for sanitizing point bonds schema.\n        Broken and forbidden entries are silently dropped\n        \"\"\"\n\n        met_bonds = set()\n\n        for bonds in graph.vertices['bonds']:\n\n            idx_to_delete = []\n            for i, bond in enumerate(bonds):\n\n                if bond.get('type') not in BINDABLE_ENTITIES:\n                    idx_to_delete.append(i)\n                    continue\n\n                try:\n                    int(bond.get('id'))\n                except (ValueError, TypeError):\n                    idx_to_delete.append(i)\n                    continue\n\n                id_type_tuple = (bond['id'], bond['type'])\n                if id_type_tuple in met_bonds:\n                    idx_to_delete.append(i)\n                    continue\n\n                met_bonds.add((bond['id'], bond['type']))\n\n            for idx in reversed(idx_to_delete):\n                del bonds[idx]\n\n\n    def __clean_graph_bonds_by_data(self, graph: RoadNetGraph) -> None:\n        \"\"\"\n        Internal helper for sanitizing point bonds data.\n        Broken and forbidden entries are silently dropped\n        \"\"\"\n\n        bond_type_ids_map = defaultdict(set)\n        bond_vertex_map = defaultdict(set)\n\n        for vertex_idx, bonds in enumerate(graph.vertices['bonds']):\n            for bond in bonds:\n                bond_type_ids_map[bond['type']].add(bond['id'])\n                bond_vertex_map[(bond['id'], bond['type'])].add(vertex_idx)\n\n        for bond_type, ids in bond_type_ids_map.items():\n            model = TYPE_MODEL_MAP[bond_type]\n            db_ids = set(db.execute(\n                select(model.id).where(model.id.in_(ids), model.quarry_id == self.quarry_id)\n            ).scalars())\n            non_existent_ids = ids - db_ids\n            for non_existent_id in non_existent_ids:\n                for vertex_idx in bond_vertex_map[(non_existent_id, bond_type)]:\n                    for bond_idx, bond in enumerate(graph.vertices[vertex_idx]['bonds']):\n                        if bond['id'] == non_existent_id and bond['type'] == bond_type:\n                            del graph.vertices[vertex_idx]['bonds'][bond_idx]\n                            break",
      "imports": [],
      "calls": [
        "execute",
        "scalars",
        "add",
        "select",
        "idx_to_delete",
        "enumerate",
        "bond_type_ids_map",
        "reversed",
        "self",
        "__clean_graph_bonds_by_schema",
        "__clean_graph_bonds_by_data",
        "defaultdict",
        "append",
        "int",
        "where",
        "in_",
        "db",
        "met_bonds",
        "items",
        "get",
        "bond",
        "set"
      ]
    },
    {
      "id": "class:TimeRange@app/routes.py",
      "name": "TimeRange",
      "type": "class",
      "layer": "API/Роуты",
      "file_path": "app/routes.py",
      "docstring": "",
      "methods": [],
      "source_code": "class TimeRange(BaseModel):\n    start_time: str\n    end_time: str",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:QuarryDataResponse@app/routes.py",
      "name": "QuarryDataResponse",
      "type": "class",
      "layer": "API/Роуты",
      "file_path": "app/routes.py",
      "docstring": "",
      "methods": [],
      "source_code": "class QuarryDataResponse(BaseModel):\n    time: TimeRange\n    templates: Dict[str, List[Dict]]\n    quarry_list: List[Dict]",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:UpdateLocationRequest@app/routes.py",
      "name": "UpdateLocationRequest",
      "type": "class",
      "layer": "API/Роуты",
      "file_path": "app/routes.py",
      "docstring": "",
      "methods": [],
      "source_code": "class UpdateLocationRequest(BaseModel):\n    object_db_id: int\n    object_type: str\n    lat: float\n    lon: float",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:DeleteObjectRequest@app/routes.py",
      "name": "DeleteObjectRequest",
      "type": "class",
      "layer": "API/Роуты",
      "file_path": "app/routes.py",
      "docstring": "",
      "methods": [],
      "source_code": "class DeleteObjectRequest(BaseModel):\n    type: str\n    id: int",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ScheduleDataRequest@app/routes.py",
      "name": "ScheduleDataRequest",
      "type": "class",
      "layer": "API/Роуты",
      "file_path": "app/routes.py",
      "docstring": "",
      "methods": [],
      "source_code": "class ScheduleDataRequest(BaseModel):\n    date: str\n    quarry_id: int\n    type: str\n    shift_number: Optional[int] = None\n    start_time: Optional[str] = None\n    end_time: Optional[str] = None",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ShiftConfigException@app/shift.py",
      "name": "ShiftConfigException",
      "type": "class",
      "layer": "Прочее",
      "file_path": "app/shift.py",
      "docstring": "Базовое исключение для ошибок конфигурации смен.",
      "methods": [
        "__init__",
        "__str__"
      ],
      "source_code": "class ShiftConfigException(Exception):\n    \"\"\"\n    Базовое исключение для ошибок конфигурации смен.\n    \"\"\"\n\n    def __init__(self, message: str, status_code=None):\n        self.message = message\n        self.status_code = status_code or 400\n        super().__init__(message)\n\n    def __str__(self) -> str:\n        return self.message",
      "imports": [],
      "calls": [
        "super",
        "__init__"
      ]
    },
    {
      "id": "class:ShiftConfigParseException@app/shift.py",
      "name": "ShiftConfigParseException",
      "type": "class",
      "layer": "Прочее",
      "file_path": "app/shift.py",
      "docstring": "Парсинговые ошибки (дата/время и т.п.).",
      "methods": [],
      "source_code": "class ShiftConfigParseException(ShiftConfigException):\n    \"\"\"Парсинговые ошибки (дата/время и т.п.).\"\"\"\n    pass",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ShiftConfigSchemaException@app/shift.py",
      "name": "ShiftConfigSchemaException",
      "type": "class",
      "layer": "Прочее",
      "file_path": "app/shift.py",
      "docstring": "Ошибки схемы/структуры (оставляем на будущее).",
      "methods": [],
      "source_code": "class ShiftConfigSchemaException(ShiftConfigException):\n    \"\"\"Ошибки схемы/структуры (оставляем на будущее).\"\"\"\n    pass",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ShiftConfigDataException@app/shift.py",
      "name": "ShiftConfigDataException",
      "type": "class",
      "layer": "Прочее",
      "file_path": "app/shift.py",
      "docstring": "Ошибки данных (например 'Quarry not found', 'shift not found' и т.п.).",
      "methods": [],
      "source_code": "class ShiftConfigDataException(ShiftConfigException):\n    \"\"\"Ошибки данных (например 'Quarry not found', 'shift not found' и т.п.).\"\"\"\n    pass",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ShiftLogic@app/shift.py",
      "name": "ShiftLogic",
      "type": "class",
      "layer": "Прочее",
      "file_path": "app/shift.py",
      "docstring": "",
      "methods": [
        "__init__",
        "factory",
        "validate_shift_config",
        "for_date",
        "for_datetime",
        "for_range",
        "prev_from",
        "next_from"
      ],
      "source_code": "class ShiftLogic:\n\n    def __init__(self, offsets_tuple: Tuple['ShiftOffsetsDTO', ...]) -> None:\n        self.offsets_tuple = offsets_tuple\n\n    @classmethod\n    def factory(cls, shift_config: str | Mapping | Sequence) -> 'ShiftLogic':\n        if isinstance(shift_config, str):\n            try:\n                _shift_config = json.loads(shift_config)\n            except TypeError as exc:\n                raise ShiftConfigParseException('Improper type of json string') from exc\n            except json.JSONDecodeError as exc:\n                raise ShiftConfigParseException('Improper content of json string') from exc\n\n        elif isinstance(shift_config, Mapping):\n            _shift_config = [shift_config]\n\n        elif isinstance(shift_config, Sequence):\n            _shift_config = shift_config\n\n        else:\n            raise ShiftConfigParseException('Improper type of shift config data')\n\n        cls.validate_shift_config(_shift_config)\n\n        offsets_tuple = tuple(\n            ShiftOffsetsDTO(\n                timedelta(minutes=shift_offsets['begin_offset']),\n                timedelta(minutes=shift_offsets['end_offset'])\n            )\n            for shift_offsets in _shift_config\n        )\n        return cls(offsets_tuple)\n\n    @classmethod\n    def validate_shift_config(cls, shift_config: Any) -> None:\n        try:\n            jsonschema.validate(shift_config, SHIFT_OFFSETS_SCHEMA)\n        except jsonschema.ValidationError as exc:\n            raise ShiftConfigSchemaException('Improper shift config json schema') from exc\n\n        for i, shift_offsets in enumerate(shift_config):\n            if shift_offsets['begin_offset'] >= shift_offsets['end_offset']:\n                raise ShiftConfigDataException('Shifts must have positive duration')\n            if i > 0 and shift_offsets['begin_offset'] != shift_config[i-1]['end_offset']:\n                raise ShiftConfigDataException('Shifts must be in continuous sequence and in ascending order')\n        if shift_config[-1]['end_offset'] - shift_config[0]['begin_offset'] != 1440:\n            raise ShiftConfigDataException('Total shifts duration must be exaclty 24 hours')\n\n    def for_date(self, day: date, tzinfo: tzinfo | None = None) -> list['ShiftDTO']:\n        if tzinfo is None:\n            tzinfo = timezone.utc\n        result = []\n        day_start = datetime.combine(day, time.min, tzinfo)\n        for i, offsets in enumerate(self.offsets_tuple, 1):\n            result.append(ShiftDTO(\n                day=day,\n                begin_time=day_start + offsets.begin_offset,\n                end_time=day_start + offsets.end_offset,\n                number=i,\n                length=offsets.end_offset - offsets.begin_offset,\n                begin_offset=offsets.begin_offset,\n                end_offset=offsets.end_offset,\n            ))\n        return result\n\n    def for_datetime(self, moment: datetime) -> 'ShiftDTO':\n        day = moment.date()\n        day_td = timedelta(days=1)\n        days_in_scope = (day-day_td, day, day+day_td)\n        for day in days_in_scope:\n            day_start = datetime.combine(day, time.min, moment.tzinfo)\n            for i, offsets in enumerate(self.offsets_tuple, 1):\n                begin_time = day_start + offsets.begin_offset\n                end_time = day_start + offsets.end_offset\n                if begin_time <= moment < end_time:\n                    return ShiftDTO(\n                        day=day,\n                        begin_time=begin_time,\n                        end_time=end_time,\n                        number=i,\n                        length=offsets.end_offset - offsets.begin_offset,\n                        begin_offset=offsets.begin_offset,\n                        end_offset=offsets.end_offset,\n                    )\n        raise ShiftConfigDataException('Somehow it is improper shift config data')\n\n    def for_range(self, start: datetime, stop: datetime) -> list['ShiftDTO']:\n        start_shift = self.for_datetime(start)\n        end_shift = self.for_datetime(stop)\n\n        cur_day = start_shift.day\n        cur_number = start_shift.number\n        result = [start_shift]\n        shifts_per_day = len(self.offsets_tuple)\n\n        while cur_day != end_shift.day or cur_number != end_shift.number:\n            if cur_number >= shifts_per_day:\n                cur_number = 1\n                cur_day += timedelta(days=1)\n            else:\n                cur_number += 1\n\n            cur_day_start = datetime.combine(cur_day, time.min, start.tzinfo)\n            cur_config = self.offsets_tuple[cur_number-1]\n            result.append(ShiftDTO(\n                day=cur_day,\n                begin_time=cur_day_start + cur_config.begin_offset,\n                end_time=cur_day_start + cur_config.end_offset,\n                number=cur_number,\n                length=cur_config.end_offset - cur_config.begin_offset,\n                begin_offset=cur_config.begin_offset,\n                end_offset=cur_config.end_offset,\n            ))\n\n        return result\n\n    def prev_from(self, shift: 'ShiftDTO') -> 'ShiftDTO':\n        if shift.number <= 1:\n            prev_number = len(self.offsets_tuple)\n            prev_day = shift.day - timedelta(days=1)\n        else:\n            prev_number = shift.number - 1\n            prev_day = shift.day\n        prev_day_start = datetime.combine(prev_day, time.min, shift.begin_time.tzinfo)\n        offsets = self.offsets_tuple[prev_number - 1]\n        return ShiftDTO(\n            day=prev_day,\n            begin_time=prev_day_start + offsets.begin_offset,\n            end_time=prev_day_start + offsets.end_offset,\n            number=prev_number,\n            length=offsets.end_offset - offsets.begin_offset,\n            begin_offset=offsets.begin_offset,\n            end_offset=offsets.end_offset,\n        )\n\n    def next_from(self, shift: 'ShiftDTO') -> 'ShiftDTO':\n        if shift.number >= len(self.offsets_tuple):\n            next_number = 1\n            next_day = shift.day + timedelta(days=1)\n        else:\n            next_number = shift.number + 1\n            next_day = shift.day\n        next_day_start = datetime.combine(next_day, time.min, shift.begin_time.tzinfo)\n        offsets = self.offsets_tuple[next_number - 1]\n        return ShiftDTO(\n            day=next_day,\n            begin_time=next_day_start + offsets.begin_offset,\n            end_time=next_day_start + offsets.end_offset,\n            number=next_number,\n            length=offsets.end_offset - offsets.begin_offset,\n            begin_offset=offsets.begin_offset,\n            end_offset=offsets.end_offset,\n        )",
      "imports": [],
      "calls": [
        "tuple",
        "timedelta",
        "jsonschema",
        "loads",
        "ShiftDTO",
        "cls",
        "result",
        "date",
        "enumerate",
        "validate_shift_config",
        "self",
        "json",
        "isinstance",
        "validate",
        "ShiftConfigParseException",
        "combine",
        "len",
        "moment",
        "append",
        "for_datetime",
        "ShiftConfigSchemaException",
        "ShiftConfigDataException",
        "ShiftOffsetsDTO",
        "datetime"
      ]
    },
    {
      "id": "class:ShiftOffsetsDTO@app/shift.py",
      "name": "ShiftOffsetsDTO",
      "type": "class",
      "layer": "Прочее",
      "file_path": "app/shift.py",
      "docstring": "",
      "methods": [],
      "source_code": "class ShiftOffsetsDTO:\n    begin_offset: timedelta\n    end_offset: timedelta",
      "imports": [],
      "calls": [
        "dataclass"
      ]
    },
    {
      "id": "class:ShiftDTO@app/shift.py",
      "name": "ShiftDTO",
      "type": "class",
      "layer": "Прочее",
      "file_path": "app/shift.py",
      "docstring": "",
      "methods": [],
      "source_code": "class ShiftDTO:\n    day: date\n    begin_time: datetime\n    end_time: datetime\n    number: int\n    length: timedelta\n    begin_offset: timedelta\n    end_offset: timedelta",
      "imports": [],
      "calls": [
        "dataclass"
      ]
    },
    {
      "id": "function:utc_now@app/utils.py",
      "name": "utc_now",
      "type": "function",
      "layer": "Утилиты",
      "file_path": "app/utils.py",
      "docstring": "",
      "source_code": "def utc_now():\n    return datetime.now(timezone.utc)",
      "imports": [],
      "calls": [
        "datetime",
        "now"
      ]
    },
    {
      "id": "function:utc_to_enterprise@app/utils.py",
      "name": "utc_to_enterprise",
      "type": "function",
      "layer": "Утилиты",
      "file_path": "app/utils.py",
      "docstring": "Конвертирует UTC время в указанную таймзону",
      "source_code": "def utc_to_enterprise(utc_time: str, tz: str = TZ) -> datetime:\n    \"\"\"Конвертирует UTC время в указанную таймзону\"\"\"\n    return datetime.fromisoformat(utc_time.replace('Z', '+00:00'))\\\n                  .replace(tzinfo=timezone.utc)\\\n                  .astimezone(ZoneInfo(tz))",
      "imports": [],
      "calls": [
        "ZoneInfo",
        "replace",
        "datetime",
        "fromisoformat",
        "astimezone",
        "utc_time"
      ]
    },
    {
      "id": "function:enterprise_to_utc@app/utils.py",
      "name": "enterprise_to_utc",
      "type": "function",
      "layer": "Утилиты",
      "file_path": "app/utils.py",
      "docstring": "Конвертирует локальное время предприятия в UTC",
      "source_code": "def enterprise_to_utc(local_time: str, tz: str = TZ) -> datetime:\n    \"\"\"Конвертирует локальное время предприятия в UTC\"\"\"\n    return datetime.fromisoformat(local_time)\\\n                  .replace(tzinfo=ZoneInfo(tz))\\\n                  .astimezone(timezone.utc)",
      "imports": [],
      "calls": [
        "ZoneInfo",
        "replace",
        "datetime",
        "fromisoformat",
        "astimezone"
      ]
    },
    {
      "id": "function:str_to_snake_case@app/utils.py",
      "name": "str_to_snake_case",
      "type": "function",
      "layer": "Утилиты",
      "file_path": "app/utils.py",
      "docstring": "",
      "source_code": "def str_to_snake_case(s: str) -> str:\n    # Add an underscore before each uppercase letter that is followed by a lowercase letter\n    s = re.sub(r'([A-Z]+)([A-Z][a-z])', r'\\1_\\2', s)\n    # Add an underscore before each lowercase letter that is preceded by an uppercase letter\n    s = re.sub(r'([a-z\\d])([A-Z])', r'\\1_\\2', s)\n    # Convert the entire string to lowercase\n    s = s.lower()\n    return s",
      "imports": [],
      "calls": [
        "sub",
        "s",
        "re",
        "lower"
      ]
    },
    {
      "id": "function:secure_filename@app/utils.py",
      "name": "secure_filename",
      "type": "function",
      "layer": "Утилиты",
      "file_path": "app/utils.py",
      "docstring": "Copy of :func:`werkzeug.utils.secure_filename`, but with `allow_unicode` arg\n\nPass it a filename and it will return a secure version of it.  This\nfilename can then safely be stored on a regular file system and passed\nto :func:`os.path.join`.  The filename returned is an ASCII only string\nfor maximum portability.\n\nOn windows systems the function also makes sure that the file is not\nnamed after one of the special device files.\n\n>>> secure_filename(\"My cool movie.mov\")\n'My_cool_movie.mov'\n>>> secure_filename(\"../../../etc/passwd\")\n'etc_passwd'\n>>> secure_filename('i contain cool \\xfcml\\xe4uts.txt')\n'i_contain_cool_umlauts.txt'\n\nThe function might return an empty filename.  It's your responsibility\nto ensure that the filename is unique and that you abort or\ngenerate a random filename if the function returned an empty one.\n\n.. versionadded:: 0.5\n\n:param filename: the filename to secure",
      "source_code": "def secure_filename(filename: str, allow_unicode: bool = False) -> str:\n    r\"\"\"Copy of :func:`werkzeug.utils.secure_filename`, but with `allow_unicode` arg\n\n    Pass it a filename and it will return a secure version of it.  This\n    filename can then safely be stored on a regular file system and passed\n    to :func:`os.path.join`.  The filename returned is an ASCII only string\n    for maximum portability.\n\n    On windows systems the function also makes sure that the file is not\n    named after one of the special device files.\n\n    >>> secure_filename(\"My cool movie.mov\")\n    'My_cool_movie.mov'\n    >>> secure_filename(\"../../../etc/passwd\")\n    'etc_passwd'\n    >>> secure_filename('i contain cool \\xfcml\\xe4uts.txt')\n    'i_contain_cool_umlauts.txt'\n\n    The function might return an empty filename.  It's your responsibility\n    to ensure that the filename is unique and that you abort or\n    generate a random filename if the function returned an empty one.\n\n    .. versionadded:: 0.5\n\n    :param filename: the filename to secure\n    \"\"\"\n    filename = unicodedata.normalize(\"NFKD\", filename)\n    if not allow_unicode:\n        filename = filename.encode(\"ascii\", \"ignore\").decode(\"ascii\")\n\n    for sep in os.sep, os.path.altsep:\n        if sep:\n            filename = filename.replace(sep, \" \")\n    if allow_unicode:\n        strip_re = _filename_unicode_strip_re\n    else:\n        strip_re = _filename_ascii_strip_re\n    filename = str(strip_re.sub(\"\", \"_\".join(filename.split()))).strip(\n        \"._\"\n    )\n\n    # on nt a couple of special files are present in each folder.  We\n    # have to ensure that the target file is not such a filename.  In\n    # this case we prepend an underline\n    if (\n        os.name == \"nt\"\n        and filename\n        and filename.split(\".\")[0].upper() in _windows_device_files\n    ):\n        filename = f\"_{filename}\"\n\n    return filename",
      "imports": [],
      "calls": [
        "decode",
        "strip",
        "replace",
        "upper",
        "encode",
        "split",
        "unicodedata",
        "strip_re",
        "str",
        "filename",
        "sub",
        "join",
        "normalize"
      ]
    },
    {
      "id": "function:human_size@app/utils.py",
      "name": "human_size",
      "type": "function",
      "layer": "Утилиты",
      "file_path": "app/utils.py",
      "docstring": "Return human-readable file size",
      "source_code": "def human_size(path: pathlib.Path) -> str:\n    \"\"\"Return human-readable file size\"\"\"\n    size = path.stat().st_size\n    for unit in ('B', 'KB', 'MB', 'GB', 'TB'):\n        if size < 1024:\n            return f'{size:.1f}{unit}'\n        size /= 1024\n    return f'{size:.1f}PB'",
      "imports": [],
      "calls": [
        "path",
        "stat"
      ]
    },
    {
      "id": "function:get_db@app/__init__.py",
      "name": "get_db",
      "type": "function",
      "layer": "Прочее",
      "file_path": "app/__init__.py",
      "docstring": "",
      "source_code": "def get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()",
      "imports": [],
      "calls": [
        "db",
        "close",
        "SessionLocal"
      ]
    },
    {
      "id": "function:get_redis@app/__init__.py",
      "name": "get_redis",
      "type": "function",
      "layer": "Прочее",
      "file_path": "app/__init__.py",
      "docstring": "",
      "source_code": "def get_redis():\n    return redis_client",
      "imports": [],
      "calls": []
    },
    {
      "id": "function:create_app@app/__init__.py",
      "name": "create_app",
      "type": "function",
      "layer": "Прочее",
      "file_path": "app/__init__.py",
      "docstring": "",
      "source_code": "def create_app(test_config=None):\n    app = FastAPI(\n        title=\"QSIMMINE12\",\n        lifespan=lifespan,\n        debug=os.getenv('APP_MODE') == 'dev'\n    )\n\n    app.state.config = {\n        'UPLOAD_FOLDER': 'uploads'\n    }\n    upload_folder = Path(app.state.config['UPLOAD_FOLDER'])\n    upload_folder.mkdir(exist_ok=True)\n\n    app.add_middleware(\n        CORSMiddleware,\n        allow_origins=[f\"https://{os.getenv('BASE_DOMAIN')}\"] if os.getenv('BASE_DOMAIN') else [\"*\"],\n        allow_credentials=True,\n        allow_methods=[\"GET\", \"PUT\", \"POST\", \"DELETE\", \"OPTIONS\"],\n        allow_headers=[\"Content-Type\", \"Authorization\", \"X-CSRF-Token\"],\n    )\n\n    app.mount(\"/static\", StaticFiles(directory=STATIC_DIR), name=\"static\")\n    app.mount(\"/upload\", StaticFiles(directory=UPLOAD_DIR), name=\"upload\")\n\n    from app.routes import router\n    app.include_router(router)\n\n    return app",
      "imports": [
        "router",
        "app"
      ],
      "calls": [
        "upload_folder",
        "app",
        "StaticFiles",
        "mount",
        "os",
        "mkdir",
        "FastAPI",
        "include_router",
        "add_middleware",
        "getenv",
        "Path"
      ]
    },
    {
      "id": "class:StartEndTimeDTO@app/services/date_time_service.py",
      "name": "StartEndTimeDTO",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/date_time_service.py",
      "docstring": "DTO содержит времена в UTC.",
      "methods": [],
      "source_code": "class StartEndTimeDTO(BaseModel):\n    \"\"\"\n    DTO содержит времена в UTC.\n    \"\"\"\n    start_time: datetime\n    end_time: datetime",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:StartEndTimeGenerateService@app/services/date_time_service.py",
      "name": "StartEndTimeGenerateService",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/date_time_service.py",
      "docstring": "Генерирует начало/конец рабочего дня в часовом поясе предприятия и возвращает их в UTC.\nПо умолчанию берёт таймзону из окружения TZ, иначе 'UTC'.",
      "methods": [
        "__init__",
        "_load_zone",
        "_current_date_in_enterprise_tz",
        "_generate_time_in_enterprise_tz",
        "_to_utc",
        "__call__"
      ],
      "source_code": "class StartEndTimeGenerateService:\n    \"\"\"\n    Генерирует начало/конец рабочего дня в часовом поясе предприятия и возвращает их в UTC.\n    По умолчанию берёт таймзону из окружения TZ, иначе 'UTC'.\n    \"\"\"\n\n    def __init__(self, tz_name: Optional[str] = None, start_hour: int = 10, end_hour: int = 18):\n        \"\"\"\n        :param tz_name: имя таймзоны (например, 'Europe/Berlin'). Если None — используется переменная окружения TZ или 'UTC'.\n        :param start_hour: час начала рабочего дня в локальном времени предприятия.\n        :param end_hour: час конца рабочего дня в локальном времени предприятия.\n        \"\"\"\n        self.tz_name = tz_name or os.getenv(\"TZ\", \"UTC\")\n        self.tz = self._load_zone(self.tz_name)\n        self.start_hour = int(start_hour)\n        self.end_hour = int(end_hour)\n\n    @staticmethod\n    def _load_zone(name: str) -> ZoneInfo:\n        try:\n            return ZoneInfo(name)\n        except ZoneInfoNotFoundError:\n            return ZoneInfo(\"UTC\")\n\n    def _current_date_in_enterprise_tz(self) -> date:\n        now = datetime.now(self.tz)\n        return now.date()\n\n    def _generate_time_in_enterprise_tz(self, on_date: date, hour: int) -> datetime:\n        return datetime(on_date.year, on_date.month, on_date.day, hour, 0, 0, tzinfo=self.tz)\n\n    @staticmethod\n    def _to_utc(dt: datetime) -> datetime:\n        return dt.astimezone(ZoneInfo(\"UTC\"))\n\n    def __call__(self) -> StartEndTimeDTO:\n        on_date = self._current_date_in_enterprise_tz()\n\n        start_local = self._generate_time_in_enterprise_tz(on_date, self.start_hour)\n        end_local = self._generate_time_in_enterprise_tz(on_date, self.end_hour)\n\n        start_utc = self._to_utc(start_local)\n        end_utc = self._to_utc(end_local)\n\n        return StartEndTimeDTO(start_time=start_utc, end_time=end_utc)",
      "imports": [],
      "calls": [
        "ZoneInfo",
        "self",
        "_load_zone",
        "datetime",
        "os",
        "StartEndTimeDTO",
        "now",
        "_to_utc",
        "_current_date_in_enterprise_tz",
        "astimezone",
        "int",
        "date",
        "_generate_time_in_enterprise_tz",
        "getenv",
        "dt"
      ]
    },
    {
      "id": "class:ObjectDAO@app/services/object_service.py",
      "name": "ObjectDAO",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/object_service.py",
      "docstring": "",
      "methods": [
        "__init__",
        "get_by_id",
        "delete_scenario_associations",
        "association_exists",
        "create_association"
      ],
      "source_code": "class ObjectDAO:\n    def __init__(self, db: Session):\n        self.db = db\n\n    def get_by_id(self, model, obj_id: int):\n        stmt = select(model).where(model.id == obj_id)\n        return self.db.execute(stmt).scalar()\n\n    def delete_scenario_associations(self, scenario_id: int):\n        self.db.execute(\n            delete(TrailTruckAssociation).where(\n                TrailTruckAssociation.scenario_id == scenario_id\n            )\n        )\n\n    def association_exists(self, scenario_id: int, trail_id: int, truck_id: int) -> bool:\n        stmt = select(TrailTruckAssociation).where(\n            TrailTruckAssociation.scenario_id == scenario_id,\n            TrailTruckAssociation.trail_id == trail_id,\n            TrailTruckAssociation.truck_id == truck_id,\n        )\n        return self.db.execute(stmt).scalar() is not None\n\n    def create_association(self, scenario_id: int, trail_id: int, truck_id: int):\n        assoc = TrailTruckAssociation(\n            scenario_id=scenario_id,\n            trail_id=trail_id,\n            truck_id=truck_id,\n        )\n        self.db.add(assoc)",
      "imports": [],
      "calls": [
        "execute",
        "TrailTruckAssociation",
        "add",
        "where",
        "select",
        "delete",
        "scalar"
      ]
    },
    {
      "id": "class:ObjectService@app/services/object_service.py",
      "name": "ObjectService",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/object_service.py",
      "docstring": "",
      "methods": [
        "__init__",
        "create_object",
        "update_object",
        "_dispatch"
      ],
      "source_code": "class ObjectService:\n    def __init__(self, db: Session):\n        self.db = db\n        self.dao = ObjectDAO(db)\n\n    def create_object(self, data: ObjectActionRequest):\n        return self._dispatch(data, action=\"create\")\n\n    def update_object(self, obj_id: int, data: ObjectActionRequest):\n        data.data[\"id\"] = obj_id\n        return self._dispatch(data, action=\"update\")\n\n    def _dispatch(self, data: ObjectActionRequest, action: str):\n        if not data.data:\n            raise HTTPException(status_code=400, detail=\"Invalid data\")\n\n        validate_object_type(data.type)\n\n        schema_cls = TYPE_SCHEMA_MAP.get(data.type)\n        model = TYPE_MODEL_MAP.get(data.type)\n\n        if data.type == \"scenario\":\n            service = ScenarioObjectService(self.db, self.dao, model, schema_cls)\n        elif data.type in (\"blasting\", \"planned_idle\"):\n            service = ScheduleObjectService(self.db, self.dao, model, schema_cls)\n        else:\n            service = GenericObjectService(self.db, self.dao, model, schema_cls)\n\n        return service.process(data, action)",
      "imports": [],
      "calls": [
        "validate_object_type",
        "self",
        "TYPE_MODEL_MAP",
        "_dispatch",
        "HTTPException",
        "ScheduleObjectService",
        "GenericObjectService",
        "ObjectDAO",
        "get",
        "TYPE_SCHEMA_MAP",
        "ScenarioObjectService",
        "service",
        "process"
      ]
    },
    {
      "id": "class:BaseObjectService@app/services/object_service.py",
      "name": "BaseObjectService",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/object_service.py",
      "docstring": "",
      "methods": [
        "__init__",
        "_prepare_data",
        "_validate_form",
        "_get_or_create",
        "_apply_form"
      ],
      "source_code": "class BaseObjectService:\n    def __init__(self, db: Session, dao: ObjectDAO, model, schema_cls):\n        self.db = db\n        self.dao = dao\n        self.model = model\n        self.schema_cls = schema_cls\n\n    def _prepare_data(self, data: dict, action: str) -> dict:\n        obj_data = data.copy()\n        if action == \"create\":\n            obj_data.pop(\"id\", None)\n\n        if \"segments\" in obj_data:\n            obj_data[\"raw_graph\"] = json.dumps(obj_data.get(\"segments\", []))\n            obj_data.pop(\"segments\", None)\n        return obj_data\n\n    def _validate_form(self, obj_data: dict):\n        try:\n            return self.schema_cls(**obj_data)\n        except ValidationError as exc:\n            raise HTTPException(\n                status_code=400,\n                detail={\"error\": \"Form validation failed\", \"errors\": exc.errors()},\n            )\n\n    def _get_or_create(self, obj_id, action: str):\n        if action == \"update\":\n            if not obj_id:\n                raise HTTPException(status_code=400, detail=\"Missing id for update\")\n            obj = self.dao.get_by_id(self.model, obj_id)\n            if not obj:\n                raise HTTPException(status_code=400, detail=\"Couldn't find object by id\")\n            return obj\n        obj = self.model()\n        self.db.add(obj)\n        return obj\n\n    def _apply_form(self, form, obj):\n        data_dict = form.dict(exclude_unset=True)\n        for field, value in data_dict.items():\n            if field in (\"id\", \"geojson_data\", \"geojson_points_data\", \"convert_overlay\"):\n                continue\n            setattr(obj, field, value)",
      "imports": [],
      "calls": [
        "add",
        "copy",
        "exc",
        "self",
        "obj_data",
        "schema_cls",
        "json",
        "dumps",
        "model",
        "dict",
        "HTTPException",
        "errors",
        "get_by_id",
        "items",
        "setattr",
        "data_dict",
        "get",
        "data",
        "form",
        "pop"
      ]
    },
    {
      "id": "class:GenericObjectService@app/services/object_service.py",
      "name": "GenericObjectService",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/object_service.py",
      "docstring": "",
      "methods": [
        "process"
      ],
      "source_code": "class GenericObjectService(BaseObjectService):\n    def process(self, data: ObjectActionRequest, action: str):\n        obj_data = self._prepare_data(data.data, action)\n\n        form = self._validate_form(obj_data)\n\n        obj = self._get_or_create(obj_data.get(\"id\"), action)\n        \n        if isinstance(form, TemplateMixin):\n            try:\n                form.verify_template_bond_reversed(obj)\n            except Exception as e:\n                raise HTTPException(status_code=400, detail=str(e))\n\n        self._apply_form(form, obj)\n\n        if isinstance(form, TemplateRefMixin):\n            form.verify_template_bond(obj)\n\n        if isinstance(form, RoadNetSchema):\n            form.save_geojson_data(obj)\n\n        if isinstance(form, MapOverlaySchema):\n            form.convert_dxf(obj)\n\n        self.db.commit()\n        self.db.refresh(obj)\n\n        return {\"success\": True, \"id\": obj.id}",
      "imports": [],
      "calls": [
        "self",
        "obj_data",
        "convert_dxf",
        "verify_template_bond_reversed",
        "_prepare_data",
        "commit",
        "get",
        "str",
        "refresh",
        "verify_template_bond",
        "form",
        "_apply_form",
        "isinstance",
        "_get_or_create",
        "HTTPException",
        "_validate_form",
        "save_geojson_data"
      ]
    },
    {
      "id": "class:ScheduleObjectService@app/services/object_service.py",
      "name": "ScheduleObjectService",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/object_service.py",
      "docstring": "",
      "methods": [
        "process"
      ],
      "source_code": "class ScheduleObjectService(BaseObjectService):\n    def process(self, data: ObjectActionRequest, action: str):\n        obj_data = self._prepare_data(data.data, action)\n        form = self._validate_form(obj_data)\n\n        if action == \"create\":\n            schedule_type = \"blasting\" if isinstance(form, BlastingSchema) else \"planned_idle\"\n            return form.handle_schedule_create(obj_data, self.model, schedule_type)\n\n        obj = self._get_or_create(obj_data.get(\"id\"), action)\n        self._apply_form(form, obj)\n        self.db.commit()\n        self.db.refresh(obj)\n\n        return {\"success\": True, \"id\": obj.id}",
      "imports": [],
      "calls": [
        "self",
        "obj_data",
        "_prepare_data",
        "commit",
        "get",
        "refresh",
        "handle_schedule_create",
        "form",
        "_apply_form",
        "isinstance",
        "_get_or_create",
        "_validate_form"
      ]
    },
    {
      "id": "class:ScenarioObjectService@app/services/object_service.py",
      "name": "ScenarioObjectService",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/object_service.py",
      "docstring": "",
      "methods": [
        "process"
      ],
      "source_code": "class ScenarioObjectService(BaseObjectService):\n    def process(self, data: ObjectActionRequest, action: str):\n        obj_data = self._prepare_data(data.data, action)\n        form = self._validate_form(obj_data)\n        obj = self._get_or_create(obj_data.get(\"id\"), action)\n\n        self._apply_form(form, obj)\n\n        if \"trails\" in obj_data:\n            if action == \"update\":\n                self.dao.delete_scenario_associations(obj.id)\n\n            for trail in obj_data[\"trails\"]:\n                trail_id = trail.get(\"id\")\n                for truck_id in trail.get(\"trucks\", []):\n                    if not self.dao.association_exists(obj.id, trail_id, truck_id):\n                        self.dao.create_association(obj.id, trail_id, truck_id)\n\n        if isinstance(form, TemplateRefMixin):\n            form.verify_template_bond(obj)\n\n        self.db.commit()\n        self.db.refresh(obj)\n        return {\"success\": True, \"id\": obj.id}",
      "imports": [],
      "calls": [
        "self",
        "obj_data",
        "trail",
        "association_exists",
        "_prepare_data",
        "commit",
        "get",
        "create_association",
        "refresh",
        "verify_template_bond",
        "form",
        "delete_scenario_associations",
        "_apply_form",
        "isinstance",
        "_get_or_create",
        "_validate_form"
      ]
    },
    {
      "id": "class:QuarryDataDTO@app/services/quarry_data_service.py",
      "name": "QuarryDataDTO",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/quarry_data_service.py",
      "docstring": "DTO, возвращаемый сервисом — содержит список карьеров в виде словарей.",
      "methods": [],
      "source_code": "class QuarryDataDTO(BaseModel):\n    \"\"\"\n    DTO, возвращаемый сервисом — содержит список карьеров в виде словарей.\n    \"\"\"\n    quarry_list: List[Dict[str, Any]]",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:QuarryDAO@app/services/quarry_data_service.py",
      "name": "QuarryDAO",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/quarry_data_service.py",
      "docstring": "",
      "methods": [
        "__init__",
        "fetch_all",
        "fetch_roadnet_id_pairs",
        "fetch_map_overlays_deferred_geojson",
        "fetch_trails_with_quarry_id"
      ],
      "source_code": "class QuarryDAO:\n    def __init__(self, db_session: Session):\n        self.db = db_session\n\n    def fetch_all(self, model) -> List:\n        \"\"\"\n        Универсальный fetch для простых моделей: select(model).order_by(model.id.asc()).\n        Возвращает список экземпляров модели.\n        \"\"\"\n        stmt = select(model).order_by(model.id.asc())\n        return self.db.execute(stmt).scalars().all()\n\n    def fetch_roadnet_id_pairs(self) -> List[Tuple[int, int]]:\n        \"\"\"\n        Возвращает список (roadnet.id, roadnet.quarry_id) упорядоченных по id ASC.\n        \"\"\"\n        stmt = select(RoadNet.id, RoadNet.quarry_id).order_by(RoadNet.id.asc())\n        return self.db.execute(stmt).all()\n\n    def fetch_map_overlays_deferred_geojson(self) -> List:\n        \"\"\"\n        Возвращает MapOverlay без подгрузки большого поля geojson_data.\n        \"\"\"\n        stmt = select(MapOverlay).order_by(MapOverlay.id.asc()).options(defer(MapOverlay.geojson_data))\n        return self.db.execute(stmt).scalars().all()\n\n    def fetch_trails_with_quarry_id(self) -> List[Tuple[\"Trail\", int]]:\n        \"\"\"\n        Возвращает список кортежей (Trail, quarry_id) — делается join через Shovel.\n        Также подгружаем associations (selectinload).\n        \"\"\"\n        stmt = (\n            select(Trail, Shovel.quarry_id)\n            .join(Shovel, Trail.shovel_id == Shovel.id)\n            .options(selectinload(Trail.truck_associations))\n            .order_by(Trail.id.asc())\n        )\n        return self.db.execute(stmt).all()",
      "imports": [],
      "calls": [
        "asc",
        "all",
        "defer",
        "scalars",
        "execute",
        "selectinload",
        "order_by",
        "select",
        "join",
        "options"
      ]
    },
    {
      "id": "class:QuarryDataService@app/services/quarry_data_service.py",
      "name": "QuarryDataService",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/quarry_data_service.py",
      "docstring": "Сервис, собирающий всю необходимую информацию по карьерам.\nВозвращает QuarryDataDTO — связи с роутером происходят через DTO.\nВнутри — DAO для запросов к БД.",
      "methods": [
        "__init__",
        "_model_to_dict",
        "__call__",
        "_init_quarries",
        "_load_related_models",
        "_apply_roadnet",
        "_load_map_overlays",
        "_load_trails"
      ],
      "source_code": "class QuarryDataService:\n    \"\"\"\n    Сервис, собирающий всю необходимую информацию по карьерам.\n    Возвращает QuarryDataDTO — связи с роутером происходят через DTO.\n    Внутри — DAO для запросов к БД.\n    \"\"\"\n\n    # Модели, по которым просто собираются списки (используются в _load_related_models)\n    SIMPLE_RELATED_MODELS = (\n        Shovel, Truck, Unload, FuelStation, IdleArea, Scenario, PlannedIdle\n    )\n    # Модели, для которых создаём пустые списки при инициализации quarry\n    ALL_RELATION_MODELS = (\n        Shovel, Truck, Unload, Trail, FuelStation, IdleArea, Scenario, MapOverlay, PlannedIdle\n    )\n\n    def __init__(self, db_session: Session):\n        self.dao = QuarryDAO(db_session)\n\n    @staticmethod\n    def _model_to_dict(model, instance) -> Dict[str, Any]:\n        \"\"\"\n        Преобразовать экземпляр модели в словарь по колонкам таблицы.\n        \"\"\"\n        column_names = [col.name for col in model.__table__.columns]\n        return {col_name: getattr(instance, col_name) for col_name in column_names}\n\n    def __call__(self) -> QuarryDataDTO:\n        \"\"\"\n        Выполнить сбор всей информации и вернуть QuarryDataDTO.\n        \"\"\"\n        quarry_map: Dict[int, Dict[str, Any]] = {}\n\n        # 1) Инициализация карьеров (основные поля + пустые списки для связей)\n        self._init_quarries(quarry_map)\n\n        # 2) Простые связанные модели (Shovel, Truck, ... PlannedIdle)\n        self._load_related_models(quarry_map)\n\n        # 3) RoadNet — присваиваем первый найденный roadnet.id для quarry\n        self._apply_roadnet(quarry_map)\n\n        # 4) MapOverlay — без поля geojson_data\n        self._load_map_overlays(quarry_map)\n\n        # 5) Trail — special processing (raw_graph -> segments, truck associations)\n        self._load_trails(quarry_map)\n\n        # Собираем результат в DTO\n        dto = QuarryDataDTO(quarry_list=list(quarry_map.values()))\n        return dto\n\n    def _init_quarries(self, quarry_map: Dict[int, Dict[str, Any]]):\n        \"\"\"\n        Создаёт запись в quarry_map для каждого Quarry: копирует все колонки таблицы\n        и создаёт пустые списки для связанных коллекций.\n        \"\"\"\n        quarry_cols = [col.name for col in Quarry.__table__.columns]\n        quarry_instances = self.dao.fetch_all(Quarry)\n        road_net_key_name = f'{RoadNet.__tablename__}_id'\n\n        for quarry in quarry_instances:\n            qdict = {col_name: getattr(quarry, col_name) for col_name in quarry_cols}\n            # создаём пустые списки для связей\n            for model in self.ALL_RELATION_MODELS:\n                qdict[f'{model.__tablename__}_list'] = []\n            qdict[road_net_key_name] = None\n            quarry_map[quarry.id] = qdict\n\n    def _load_related_models(self, quarry_map: Dict[int, Dict[str, Any]]):\n        \"\"\"\n        Загружает простые связанные сущности (без специальных преобразований).\n        \"\"\"\n        for model in self.SIMPLE_RELATED_MODELS:\n            model_key_name = f'{model.__tablename__}_list'\n            instances = self.dao.fetch_all(model)\n            model_cols = [col.name for col in model.__table__.columns]\n\n            for inst in instances:\n                quarry_id = getattr(inst, \"quarry_id\", None)\n                if quarry_id is None or quarry_id not in quarry_map:\n                    continue\n                item = {col: getattr(inst, col) for col in model_cols}\n                quarry_map[quarry_id][model_key_name].append(item)\n\n    def _apply_roadnet(self, quarry_map: Dict[int, Dict[str, Any]]):\n        \"\"\"\n        Устанавливает первую встреченную roadnet.id для каждого карьера (roadnet_id).\n        \"\"\"\n        road_net_key_name = f'{RoadNet.__tablename__}_id'\n        pairs = self.dao.fetch_roadnet_id_pairs()\n        for rn_id, quarry_id in pairs:\n            if quarry_id not in quarry_map:\n                continue\n            quarry_map[quarry_id][road_net_key_name] = quarry_map[quarry_id][road_net_key_name] or rn_id\n\n    def _load_map_overlays(self, quarry_map: Dict[int, Dict[str, Any]]):\n        \"\"\"\n        Загружает MapOverlay без поля geojson_data.\n        \"\"\"\n        mo_instances = self.dao.fetch_map_overlays_deferred_geojson()\n        mo_cols = [col.name for col in MapOverlay.__table__.columns]\n        key_name = f'{MapOverlay.__tablename__}_list'\n\n        for mo in mo_instances:\n            quarry_id = getattr(mo, \"quarry_id\", None)\n            if quarry_id is None or quarry_id not in quarry_map:\n                continue\n            item = {col: getattr(mo, col) for col in mo_cols if col != 'geojson_data'}\n            quarry_map[quarry_id][key_name].append(item)\n\n    def _load_trails(self, quarry_map: Dict[int, Dict[str, Any]]):\n        \"\"\"\n        Загружает Trail c преобразованием raw_graph -> segments и сбором truck_associations.\n        DAO возвращает [(Trail, quarry_id), ...]\n        \"\"\"\n        trail_key_name = f'{Trail.__tablename__}_list'\n        trail_rows = self.dao.fetch_trails_with_quarry_id()\n\n        for trail, quarry_id in trail_rows:\n            if quarry_id not in quarry_map:\n                continue\n            # raw_graph -> segments (обработка ошибок JSON)\n            segments = []\n            raw = getattr(trail, 'raw_graph', None)\n            if raw:\n                try:\n                    segments = json.loads(raw)\n                except json.decoder.JSONDecodeError:\n                    segments = []\n\n            # truck associations -> список id грузовиков\n            trucks = [assoc.truck_id for assoc in getattr(trail, \"truck_associations\", [])]\n\n            trail_dict = {\n                'id': trail.id,\n                'quarry_id': quarry_id,\n                'trail_type': trail.trail_type,\n                'shovel_id': trail.shovel_id,\n                'unload_id': trail.unload_id,\n                'segments': segments,\n                'trucks': trucks\n            }\n            quarry_map[quarry_id][trail_key_name].append(trail_dict)",
      "imports": [],
      "calls": [
        "_load_related_models",
        "_init_quarries",
        "loads",
        "list",
        "_load_trails",
        "self",
        "fetch_all",
        "json",
        "getattr",
        "quarry_map",
        "_apply_roadnet",
        "QuarryDAO",
        "append",
        "QuarryDataDTO",
        "_load_map_overlays",
        "values",
        "fetch_trails_with_quarry_id",
        "fetch_map_overlays_deferred_geojson",
        "fetch_roadnet_id_pairs"
      ]
    },
    {
      "id": "class:TrailDTO@app/services/scenario_service.py",
      "name": "TrailDTO",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/scenario_service.py",
      "docstring": "",
      "methods": [],
      "source_code": "class TrailDTO(BaseModel):\n    id: int\n    trail_type: str | None\n    shovel_id: int | None\n    unload_id: int | None\n    segments: List[Any]\n    trucks: List[int]",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ScenarioDTO@app/services/scenario_service.py",
      "name": "ScenarioDTO",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/scenario_service.py",
      "docstring": "",
      "methods": [],
      "source_code": "class ScenarioDTO(BaseModel):\n    id: int\n    name: str | None\n    start_time: datetime | None\n    end_time: datetime | None\n    quarry_id: int | None\n    is_auto_truck_distribution: bool | None\n    is_calc_reliability_enabled: bool | None\n    trails: List[TrailDTO]",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ScenarioDAO@app/services/scenario_service.py",
      "name": "ScenarioDAO",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/scenario_service.py",
      "docstring": "",
      "methods": [
        "__init__",
        "fetch_all_with_assocs",
        "fetch_trails_by_quarry"
      ],
      "source_code": "class ScenarioDAO:\n    def __init__(self, db_session: Session):\n        self.db = db_session\n\n    def fetch_all_with_assocs(self) -> List[Scenario]:\n        \"\"\"\n        Возвращает все Scenario.\n        \"\"\"\n        stmt = (\n            select(Scenario)\n            .options(\n                selectinload(Scenario.truck_associations),\n                selectinload(Scenario.quarry)\n            )\n            .order_by(Scenario.id.asc())\n        )\n        return self.db.execute(stmt).scalars().all()\n\n    def fetch_trails_by_quarry(self, quarry_id: int) -> List[Trail]:\n        \"\"\"\n        Возвращает Trail, принадлежащие карьерам quarry_id (через Shovel).\n        \"\"\"\n        stmt = (\n            select(Trail)\n            .join(Shovel, Trail.shovel_id == Shovel.id)\n            .where(Shovel.quarry_id == quarry_id)\n            .options(selectinload(Trail.truck_associations))\n            .order_by(Trail.id.asc())\n        )\n        return self.db.execute(stmt).scalars().all()",
      "imports": [],
      "calls": [
        "asc",
        "all",
        "execute",
        "scalars",
        "selectinload",
        "order_by",
        "select",
        "where",
        "join",
        "options"
      ]
    },
    {
      "id": "class:ScenarioService@app/services/scenario_service.py",
      "name": "ScenarioService",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/scenario_service.py",
      "docstring": "",
      "methods": [
        "__init__",
        "__call__",
        "_scenario_to_dto",
        "_build_assoc_map",
        "_load_and_transform_trails",
        "_trail_to_dto",
        "_parse_segments"
      ],
      "source_code": "class ScenarioService:\n    def __init__(self, db_session: Session):\n        self.dao = ScenarioDAO(db_session)\n\n    def __call__(self) -> List[ScenarioDTO]:\n        scenarios = self.dao.fetch_all_with_assocs()\n        return [self._scenario_to_dto(scenario) for scenario in scenarios]\n\n    def _scenario_to_dto(self, scenario) -> ScenarioDTO:\n        assoc_by_trail = self._build_assoc_map(scenario)\n        trails = self._load_and_transform_trails(scenario.quarry_id, assoc_by_trail)\n\n        return ScenarioDTO(\n            id=scenario.id,\n            name=scenario.name,\n            start_time=getattr(scenario, \"start_time\", None),\n            end_time=getattr(scenario, \"end_time\", None),\n            quarry_id=getattr(scenario, \"quarry_id\", None),\n            is_auto_truck_distribution=getattr(scenario, \"is_auto_truck_distribution\", None),\n            is_calc_reliability_enabled=getattr(scenario, \"is_calc_reliability_enabled\", None),\n            trails=trails\n        )\n\n    def _build_assoc_map(self, scenario) -> Dict[int, List[int]]:\n        assoc_by_trail: Dict[int, List[int]] = {}\n        for assoc in getattr(scenario, \"truck_associations\", []) or []:\n            trail_id = getattr(assoc, \"trail_id\", None)\n            truck_id = getattr(assoc, \"truck_id\", None)\n            if trail_id is None or truck_id is None:\n                continue\n            assoc_by_trail.setdefault(trail_id, []).append(truck_id)\n        return assoc_by_trail\n\n    def _load_and_transform_trails(\n        self,\n        quarry_id: Optional[int],\n        assoc_by_trail: Dict[int, List[int]]\n    ) -> List[TrailDTO]:\n        if quarry_id is None:\n            return []\n\n        trail_objs: List[Trail] = self.dao.fetch_trails_by_quarry(quarry_id)\n        trails_dto: List[TrailDTO] = [\n            self._trail_to_dto(trail, assoc_by_trail) for trail in trail_objs\n        ]\n        return trails_dto\n\n    def _trail_to_dto(self, trail, assoc_by_trail: Dict[int, List[int]]) -> TrailDTO:\n        segments = self._parse_segments(getattr(trail, \"raw_graph\", None))\n        trucks_in_scenario = assoc_by_trail.get(getattr(trail, \"id\"), [])\n\n        return TrailDTO(\n            id=trail.id,\n            trail_type=trail.trail_type,\n            shovel_id=trail.shovel_id,\n            unload_id=trail.unload_id,\n            segments=segments,\n            trucks=trucks_in_scenario\n        )\n\n    @staticmethod\n    def _parse_segments(raw_graph: Optional[str]) -> List[Any]:\n        if not raw_graph:\n            return []\n\n        try:\n            parsed = json.loads(raw_graph)\n            return parsed if isinstance(parsed, list) else []\n        except json.decoder.JSONDecodeError:\n            return []",
      "imports": [],
      "calls": [
        "fetch_trails_by_quarry",
        "_scenario_to_dto",
        "loads",
        "_parse_segments",
        "_trail_to_dto",
        "self",
        "fetch_all_with_assocs",
        "json",
        "isinstance",
        "getattr",
        "setdefault",
        "ScenarioDAO",
        "TrailDTO",
        "append",
        "_load_and_transform_trails",
        "_build_assoc_map",
        "get",
        "assoc_by_trail",
        "ScenarioDTO"
      ]
    },
    {
      "id": "class:ScheduleItemDTO@app/services/schedule_data_service.py",
      "name": "ScheduleItemDTO",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/schedule_data_service.py",
      "docstring": "",
      "methods": [],
      "source_code": "class ScheduleItemDTO(BaseModel):\n    id: int\n    quarry_id: int\n    start_time: datetime\n    end_time: datetime\n    geojson_data: Optional[Any] = None\n\n    class Config:\n        from_attributes = True",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ShiftDetailsDTO@app/services/schedule_data_service.py",
      "name": "ShiftDetailsDTO",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/schedule_data_service.py",
      "docstring": "",
      "methods": [],
      "source_code": "class ShiftDetailsDTO(BaseModel):\n    number: int\n    begin_time_enterprise: str\n    end_time_enterprise: str\n    day: str",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ScheduleDataResponseDTO@app/services/schedule_data_service.py",
      "name": "ScheduleDataResponseDTO",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/schedule_data_service.py",
      "docstring": "",
      "methods": [],
      "source_code": "class ScheduleDataResponseDTO(BaseModel):\n    time: dict\n    filters: dict\n    shift_details: Optional[ShiftDetailsDTO] = None\n    items: List[ScheduleItemDTO]",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ScheduleDAO@app/services/schedule_data_service.py",
      "name": "ScheduleDAO",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/schedule_data_service.py",
      "docstring": "DAO для выборки расписания из БД.",
      "methods": [
        "__init__",
        "fetch_filtered"
      ],
      "source_code": "class ScheduleDAO:\n    \"\"\"DAO для выборки расписания из БД.\"\"\"\n\n    def __init__(self, db_session: Session):\n        self.db = db_session\n\n    def fetch_filtered(\n        self,\n        model,\n        start_time_utc: datetime,\n        end_time_utc: datetime,\n        quarry_id: int,\n        schedule_type: str,\n    ) -> List[ScheduleItemDTO]:\n        \"\"\"Возвращает список отфильтрованных элементов расписания в виде DTO.\"\"\"\n\n        stmt = (\n            select(model)\n            .where(\n                model.quarry_id == quarry_id,\n                model.start_time < end_time_utc,\n                start_time_utc < model.end_time,\n            )\n            .order_by(model.id.asc())\n        )\n\n        res = self.db.execute(stmt).scalars().all()\n        model_cols = set(model.__table__.columns.keys())\n        items: List[ScheduleItemDTO] = []\n\n        for obj in res:\n            obj_dict = {col: getattr(obj, col) for col in model_cols}\n            if schedule_type == \"blasting\":\n                if isinstance(obj_dict.get(\"geojson_data\"), str):\n                    try:\n                        obj_dict[\"geojson_data\"] = json.loads(obj_dict[\"geojson_data\"])\n                    except json.JSONDecodeError:\n                        obj_dict[\"geojson_data\"] = None\n\n            items.append(ScheduleItemDTO(**obj_dict))\n\n        return items",
      "imports": [],
      "calls": [
        "asc",
        "all",
        "items",
        "execute",
        "scalars",
        "ScheduleItemDTO",
        "obj_dict",
        "loads",
        "get",
        "keys",
        "append",
        "order_by",
        "where",
        "select",
        "json",
        "isinstance",
        "set",
        "getattr"
      ]
    },
    {
      "id": "class:ScheduleDataService@app/services/schedule_data_service.py",
      "name": "ScheduleDataService",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/schedule_data_service.py",
      "docstring": "Сервис для получения расписания по дате и смене или временному диапазону.",
      "methods": [
        "__init__",
        "__call__",
        "_resolve_time_window"
      ],
      "source_code": "class ScheduleDataService:\n    \"\"\"Сервис для получения расписания по дате и смене или временному диапазону.\"\"\"\n\n    def __init__(self, db_session: Session):\n        self.db = db_session\n        self.dao = ScheduleDAO(db_session)\n\n    def __call__(\n        self,\n        model,\n        date_str: str,\n        quarry_id: int,\n        schedule_type: str,\n        enterprise_tz: ZoneInfo,\n        shift_number: Optional[int] = None,\n        start_time: Optional[str] = None,\n        end_time: Optional[str] = None,\n    ) -> ScheduleDataResponseDTO:\n        \"\"\"Основная точка входа.\"\"\"\n\n        quarry = self.db.get(Quarry, quarry_id)\n        if not quarry:\n            raise ShiftConfigDataException(\"Quarry not found\")\n\n        # --- вычисляем start_time_utc / end_time_utc ---\n        start_time_utc, end_time_utc, target_shift = self._resolve_time_window(\n            quarry, date_str, enterprise_tz, shift_number, start_time, end_time\n        )\n\n        # --- получаем элементы расписания ---\n        items = self.dao.fetch_filtered(\n            model=model,\n            start_time_utc=start_time_utc,\n            end_time_utc=end_time_utc,\n            quarry_id=quarry_id,\n            schedule_type=schedule_type,\n        )\n\n        # --- формируем DTO-ответ ---\n        return ScheduleDataResponseDTO(\n            time={\n                \"start_time\": start_time_utc.isoformat(),\n                \"end_time\": end_time_utc.isoformat(),\n            },\n            filters={\n                \"date\": date_str,\n                \"quarry_id\": quarry_id,\n                \"type\": schedule_type,\n                \"shift_number\": shift_number,\n                \"start_time\": start_time,\n                \"end_time\": end_time,\n            },\n            items=items,\n            shift_details=ShiftDetailsDTO(\n                number=target_shift.number,\n                begin_time_enterprise=target_shift.begin_time.isoformat(),\n                end_time_enterprise=target_shift.end_time.isoformat(),\n                day=target_shift.day.isoformat(),\n            )\n            if target_shift\n            else None,\n        )\n\n    # -------------------- helpers --------------------\n\n    def _resolve_time_window(\n        self,\n        quarry,\n        date_str: str,\n        enterprise_tz: ZoneInfo,\n        shift_number: Optional[int],\n        start_time: Optional[str],\n        end_time: Optional[str],\n    ):\n        \"\"\"Определяет временной диапазон по номеру смены или вручную заданным временам.\"\"\"\n        try:\n            date = datetime.strptime(date_str, \"%Y-%m-%d\").date()\n        except ValueError as e:\n            raise ShiftConfigParseException(str(e))\n\n        target_shift = None\n\n        if shift_number is not None:\n            shift_logic = ShiftLogic.factory(quarry.shift_config)\n            shifts_for_date = shift_logic.for_date(date, enterprise_tz)\n\n            if shift_number > len(shifts_for_date) or shift_number <= 0:\n                raise ShiftConfigDataException(f\"Shift number {shift_number} not found for date {date_str}\")\n\n            target_shift = shifts_for_date[shift_number - 1]\n            start_time_utc = target_shift.begin_time.astimezone(ZoneInfo(\"UTC\"))\n            end_time_utc = target_shift.end_time.astimezone(ZoneInfo(\"UTC\"))\n\n        elif start_time and end_time:\n            try:\n                start_dt = datetime.fromisoformat(start_time.replace(\"Z\", \"+00:00\"))\n                end_dt = datetime.fromisoformat(end_time.replace(\"Z\", \"+00:00\"))\n            except ValueError as e:\n                raise ShiftConfigParseException(str(e))\n\n            if start_dt.tzinfo is None:\n                start_dt = start_dt.replace(tzinfo=enterprise_tz)\n            if end_dt.tzinfo is None:\n                end_dt = end_dt.replace(tzinfo=enterprise_tz)\n\n            start_time_utc = start_dt.astimezone(ZoneInfo(\"UTC\"))\n            end_time_utc = end_dt.astimezone(ZoneInfo(\"UTC\"))\n\n        else:\n            raise ShiftConfigDataException(\"Must specify either shift_number or start_time/end_time\")\n\n        if start_time_utc >= end_time_utc:\n            raise ShiftConfigDataException(\"start_time must be earlier than end_time\")\n\n        return start_time_utc, end_time_utc, target_shift",
      "imports": [],
      "calls": [
        "strptime",
        "replace",
        "_resolve_time_window",
        "astimezone",
        "factory",
        "date",
        "end_time_utc",
        "end_dt",
        "self",
        "ShiftLogic",
        "start_dt",
        "end_time",
        "ScheduleDAO",
        "fetch_filtered",
        "ShiftConfigParseException",
        "ZoneInfo",
        "len",
        "fromisoformat",
        "start_time",
        "ScheduleDataResponseDTO",
        "ShiftConfigDataException",
        "datetime",
        "isoformat",
        "ShiftDetailsDTO",
        "get",
        "str",
        "shift_logic",
        "start_time_utc",
        "for_date"
      ]
    },
    {
      "id": "class:SimulationRequestDTO@app/services/simulation_id_service.py",
      "name": "SimulationRequestDTO",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/simulation_id_service.py",
      "docstring": "Модель запроса для запуска симуляции.",
      "methods": [
        "validate_quarry",
        "validate_times"
      ],
      "source_code": "class SimulationRequestDTO(BaseModel):\n    \"\"\"Модель запроса для запуска симуляции.\"\"\"\n\n    quarry: Dict[str, Any]\n    start_time: str = Field(..., description=\"ISO datetime string (UTC или с таймзоной)\")\n    end_time: str = Field(..., description=\"ISO datetime string (UTC или с таймзоной)\")\n    scenario: Optional[Dict[str, Any]] = None\n\n    @field_validator(\"quarry\")\n    @classmethod\n    def validate_quarry(cls, v):\n        if not v or \"id\" not in v:\n            raise ValueError(\"Field 'quarry.id' is required\")\n        return v\n\n    @field_validator(\"end_time\")\n    @classmethod\n    def validate_times(cls, v: str, info: ValidationInfo):\n        start_str = info.data.get(\"start_time\")\n        if not start_str:\n            return v\n\n        try:\n            start_dt = datetime.fromisoformat(start_str.replace(\"Z\", \"+00:00\"))\n            end_dt = datetime.fromisoformat(v.replace(\"Z\", \"+00:00\"))\n        except Exception:\n            raise ValueError(\"Invalid datetime format for 'start_time' or 'end_time'\")\n\n        if end_dt <= start_dt:\n            raise ValueError(\"'end_time' must be after 'start_time'\")\n\n        return v",
      "imports": [],
      "calls": [
        "start_str",
        "replace",
        "ValueError",
        "datetime",
        "fromisoformat",
        "field_validator",
        "get",
        "Field",
        "v"
      ]
    },
    {
      "id": "class:SimulationDAO@app/services/simulation_id_service.py",
      "name": "SimulationDAO",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/simulation_id_service.py",
      "docstring": "Работа с базой данных для симуляции.",
      "methods": [
        "__init__",
        "fetch_road_net_by_id",
        "get_filtered_schedule_items",
        "fetch_schedules"
      ],
      "source_code": "class SimulationDAO:\n    \"\"\"Работа с базой данных для симуляции.\"\"\"\n\n    def __init__(self, db_session: Session):\n        self.db = db_session\n\n    def fetch_road_net_by_id(self, road_net_id: int):\n        stmt = select(RoadNet).where(RoadNet.id == road_net_id)\n        return self.db.execute(stmt).scalar()\n\n    def get_filtered_schedule_items(self, model, start_time_utc, end_time_utc, quarry_id, schedule_type) -> list:\n        model_cols = set(model.__table__.columns.keys())\n\n        stmt = select(model).where(\n            model.quarry_id == quarry_id,\n            model.start_time < end_time_utc,\n            start_time_utc < model.end_time\n        ).order_by(model.id.asc())\n\n        res = self.db.execute(stmt).scalars()\n\n        item_list = []\n        for obj in res:\n            obj_dict = {\n                col_name: getattr(obj, col_name)\n                for col_name in model_cols\n            }\n            if schedule_type == 'blasting':\n                if 'geojson_data' in obj_dict and isinstance(obj_dict['geojson_data'], str):\n                    try:\n                        obj_dict['geojson_data'] = json.loads(obj_dict['geojson_data'])\n                    except json.JSONDecodeError:\n                        obj_dict['geojson_data'] = None\n            item_list.append(obj_dict)\n\n        return item_list\n\n\n\n    def fetch_schedules(self, quarry_id: int, start_time: datetime, end_time: datetime) -> dict:\n        \"\"\"Получает blasting и planned_idle расписания для карьера.\"\"\"\n        schedules = {\"blasting\": [], \"planned_idle\": []}\n\n        for schedule_type in [\"blasting\", \"planned_idle\"]:\n            model = TYPE_SCHEDULE_MAP.get(schedule_type)\n            items = self.get_filtered_schedule_items(\n                model, start_time, end_time, quarry_id, schedule_type\n            )\n            schedules[schedule_type] = items\n\n        return schedules",
      "imports": [],
      "calls": [
        "TYPE_SCHEDULE_MAP",
        "execute",
        "scalars",
        "loads",
        "select",
        "item_list",
        "self",
        "json",
        "isinstance",
        "scalar",
        "getattr",
        "asc",
        "get_filtered_schedule_items",
        "append",
        "order_by",
        "where",
        "get",
        "keys",
        "set"
      ]
    },
    {
      "id": "class:GetSimIdService@app/services/simulation_id_service.py",
      "name": "GetSimIdService",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/simulation_id_service.py",
      "docstring": "Основной сервис симуляции — собирает данные, запускает SimulationManager и сохраняет результат.",
      "methods": [
        "__init__",
        "_store_simulation_data",
        "_cleanup_old_simulations"
      ],
      "source_code": "class GetSimIdService:\n    \"\"\"Основной сервис симуляции — собирает данные, запускает SimulationManager и сохраняет результат.\"\"\"\n\n    def __init__(self, data: SimulationRequestDTO, db, redis_client):\n        self.data = data\n        self.db = db\n        self.redis = redis_client\n        self.dao = SimulationDAO(db)\n\n    async def __call__(self):\n        quarry_id = self.data.quarry[\"id\"]\n\n        start_dt = datetime.fromisoformat(self.data.start_time.replace(\"Z\", \"+00:00\"))\n        end_dt = datetime.fromisoformat(self.data.end_time.replace(\"Z\", \"+00:00\"))\n        start_time_utc = start_dt.astimezone(ZoneInfo(\"UTC\"))\n        end_time_utc = end_dt.astimezone(ZoneInfo(\"UTC\"))\n\n        # Получение расписаний\n        schedules = self.dao.fetch_schedules(quarry_id, start_time_utc, end_time_utc)\n        self.data.quarry[\"schedules\"] = schedules\n\n        # Добавление RoadNet\n        road_net_id = self.data.quarry.get(\"road_net_id\")\n        if road_net_id:\n            rn = self.dao.fetch_road_net_by_id(road_net_id)\n            if rn:\n                self.data.quarry[\"road_net\"] = rn.geojson_data\n\n        # Запуск SimulationManager\n        writer = BatchWriter(batch_size_seconds=60)\n        scenario = self.data.scenario or {}\n\n        mode = \"auto\" if scenario.get(\"is_auto_truck_distribution\") else \"manual\"\n        reliability = scenario.get(\"is_calc_reliability_enabled\", False)\n        options = {\n            \"mode\": mode,\n            \"reliability_calc_enabled\": reliability\n        }\n\n        manager = SimulationManager(\n            raw_data=self.data.model_dump(),\n            writer=writer,\n            options=options\n        )\n\n        sim_data = manager.run()\n\n        # Сохранение в Redis\n        sim_id = str(uuid.uuid4())\n        scenario_id = scenario.get(\"id\", \"unknown\")\n        sim_key_base = f\"simulation:scenario_{scenario_id}\"\n        sim_key_plus_id = f\"{sim_key_base}:{sim_id}\"\n        ttl = timedelta(hours=12)\n\n        self._store_simulation_data(sim_key_plus_id, sim_data, ttl)\n        self._cleanup_old_simulations(sim_key_base)\n\n        return sim_id\n\n    # region Helpers\n    def _store_simulation_data(self, sim_key_base: str, sim_data: dict, ttl: timedelta):\n        \"\"\"Сохраняет результаты симуляции в Redis.\"\"\"\n        self.redis.setex(f\"{sim_key_base}:meta\", ttl, json.dumps(sim_data[\"meta\"]))\n        self.redis.setex(f\"{sim_key_base}:summary\", ttl, json.dumps(sim_data[\"summary\"]))\n        self.redis.setex(f\"{sim_key_base}:events\", ttl, json.dumps(sim_data[\"events\"]))\n\n        pipe = self.redis.pipeline()\n        for batch_key, batch_data in sim_data[\"batches\"].items():\n            pipe.setex(f\"{sim_key_base}:batch:{batch_key}\", ttl, json.dumps(batch_data))\n        pipe.execute()\n\n    def _cleanup_old_simulations(self, sim_key_base: str):\n        \"\"\"Удаляет старые симуляции, если их слишком много.\"\"\"\n        stored_meta_keys = [\n            (key, self.redis.ttl(key))\n            for key in self.redis.scan_iter(f\"{sim_key_base}:*:meta\", 1000)\n        ]\n        stored_meta_keys.sort(key=itemgetter(1), reverse=True)\n\n        if len(stored_meta_keys) <= STORED_RESULTS_NUMBER:\n            return\n\n        key_patterns_to_delete = [\n            meta_key[0].replace(\":meta\", \":*\")\n            for meta_key in stored_meta_keys[STORED_RESULTS_NUMBER:]\n        ]\n        for key_pattern in key_patterns_to_delete:\n            stored_keys_to_delete = [\n                key for key in self.redis.scan_iter(key_pattern, 1000)\n            ]\n            if stored_keys_to_delete:\n                self.redis.delete(*stored_keys_to_delete)",
      "imports": [],
      "calls": [
        "replace",
        "uuid",
        "_store_simulation_data",
        "timedelta",
        "execute",
        "astimezone",
        "SimulationDAO",
        "uuid4",
        "stored_meta_keys",
        "end_dt",
        "SimulationManager",
        "run",
        "scenario",
        "self",
        "pipeline",
        "manager",
        "sort",
        "ttl",
        "pipe",
        "start_dt",
        "json",
        "dumps",
        "ZoneInfo",
        "itemgetter",
        "model_dump",
        "setex",
        "fromisoformat",
        "len",
        "BatchWriter",
        "fetch_road_net_by_id",
        "delete",
        "scan_iter",
        "items",
        "datetime",
        "_cleanup_old_simulations",
        "get",
        "str",
        "fetch_schedules"
      ]
    },
    {
      "id": "class:AllTemplatesDTO@app/services/template_service.py",
      "name": "AllTemplatesDTO",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/template_service.py",
      "docstring": "",
      "methods": [],
      "source_code": "class AllTemplatesDTO(BaseModel):\n    shovel_template_list: List[Dict[str, Any]]\n    truck_template_list: List[Dict[str, Any]]\n    unload_template_list: List[Dict[str, Any]]\n    fuel_station_template_list: List[Dict[str, Any]]",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:TemplateDAO@app/services/template_service.py",
      "name": "TemplateDAO",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/template_service.py",
      "docstring": "DAO для получения моделей из БД.",
      "methods": [
        "__init__",
        "fetch_all"
      ],
      "source_code": "class TemplateDAO:\n    \"\"\"\n    DAO для получения моделей из БД.\n    \"\"\"\n\n    def __init__(self, db_session: Session):\n        self.db = db_session\n\n    def fetch_all(self, model) -> List:\n        \"\"\"\n        Вернуть все строки модели, упорядоченные по id ASC.\n        \"\"\"\n        stmt = select(model).order_by(model.id.asc())\n        result = self.db.execute(stmt).scalars().all()\n        return result",
      "imports": [],
      "calls": [
        "asc",
        "all",
        "execute",
        "scalars",
        "order_by",
        "select"
      ]
    },
    {
      "id": "class:AllTemplatesListService@app/services/template_service.py",
      "name": "AllTemplatesListService",
      "type": "class",
      "layer": "Сервисы",
      "file_path": "app/services/template_service.py",
      "docstring": "Собирает все шаблоны в словарь списков и возвращает DTO.",
      "methods": [
        "__init__",
        "_model_to_dict_list",
        "_generate_templates_dict",
        "__call__"
      ],
      "source_code": "class AllTemplatesListService:\n    \"\"\"\n    Собирает все шаблоны в словарь списков и возвращает DTO.\n    \"\"\"\n\n    # Явно перечисляем модели и соответствующие поля DTO\n    TEMPLATES = [\n        (ShovelTemplate, \"shovel_template_list\"),\n        (TruckTemplate, \"truck_template_list\"),\n        (UnloadTemplate, \"unload_template_list\"),\n        (FuelStationTemplate, \"fuel_station_template_list\"),\n    ]\n\n    def __init__(self, db_session: Session):\n        self.dao = TemplateDAO(db_session)\n\n    @staticmethod\n    def _model_to_dict_list(model, instances: List) -> List[Dict[str, Any]]:\n        \"\"\"\n        Преобразование модели в List[Dict].\n        \"\"\"\n\n        column_names = [col.name for col in model.__table__.columns]\n        return [\n            {col_name: getattr(inst, col_name) for col_name in column_names}\n            for inst in instances\n        ]\n\n    def _generate_templates_dict(self) -> Dict[str, List[Dict[str, Any]]]:\n        \"\"\"\n        Генерация словаря для шаблонов.\n        \"\"\"\n        result: Dict[str, List[Dict[str, Any]]] = {}\n        for model, dto_field in self.TEMPLATES:\n            instances = self.dao.fetch_all(model)\n            result[dto_field] = self._model_to_dict_list(model, instances)\n        return result\n\n    def __call__(self) -> AllTemplatesDTO:\n        templates_dict = self._generate_templates_dict()\n\n        dto_payload = {\n            \"shovel_template_list\": templates_dict.get(\"shovel_template_list\", []),\n            \"truck_template_list\": templates_dict.get(\"truck_template_list\", []),\n            \"unload_template_list\": templates_dict.get(\"unload_template_list\", []),\n            \"fuel_station_template_list\": templates_dict.get(\"fuel_station_template_list\", []),\n        }\n\n        return AllTemplatesDTO(**dto_payload)",
      "imports": [],
      "calls": [
        "self",
        "_generate_templates_dict",
        "TemplateDAO",
        "fetch_all",
        "get",
        "_model_to_dict_list",
        "templates_dict",
        "AllTemplatesDTO",
        "getattr"
      ]
    },
    {
      "id": "class:ObjectType@app/sim_engine/enums.py",
      "name": "ObjectType",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/enums.py",
      "docstring": "",
      "methods": [
        "__str__",
        "ru",
        "key",
        "code"
      ],
      "source_code": "class ObjectType(enum.Enum):\n    TRUCK = (1, 'truck', 'Самосвал')\n    SHOVEL = (2, 'shovel', 'Экскаватор')\n    UNLOAD = (3, 'unload', 'Зона разгрузки')\n    QUARRY = (4, 'quarry', 'Карьер')\n    IDLE_AREA = (5, 'idle_area', 'Площадка пересменки')\n    FUEL_STATION = (6, 'fuel_station', 'Заправка')\n    BLASTING = (7, 'blasting', 'Взрывные работы')\n\n    def __str__(self):\n        return self.key()  # По умолчанию — английский\n\n    def ru(self) -> str:\n        return self.value[2]\n\n    def key(self) -> str:\n        return self.value[1]\n\n    def code(self) -> int:\n        return self.value[0]",
      "imports": [],
      "calls": [
        "self",
        "key"
      ]
    },
    {
      "id": "class:IdleAreaType@app/sim_engine/enums.py",
      "name": "IdleAreaType",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/enums.py",
      "docstring": "",
      "methods": [
        "__str__",
        "ru",
        "key",
        "code"
      ],
      "source_code": "class IdleAreaType(enum.Enum):\n    SHIFT_CHANGE = (1, 'shift_change', 'Площадка пересменки')\n    PLANNED_IDLE = (2, 'planned_idle', 'Площадка ремонта')\n    LUNCH = (3, 'lunch', 'Площадка обеда')\n    BLAST_WAITING = (4, 'blast_waiting', 'Площадка ожидания взрывных работ')\n\n    def __str__(self):\n        return self.key()  # По умолчанию — английский\n\n    def ru(self) -> str:\n        return self.value[2]\n\n    def key(self) -> str:\n        return self.value[1]\n\n    def code(self) -> int:\n        return self.value[0]",
      "imports": [],
      "calls": [
        "self",
        "key"
      ]
    },
    {
      "id": "class:EventType@app/sim_engine/events.py",
      "name": "EventType",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/events.py",
      "docstring": "",
      "methods": [
        "__str__",
        "code",
        "ru",
        "en"
      ],
      "source_code": "class EventType(Enum):\n    BREAKDOWN_BEGIN = (1, \"breakdown_begin\", \"Начало ремонта\")\n    BREAKDOWN_END = (2, \"breakdown_end\", \"Завершение ремонта\")\n\n    REFUELING_BEGIN = (3, \"refueling_begin\", \"Начало Заправки\")\n    REFUELING_END = (4, \"refueling_end\", \"Конец Заправки\")\n\n    LUNCH_BEGIN = (5, \"lunch_begin\", \"Начало обеда\")\n    LUNCH_END = (6, \"lunch_end\", \"Конец обеда\")\n\n    BLASTING_BEGIN = (7, \"blasting_begin\", \"Начало взрывных работ\")\n    BLASTING_END = (8, \"blasting_end\", \"Завершение взрывных работ\")\n\n    BLASTING_IDLE_BEGIN = (9, \"blasting_idle_begin\", \"Начало ожидания проведения взрывных работ\")\n    BLASTING_IDLE_END = (10, \"blasting_idle_end\", \"Конец ожидания проведения взрывных работ\")\n\n    PLANNED_IDLE_BEGIN = (11, \"planned_idle_begin\", \"Начало планового простоя (Ремонт, ТО и т.д.)\")\n    PLANNED_IDLE_END = (12, \"planned_idle_end\", \"Конец планового простоя (Ремонт, ТО и т.д.)\")\n\n    def __str__(self):\n        return self.value[1]  # По умолчанию — английский\n\n    def code(self):\n        return self.value[0]\n\n    def ru(self):\n        return self.value[2]\n\n    def en(self):\n        return self.value[1]",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:Event@app/sim_engine/events.py",
      "name": "Event",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/events.py",
      "docstring": "",
      "methods": [],
      "source_code": "class Event(DataclassEnumSerializerMixin):\n    event_code: int\n    event_name: str\n    time: float\n    object_id: int | str\n    object_type: ObjectType\n    object_name: str",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:FuelStationEvent@app/sim_engine/events.py",
      "name": "FuelStationEvent",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/events.py",
      "docstring": "",
      "methods": [],
      "source_code": "class FuelStationEvent(Event):\n    truck_id: int\n    truck_name: str",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:InputPlanningData@app/sim_engine/planner.py",
      "name": "InputPlanningData",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/planner.py",
      "docstring": "",
      "methods": [
        "truck_ids",
        "shovel_ids",
        "unload_ids"
      ],
      "source_code": "class InputPlanningData:\n    N: int  # количество самосвалов\n    M: int  # количество экскаваторов\n    Z: int  # количество площадок разгрузки\n    D_work: int  # длительность смены (мин)\n\n    # Матрицы/словари времени:\n    T_haul: Dict[Tuple[int, int, int], int]  # ключ (i,j,z)\n    T_return: Dict[Tuple[int, int, int], int]  # ключ (i,j,z)\n    T_load: Dict[Tuple[int, int], int]  # ключ (i,j)\n    T_unload: Dict[Tuple[int, int], int]  # ключ (i,z)\n    T_start: Dict[Tuple[int, int], int]  # ключ (i,j)\n    T_end: Dict[Tuple[int, int], int]  # ключ (i,z)\n\n    # тоннаж на рейс\n    m_tons: Dict[Tuple[int, int], float]  # ключ (i,j)\n\n    # верхняя граница числа рейсов для каждого самосвала\n    Kmax_by_truck: Optional[Dict[int, int]] = None\n\n    # Удобные множества ID\n    @property\n    def truck_ids(self) -> List[int]:\n        return sorted({i for (i, _) in self.T_load.keys()})\n\n    @property\n    def shovel_ids(self) -> List[int]:\n        return sorted({j for (_, j) in self.T_load.keys()})\n\n    @property\n    def unload_ids(self) -> List[int]:\n        return sorted({z for (_, z) in self.T_unload.keys()})",
      "imports": [],
      "calls": [
        "sorted",
        "keys"
      ]
    },
    {
      "id": "function:compute_Kmax_i@app/sim_engine/planner.py",
      "name": "compute_Kmax_i",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/planner.py",
      "docstring": "Грубая верхняя граница числа рейсов для самосвала i",
      "source_code": "def compute_Kmax_i(inst: InputPlanningData, i: int) -> int:\n    \"\"\"Грубая верхняя граница числа рейсов для самосвала i\"\"\"\n    js = {j for (ti, j) in inst.T_start.keys() if ti == i}\n    zs = {z for (ti, z) in inst.T_end.keys() if ti == i}\n    min_start = min(inst.T_start[i, j] for j in js)\n    min_end = min(inst.T_end[i, z] for z in zs)\n    min_d = min(\n        inst.T_haul[i, j, z] + inst.T_return[i, z, j] + inst.T_load[i, j] + inst.T_unload[i, z]\n        for j in js for z in zs\n    )\n    available = inst.D_work - min_start - min_end\n    return max(0, floor(available / max(1, min_d)))",
      "imports": [],
      "calls": [
        "floor",
        "min",
        "keys",
        "max"
      ]
    },
    {
      "id": "function:default_Kmax@app/sim_engine/planner.py",
      "name": "default_Kmax",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/planner.py",
      "docstring": "Если Kmax не задан, вычислить его для каждого самосвала",
      "source_code": "def default_Kmax(inst: InputPlanningData) -> Dict[int, int]:\n    \"\"\"Если Kmax не задан, вычислить его для каждого самосвала\"\"\"\n    return {i: compute_Kmax_i(inst, i) for i in inst.truck_ids}",
      "imports": [],
      "calls": [
        "compute_Kmax_i"
      ]
    },
    {
      "id": "function:build_model@app/sim_engine/planner.py",
      "name": "build_model",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/planner.py",
      "docstring": "Собираем все ограничения и условия поиска решения",
      "source_code": "def build_model(inst: InputPlanningData, shovel_queue: bool = True):\n    \"\"\"Собираем все ограничения и условия поиска решения\"\"\"\n    I = inst.truck_ids\n    J = inst.shovel_ids\n    Z = inst.unload_ids\n\n    # Верхние границы числа рейсов по самосвалам\n    Kmax = inst.Kmax_by_truck or default_Kmax(inst)\n\n    # Полный список потенциальных рейсов\n    P: List[Tuple[int, int]] = [(i, k) for i in I for k in range(1, Kmax[i] + 1)]\n\n    # Оптимизационная задача: максимизация добычи\n    model = LpProblem(\"MaxVolume\", LpMaximize)\n\n    # Константы Big‑M и эпсилон:\n    #   Mbig — должна быть достаточной верхней границей времени (тут — длительность смены)\n    #   eps  — минимальный «зазор» для строгого порядка выполнения погрузки (1 единица времени)\n    Mbig = inst.D_work\n    eps = 1\n\n    # Переменные\n    x = {(i, k, j, z): LpVariable(f\"x_{i}_{k}_{j}_{z}\", 0, 1, LpBinary)\n         for (i, k) in P for j in J for z in Z}\n\n    # y[i,k] ∈ {0,1} — k-ый рейс i-ого самосвала существует\n    y = {(i, k): LpVariable(f\"y_{i}_{k}\", 0, 1, LpBinary) for (i, k) in P}\n\n    # Временные переменные (целочисленные):\n    #   s_load   — старт погрузки\n    #   s_unload — старт разгрузки\n    #   a_arr    — прибытие к экскаватору перед погрузкой\n    s_load = {(i, k): LpVariable(f\"sLoad_{i}_{k}\", lowBound=0, cat=LpInteger) for (i, k) in P}\n    s_unload = {(i, k): LpVariable(f\"sUnload_{i}_{k}\", lowBound=0, cat=LpInteger) for (i, k) in P}\n    a_arr = {(i, k): LpVariable(f\"aArr_{i}_{k}\", lowBound=0, cat=LpInteger) for (i, k) in P}\n    q = {(i, k, j, z): LpVariable(f\"q_{i}_{k}_{j}_{z}\", 0, 1, LpBinary)\n         for i in I for k in range(1, Kmax[i]) for j in J for z in Z}\n    ell = {(i, k): LpVariable(f\"ell_{i}_{k}\", 0, 1, LpBinary) for (i, k) in P}\n\n    # w[p,q,j] ∈ {0,1} — порядок обслуживания очереди экскаватора для пар рейсов p<q на экскаваторе j\n    w = {}\n    if shovel_queue:\n        for j in J:\n            for idx_p in range(len(P)):\n                for idx_q in range(idx_p + 1, len(P)):\n                    p = P[idx_p]\n                    q_ = P[idx_q]\n                    w[p, q_, j] = LpVariable(\n                        f\"w_{p[0]}_{p[1]}__{q_[0]}_{q_[1]}__j{j}\", 0, 1, LpBinary\n                    )\n\n    # Вспомогательные суммы\n    def a_use(i, k, j):\n        return lpSum(x[i, k, j, z] for z in Z)\n\n    def b_use(i, k, z):\n        return lpSum(x[i, k, j, z] for j in J)\n\n    # Ограничения\n    for (i, k) in P:\n        model += lpSum(x[i, k, j, z] for j in J for z in Z) == y[i, k]\n\n    # (A2) Непрерывность по k\n    for i in I:\n        for k in range(1, Kmax[i]):\n            model += y[i, k + 1] <= y[i, k]\n\n    # (A3) Для первого рейса прибытие в начале смены и запрет начинать раньше\n    for i in I:\n        if Kmax[i] == 0:\n            continue\n        k = 1\n        # s_load[i,1] ≥ a_arr[i,1]\n        model += s_load[i, k] >= a_arr[i, k]\n        # a_arr[i,1] = Σ_j T_start[i,j] * a_use(i,1,j)\n        model += a_arr[i, k] == lpSum(inst.T_start[i, j] * a_use(i, k, j) for j in J)\n\n    # (A4) Начало разгрузки не раньше завершения погрузки + гружёного хода\n    for (i, k) in P:\n        model += s_unload[i, k] >= s_load[i, k] + lpSum(\n            x[i, k, j, z] * (inst.T_load[i, j] + inst.T_haul[i, j, z])\n            for j in J for z in Z\n        )\n\n    # (A5) Прибытие к экскаватору на (k+1) после разгрузки (k) и порожнего хода\n    for i in I:\n        for k in range(1, Kmax[i]):\n            model += a_arr[i, k + 1] >= s_unload[i, k] + \\\n                     lpSum(b_use(i, k, z) * inst.T_unload[i, z] for z in Z) + \\\n                     lpSum(q[i, k, j, z] * inst.T_return[i, z, j] for j in J for z in Z)\n            # Связки для q: выбранная пара (z пред., j след.) должна существовать\n            model += lpSum(q[i, k, j, z] for j in J for z in Z) == y[i, k + 1]\n            for z in Z:\n                model += lpSum(q[i, k, j, z] for j in J) <= b_use(i, k, z)\n            for j in J:\n                model += lpSum(q[i, k, j, z] for z in Z) <= a_use(i, k + 1, j)\n\n    # (A6) Погрузка не раньше прибытия (для всех рейсов)\n    for (i, k) in P:\n        model += s_load[i, k] >= a_arr[i, k]\n\n    # (A7) Последний рейс и возврат до конца смены\n    for i in I:\n        for k in range(1, Kmax[i] + 1):\n            # согласование ell с y и y на следующем k\n            model += ell[i, k] <= y[i, k]\n            if k < Kmax[i]:\n                model += ell[i, k] <= 1 - y[i, k + 1]\n                model += ell[i, k] >= y[i, k] - y[i, k + 1]\n            else:\n                model += ell[i, k] == y[i, k]\n            # если это последний рейс, успеваем разгрузиться и вернуться до D_work\n            model += s_unload[i, k] + \\\n                     lpSum(b_use(i, k, z) * (inst.T_unload[i, z] + inst.T_end[i, z]) for z in Z) \\\n                     <= inst.D_work + Mbig * (1 - ell[i, k])\n        # ровно один «последний» при наличии хотя бы одного рейса\n        if Kmax[i] >= 1:\n            model += lpSum(ell[i, k] for k in range(1, Kmax[i] + 1)) == y[i, 1]\n\n    # --- (A8) Каждый самосвал должен выполнить хотя бы один рейс ---\n    # for i in I:\n    #     model += lpSum(y[i, k] for k in range(1, Kmax[i] + 1)) >= 1\n\n    # Учёт очередей\n    if shovel_queue and len(P) >= 2:\n        for j in J:\n            for idx_p in range(len(P)):\n                for idx_q in range(idx_p + 1, len(P)):\n                    p = P[idx_p]\n                    q_ = P[idx_q]\n                    wvar = w[p, q_, j]\n\n                    #  Связь порядка с временами прибытия (ровно один порядок)\n                    #  a_p − a_q ≤ M(1 − w)\n                    #  a_q − a_p ≤ M w − eps\n                    model += a_arr[p] - a_arr[q_] <= Mbig * (1 - wvar)\n                    model += a_arr[q_] - a_arr[p] <= Mbig * wvar - eps\n\n                    xpj = a_use(p[0], p[1], j)\n                    xqj = a_use(q_[0], q_[1], j)\n\n                    # Время погрузки от количество грузящихся на время погрузки\n                    load_p = lpSum(x[p[0], p[1], j, z] * inst.T_load[p[0], j] for z in Z)\n                    load_q = lpSum(x[q_[0], q_[1], j, z] * inst.T_load[q_[0], j] for z in Z)\n\n                    # Если p раньше q (w=1): s_q ≥ s_p + load_p\n                    # Если q раньше p (w=0): s_p ≥ s_q + load_q\n\n                    model += s_load[q_] >= s_load[p] + load_p - Mbig * (1 - wvar) - Mbig * (2 - xpj - xqj)\n                    model += s_load[p] >= s_load[q_] + load_q - Mbig * wvar - Mbig * (2 - xpj - xqj)\n\n    # ЦЕЛЕВАЯ ФУНКЦИЯ\n    # Максимизируем тоннаж\n    obj_tons = lpSum(inst.m_tons[i, j] * x[i, k, j, z] for (i, k) in P for j in J for z in Z)\n    obj_trips = lpSum(x[i, k, j, z] for (i, k) in P for j in J for z in Z)\n    model += obj_tons\n\n    vars_pack = dict(x=x, y=y, s_load=s_load, s_unload=s_unload, a_arr=a_arr,\n                     q=q, ell=ell, w=w, Kmax=Kmax, P=P)\n    return model, vars_pack",
      "imports": [],
      "calls": [
        "range",
        "len",
        "LpProblem",
        "b_use",
        "LpVariable",
        "dict",
        "lpSum",
        "a_use",
        "default_Kmax"
      ]
    },
    {
      "id": "function:solve_and_extract@app/sim_engine/planner.py",
      "name": "solve_and_extract",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/planner.py",
      "docstring": "Решить модель и получить расписание\n    ",
      "source_code": "def solve_and_extract(inst: InputPlanningData):\n    \"\"\"Решить модель и получить расписание\n    \"\"\"\n\n    logger.info(\"Start build model\")\n    model, V = build_model(inst)\n    logger.info(\"End build model\")\n\n    sim_conf = DR.sim_conf()\n\n    if sim_conf[\"solver\"] == \"CBC\":\n        logger.info(\"CBC\")\n        cmd = PULP_CBC_CMD(\n            msg=sim_conf[\"msg\"],\n            timeLimit=sim_conf[\"time_limit\"]\n        )\n\n    elif sim_conf[\"solver\"] == \"HIGHS\":\n        logger.info(\"HIGHS\")\n        cmd = HiGHS_CMD(\n            msg=sim_conf[\"msg\"],\n            timeLimit=sim_conf[\"time_limit\"],\n            threads=os.cpu_count()\n        )\n\n    else:\n        raise ValueError(f\"Неизвестный солвер: {sim_conf[\"solver\"]}\")\n\n    logger.info(\"Start solve\")\n    status = model.solve(cmd)\n    logger.info(\"End solve\")\n\n    result = {\n        \"status\": LpStatus[model.status],\n        \"objective\": value(model.objective),\n        \"trips\": [],\n    }\n\n    # Если решения нет (Infeasible и т.п.), вернём «пусто»\n    if LpStatus[model.status] not in (\"Optimal\", \"Optimal_Infeasible\", \"Not Solved\", \"Feasible\"):\n        return result\n\n    # Извлекаем расписание, находим активные рейсы (y=1) и их (j,z)\n    x = V[\"x\"]\n    y = V[\"y\"]\n    sL = V[\"s_load\"]\n    sU = V[\"s_unload\"]\n    Kmax = V[\"Kmax\"]\n    I = inst.truck_ids\n    J = inst.shovel_ids\n    Z = inst.unload_ids\n\n    for i in I:\n        for k in range(1, Kmax[i] + 1):\n            if y[i, k].value() is None or y[i, k].value() < 0.5:\n                continue\n            # выбранные (j, z)\n            chosen = [(j, z) for j in J for z in Z if x[i, k, j, z].value() and x[i, k, j, z].value() > 0.5]\n            if not chosen:\n                continue\n            j, z = chosen[0]\n            result[\"trips\"].append({\n                \"truck_id\": i,\n                \"order\": k,\n                \"shovel_id\": j,\n                \"unload_id\": z,\n                \"start_load\": int(round(sL[i, k].value() or 0)),\n                \"start_unload\": int(round(sU[i, k].value() or 0)),\n                \"volume, t\": inst.m_tons[i, j],\n            })\n\n    # Для удобства — сортировка по самосвалу и номеру рейса\n    result[\"trips\"].sort(key=lambda r: (r[\"truck_id\"], r[\"order\"]))\n    return result",
      "imports": [],
      "calls": [
        "range",
        "HiGHS_CMD",
        "logger",
        "DR",
        "sort",
        "value",
        "sim_conf",
        "ValueError",
        "os",
        "PULP_CBC_CMD",
        "info",
        "cpu_count",
        "solve",
        "model",
        "build_model",
        "append",
        "int",
        "round"
      ]
    },
    {
      "id": "function:build_cp_model@app/sim_engine/planner.py",
      "name": "build_cp_model",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/planner.py",
      "docstring": "",
      "source_code": "def build_cp_model(inst: InputPlanningData, use_individual_kmax: bool = True):\n    model = cp_model.CpModel()\n\n    I = inst.truck_ids\n    J = inst.shovel_ids           # экскаваторы\n    Zs = inst.unload_ids          # площадки разгрузки\n\n    # Горизонт (безопасная верхняя граница)\n    H = 2 * inst.D_work\n\n    # Индивидуальные горизонты рейсов\n    if inst.Kmax_by_truck:\n        Kmax_i = dict(inst.Kmax_by_truck)\n    else:\n        Kmax_i = {i: compute_Kmax_i(inst, i) for i in I}\n    if not use_individual_kmax:\n        K = max(Kmax_i.values() or [0])\n        Kmax_i = {i: K for i in I}\n\n    # Переменные и структуры\n    load_itv = {}     # (i,k,j) -> optional interval\n    unload_itv = {}   # (i,k,z) -> optional interval\n    load_pres = {}    # presence literals\n    unload_pres = {}\n    s_load = {}\n    e_load = {}\n    s_unload = {}\n    e_unload = {}\n\n    shovel_to_intervals = {j: [] for j in J}\n    dump_to_intervals = {z: [] for z in Zs}\n\n    choose_shovel = {}   # (i,k,j) -> Bool\n    choose_dump = {}  # (i,k,z) -> Bool\n\n    # Создание интервалов\n    for i in I:\n        for k in range(1, Kmax_i[i] + 1):\n            # Погрузка — выбор экскаватора\n            for j in J:\n                dur = inst.T_load[i, j]\n                pres = model.NewBoolVar(f\"pres_load_{i}_{k}_E{j}\")\n                start = model.NewIntVar(0, H, f\"s_load_{i}_{k}_E{j}\")\n                end   = model.NewIntVar(0, H, f\"e_load_{i}_{k}_E{j}\")\n                itv   = model.NewOptionalIntervalVar(start, dur, end, pres, f\"itv_load_{i}_{k}_E{j}\")\n                load_itv[i, k, j] = itv\n                load_pres[i, k, j] = pres\n                s_load[i, k, j] = start\n                e_load[i, k, j] = end\n                shovel_to_intervals[j].append(itv)\n                choose_shovel[i, k, j] = pres\n\n            # Разгрузка — выбор площадки\n            for z in Zs:\n                dur = inst.T_unload[i, z]\n                pres = model.NewBoolVar(f\"pres_unload_{i}_{k}_Z{z}\")\n                start = model.NewIntVar(0, H, f\"s_unload_{i}_{k}_Z{z}\")\n                end   = model.NewIntVar(0, H, f\"e_unload_{i}_{k}_Z{z}\")\n                itv   = model.NewOptionalIntervalVar(start, dur, end, pres, f\"itv_unload_{i}_{k}_Z{z}\")\n                unload_itv[i, k, z] = itv\n                unload_pres[i, k, z] = pres\n                s_unload[i, k, z] = start\n                e_unload[i, k, z] = end\n                dump_to_intervals[z].append(itv)\n                choose_dump[i, k, z] = pres\n\n            # Ровно один экскаватор и ровно одна ПР на рейс k (или рейс отсутствует)\n            model.Add(sum(choose_shovel[i, k, j] for j in J) <= 1)\n            model.Add(sum(choose_dump[i, k, z] for z in Zs) <= 1)\n            # Требуем парность: если есть погрузка, должна быть и разгрузка (и наоборот)\n            model.Add(sum(choose_shovel[i, k, j] for j in J) == sum(choose_dump[i, k, z] for z in Zs))\n\n            # Монотонность наличия рейсов: если выбран k, то (k-1) тоже выбран\n            if k > 1:\n                model.Add(sum(choose_shovel[i, k, j] for j in J) <= sum(choose_shovel[i, k-1, j] for j in J))\n\n    # Очереди: NoOverlap\n    for j in J:\n        model.AddNoOverlap(shovel_to_intervals[j])\n    for z in Zs:\n        model.AddNoOverlap(dump_to_intervals[z])\n\n    # Связки «погрузка -> разгрузка -> след. погрузка»\n    for i in I:\n        for k in range(1, Kmax_i[i] + 1):\n            # haul: load(i,k,j) -> unload(i,k,z)\n            for j in J:\n                for z in Zs:\n                    b = model.NewBoolVar(f\"pair_{i}_{k}_E{j}_Z{z}\")\n                    # b активна только когда выбраны и экскаватор, и ПР\n                    model.Add(choose_shovel[i, k, j] == 1).OnlyEnforceIf(b)\n                    model.Add(choose_dump[i, k, z] == 1).OnlyEnforceIf(b)\n                    model.AddBoolOr([choose_shovel[i, k, j].Not(), choose_dump[i, k, z].Not(), b])\n                    t_h = inst.T_haul[i, j, z]\n                    model.Add(s_unload[i, k, z] >= e_load[i, k, j] + t_h).OnlyEnforceIf(b)\n\n            # return: unload(i,k,z) -> load(i,k+1,j')\n            if k < Kmax_i[i]:\n                for z in Zs:\n                    for j2 in J:\n                        b2 = model.NewBoolVar(f\"ret_{i}_{k}_Z{z}_E{j2}\")\n                        model.Add(choose_dump[i, k, z] == 1).OnlyEnforceIf(b2)\n                        model.Add(choose_shovel[i, k+1, j2] == 1).OnlyEnforceIf(b2)\n                        model.AddBoolOr([choose_dump[i, k, z].Not(), choose_shovel[i, k+1, j2].Not(), b2])\n                        t_r = inst.T_return[i, z, j2]\n                        model.Add(s_load[i, k+1, j2] >= e_unload[i, k, z] + t_r).OnlyEnforceIf(b2)\n\n            # Начало смены для первой погрузки\n            for j in J:\n                model.Add(s_load[i, 1, j] >= inst.T_start[i, j]).OnlyEnforceIf(choose_shovel[i, 1, j])\n            # Конец смены для любой выбранной разгрузки k\n            for z in Zs:\n                model.Add(e_unload[i, k, z] + inst.T_end[i, z] <= inst.D_work).OnlyEnforceIf(choose_dump[i, k, z])\n\n    # Целевая функция — суммарные тонны (по выбранным погрузкам)\n    terms = []\n    for i in I:\n        for k in range(1, Kmax_i[i] + 1):\n            for j in J:\n                ton = int(round(inst.m_tons[i, j]))\n                terms.append(ton * choose_shovel[i, k, j])\n    model.Maximize(sum(terms))\n\n    # Пакуем ссылки для извлечения результатов\n    V = dict(\n        choose_shovel=choose_shovel, choose_dump=choose_dump,\n        s_load=s_load, s_unload=s_unload,\n        Kmax_i=Kmax_i,\n    )\n    return model, V",
      "imports": [],
      "calls": [
        "range",
        "OnlyEnforceIf",
        "AddBoolOr",
        "Not",
        "compute_Kmax_i",
        "sum",
        "terms",
        "Kmax_i",
        "Add",
        "NewIntVar",
        "NewOptionalIntervalVar",
        "CpModel",
        "model",
        "Maximize",
        "AddNoOverlap",
        "dict",
        "cp_model",
        "append",
        "int",
        "round",
        "NewBoolVar",
        "values",
        "max"
      ]
    },
    {
      "id": "function:solve_and_extract_cp@app/sim_engine/planner.py",
      "name": "solve_and_extract_cp",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/planner.py",
      "docstring": "Решение CP‑SAT и извлечение расписания в прежнем формате.",
      "source_code": "def solve_and_extract_cp(inst: InputPlanningData, time_limit: Optional[int] = None, num_workers: int = 16):\n    \"\"\"Решение CP‑SAT и извлечение расписания в прежнем формате.\"\"\"\n\n    sim_conf = DR.sim_conf()\n\n    if sim_conf[\"msg\"]:\n        logger.info(\"Start builing cp model\")\n    model, V = build_cp_model(inst, use_individual_kmax=True)\n\n    if sim_conf[\"msg\"]:\n        logger.info(\"End builing cp model\")\n\n    solver = cp_model.CpSolver()\n    if time_limit is not None:\n        solver.parameters.max_time_in_seconds = float(time_limit)\n    solver.parameters.num_search_workers = num_workers\n    solver.parameters.log_search_progress = sim_conf[\"msg\"]\n    solver.parameters.cp_model_presolve = True\n\n    if sim_conf[\"msg\"]:\n        logger.info(\"Start solve\")\n\n    status_code = solver.Solve(model)\n\n    if sim_conf[\"msg\"]:\n        logger.info(\"End solve\")\n\n    # Маппинг статусов к строкам как в MILP-версии\n    status_map = {\n        cp_model.OPTIMAL: \"Optimal\",\n        cp_model.FEASIBLE: \"Feasible\",\n        cp_model.INFEASIBLE: \"Infeasible\",\n        cp_model.MODEL_INVALID: \"Model Invalid\",\n        cp_model.UNKNOWN: \"Not Solved\",\n    }\n    status_str = status_map.get(status_code, \"Not Solved\")\n\n    result = {\n        \"status\": status_str,\n        \"objective\": solver.ObjectiveValue() if status_code in (cp_model.OPTIMAL, cp_model.FEASIBLE) else 0.0,\n        \"trips\": [],\n    }\n\n    if status_code not in (cp_model.OPTIMAL, cp_model.FEASIBLE):\n        return result\n\n    choose_shovel = V[\"choose_shovel\"]\n    choose_dump = V[\"choose_dump\"]\n    s_load = V[\"s_load\"]\n    s_unload = V[\"s_unload\"]\n    Kmax_i = V[\"Kmax_i\"]\n\n    I = inst.truck_ids\n    J = inst.shovel_ids\n    Zs = inst.unload_ids\n\n    # Извлекаем поездки, сохраняя прежний формат\n    for i in I:\n        kn = 1  # номер рейса для самосвала i\n        for k in range(1, Kmax_i[i] + 1):\n            # выбранный экскаватор и ПР (если рейс существует)\n            chosen_j = None\n            chosen_z = None\n            for j in J:\n                if solver.BooleanValue(choose_shovel[i, k, j]):\n                    chosen_j = j\n                    break\n            for z in Zs:\n                if solver.BooleanValue(choose_dump[i, k, z]):\n                    chosen_z = z\n                    break\n            if chosen_j is None or chosen_z is None:\n                # дальше рейсов не будет из-за монотонности\n                break\n\n            start_load = solver.Value(s_load[i, k, chosen_j])\n            start_unload = solver.Value(s_unload[i, k, chosen_z])\n            result[\"trips\"].append({\n                \"truck_id\": i,\n                \"order\": kn,\n                \"shovel_id\": chosen_j,\n                \"unload_id\": chosen_z,\n                \"start_load\": int(start_load),\n                \"start_unload\": int(start_unload),\n                \"volume, t\": inst.m_tons[i, chosen_j],\n            })\n            kn += 1\n\n    # Сортировка как в исходнике\n    result[\"trips\"].sort(key=lambda r: (r[\"truck_id\"], r[\"order\"]))\n    return result",
      "imports": [],
      "calls": [
        "range",
        "logger",
        "BooleanValue",
        "float",
        "sort",
        "sim_conf",
        "ObjectiveValue",
        "CpSolver",
        "info",
        "status_map",
        "Value",
        "append",
        "int",
        "cp_model",
        "Solve",
        "DR",
        "build_cp_model",
        "solver",
        "get"
      ]
    },
    {
      "id": "function:make_example@app/sim_engine/planner.py",
      "name": "make_example",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/planner.py",
      "docstring": "Заполняем исходные данные\nКоличество техники, матрица времен выполнение каждой операции (полный перебор)",
      "source_code": "def make_example() -> InputPlanningData:\n    \"\"\" Заполняем исходные данные\n    Количество техники, матрица времен выполнение каждой операции (полный перебор)\n    \"\"\"\n    N = 5  # Количество самосвалов\n    M = 2  # Количество экскаваторов\n    Z = 2  # Количество площадок разгрузки (ПР)\n    D_work = 12 * 60  # Продолжительность смены в минутах\n\n    # Инициализация словарей параметров времени и объема (в тоннах)\n    T_load: Dict[Tuple[int, int], int] = {}  # Время погрузки\n    T_unload: Dict[Tuple[int, int], int] = {}  # Время разгрузки\n    T_haul: Dict[Tuple[int, int, int], int] = {}  # Время движения груженым\n    T_return: Dict[Tuple[int, int, int], int] = {}  # Время движения порожнего\n    T_start: Dict[Tuple[int, int], int] = {}  #  Время движения из зонны пересменки к Экскаватору\n    T_end: Dict[Tuple[int, int], int] = {}  #  Время движения с Экскаватора до зоны пересменки\n    m_tons: Dict[Tuple[int, int], float] = {}  #  Количесво загружаемых тонн\n\n    # Данные должны рассчитываться для каждого i-ого самосвала, j-ого экскаватора , z-ой ПР\n    # на основании их параметров (как в симуляции сейчас)\n    # T_load[i,j] - время погрузки (несколько ковшей, от момента Э зачерпнул до момента выкинул последний ковш в самосвал) i-ого самосвала у  j-ого экскаватора\n    # T_start[i,j] - время на движение от площадки пересменки для i-ого самосвала  к j-ому экскаватору\n    # m_tons[i,j] - количество тонн загруженных в i-ый самосвала на j-ом экскаваторе за один рейс\n    # T_unload[i,z] - время разгрузки у z-ой ПР\n    # T_haul[i,j,z] - время, которое i-ый самосвала выгружается у z-ой ПР\n    # T_end[i,z] - время, которое i-ый самосвала едет от z-ой ПР к площадке пересменки\n    # T_return[i,z,j] - время, которое i-ый самосвала едет от z-ой ПР к j-ому экскаватора\n\n    # Здесь заполнение каким-то данными\n    for i in range(1, N + 1):\n        for j in range(1, M + 1):\n            T_load[i, j] = 10 + 2 * (j - 1)\n            T_start[i, j] = 15 + 3 * (i - 1)\n            m_tons[i, j] = 180\n        for z in range(1, Z + 1):\n            T_unload[i, z] = 8 + (z - 1)\n            T_end[i, z] = 20 + 5 * (z - 1)\n        for j in range(1, M + 1):\n            for z in range(1, Z + 1):\n                T_haul[i, j, z] = 25 + 5 * (z - 1) + 3 * (i - 1)\n                T_return[i, z, j] = 22 + 4 * (j - 1) + 2 * (i - 1)\n\n    return InputPlanningData(\n        N=N, M=M, Z=Z, D_work=D_work,\n        T_haul=T_haul, T_return=T_return, T_load=T_load,\n        T_unload=T_unload, T_start=T_start, T_end=T_end,\n        m_tons=m_tons,\n    )",
      "imports": [],
      "calls": [
        "range",
        "InputPlanningData"
      ]
    },
    {
      "id": "function:dummy_func@app/sim_engine/planner.py",
      "name": "dummy_func",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/planner.py",
      "docstring": "",
      "source_code": "def dummy_func():\n    return 0",
      "imports": [],
      "calls": []
    },
    {
      "id": "function:get_planning_data@app/sim_engine/planner.py",
      "name": "get_planning_data",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/planner.py",
      "docstring": "Метод набивающий матрицу данных",
      "source_code": "def get_planning_data(simdata: SimData) -> InputPlanningData:\n    \"\"\"\n    Метод набивающий матрицу данных\n    \"\"\"\n    truck_count = len(simdata.trucks)\n    shovel_count = len(simdata.shovels)\n    unl_count = len(simdata.unloads)\n    shift_change_area = simdata.idle_areas.shift_change_areas[0]\n\n    planning_data = InputPlanningData(\n        N=truck_count,\n        M=shovel_count,\n        Z=unl_count,\n        D_work=int(simdata.duration/60),\n\n        T_haul=dict(),\n        T_return=dict(),\n        T_load=dict(),\n        T_unload=dict(),\n        T_start=dict(),\n        T_end=dict(),\n        m_tons=dict(),\n\n        Kmax_by_truck=None\n    )\n\n    # Идем по самосвалам\n    for truck in simdata.trucks.values():\n\n        # Идем по экскаваторам\n        for shovel in simdata.shovels.values():\n            time_load, weight, _ = ShovelCalc.calculate_load_cycles(shovel.properties, truck.properties)\n\n            planning_data.T_load[\n                truck.id,\n                shovel.id\n            ] = int(time_load/60)\n\n            if truck.initial_edge_id and truck.initial_lat and truck.initial_lon:\n                start_route = build_route_edges_by_road_net_from_position(\n                    lon=truck.initial_lon,\n                    lat=truck.initial_lat,\n                    edge_idx=truck.initial_edge_id,\n                    height=None,\n                    to_object_id=shovel.id,\n                    to_object_type=ObjectType.SHOVEL,\n                    road_net=simdata.road_net,\n                )\n\n            else:\n                start_route = build_route_edges_by_road_net(\n                    from_object_id=shift_change_area.id,\n                    from_object_type=ObjectType.IDLE_AREA,\n                    to_object_id=shovel.id,\n                    to_object_type=ObjectType.SHOVEL,\n                    road_net=simdata.road_net\n                )\n\n            planning_data.T_start[\n                truck.id,\n                shovel.id\n            ] = int(TruckCalc.calculate_time_motion_by_edges(\n                start_route,\n                truck.properties,\n                forward=True\n            )/60)\n\n            planning_data.m_tons[\n                truck.id,\n                shovel.id\n            ] = int(weight)\n\n            # Идем по пунктам разгрузки\n            for unload in simdata.unloads.values():\n\n                route = build_route_edges_by_road_net(\n                    from_object_id=shovel.id,\n                    from_object_type=ObjectType.SHOVEL,\n                    to_object_id=unload.id,\n                    to_object_type=ObjectType.UNLOAD,\n                    road_net=simdata.road_net\n                )\n                planning_data.T_haul[\n                    truck.id,\n                    shovel.id,\n                    unload.id\n                ] = int(TruckCalc.calculate_time_motion_by_edges(\n                    route,\n                    truck.properties,\n                    forward=True\n                )/60)\n\n                planning_data.T_return[\n                    truck.id,\n                    unload.id,\n                    shovel.id\n                ] = int(TruckCalc.calculate_time_motion_by_edges(\n                    route,\n                    truck.properties,\n                    forward=False\n                )/60)\n\n        # Идем по пунктам разгрузки\n        for unload in simdata.unloads.values():\n\n            planning_data.T_unload[\n                truck.id,\n                unload.id\n            ] = int(UnloadCalc.unload_calculation_by_norm(unload.properties, truck.properties)[\"t_total\"]/60)\n\n            end_route = build_route_edges_by_road_net(\n                from_object_id=unload.id,\n                from_object_type=ObjectType.UNLOAD,\n                to_object_id=shift_change_area.id,\n                to_object_type=ObjectType.IDLE_AREA,\n                road_net=simdata.road_net\n            )\n\n            planning_data.T_end[\n                truck.id,\n                unload.id\n            ] = int(TruckCalc.calculate_time_motion_by_edges(\n                end_route,\n                truck.properties,\n                forward=True\n            )/60)\n\n    return planning_data",
      "imports": [],
      "calls": [
        "TruckCalc",
        "UnloadCalc",
        "values",
        "calculate_time_motion_by_edges",
        "len",
        "calculate_load_cycles",
        "dict",
        "int",
        "InputPlanningData",
        "ShovelCalc",
        "build_route_edges_by_road_net_from_position",
        "unload_calculation_by_norm",
        "build_route_edges_by_road_net"
      ]
    },
    {
      "id": "function:run_planning@app/sim_engine/planner.py",
      "name": "run_planning",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/planner.py",
      "docstring": "",
      "source_code": "def run_planning(simdata: SimData):\n    sim_conf = DR.sim_conf()\n    planning_data = get_planning_data(simdata)\n    # planning_data = make_example()\n\n    if sim_conf[\"msg\"]:\n        logger.info(planning_data)\n\n    out = solve_and_extract_cp(planning_data, time_limit=sim_conf[\"time_limit\"])\n\n    if sim_conf[\"msg\"]:\n        for trip in out[\"trips\"]:\n            if trip[\"order\"] == 1:\n                logger.info(\"-------------------------\")\n            logger.info(f\"Самосвал: {trip[\"truck_id\"]}; Экскаватор: {trip[\"shovel_id\"]}; ПР: {trip[\"unload_id\"]}; Рейс № {trip[\"order\"]}\")\n    return out",
      "imports": [],
      "calls": [
        "logger",
        "DR",
        "sim_conf",
        "get_planning_data",
        "info",
        "solve_and_extract_cp"
      ]
    },
    {
      "id": "function:run_planning_trips@app/sim_engine/planner.py",
      "name": "run_planning_trips",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/planner.py",
      "docstring": "",
      "source_code": "def run_planning_trips(\n        sim_data: SimData,\n        exclude_objects: dict[str, list[int]],\n) -> dict:\n\n    sim_data.duration = int((sim_data.end_time - sim_data.start_time).total_seconds())\n\n    exclude_trucks = exclude_objects[\"trucks\"]\n    exclude_shovels = exclude_objects[\"shovels\"]\n    exclude_unloads = exclude_objects[\"unloads\"]\n\n    for truck_id in exclude_trucks:\n        sim_data.trucks.pop(truck_id, None)\n\n    for shovel_id in exclude_shovels:\n        sim_data.shovels.pop(shovel_id, None)\n\n    for unload_id in exclude_unloads:\n        sim_data.unloads.pop(unload_id, None)\n\n    if not sim_data.shovels or not sim_data.unloads or not sim_data.trucks:\n        return {}\n\n    result = run_planning(simdata=sim_data)\n    planned_trips = defaultdict(list)\n\n    for trip in result[\"trips\"]:\n        planned_trip = PlannedTrip(\n            truck_id=trip[\"truck_id\"],\n            shovel_id=trip[\"shovel_id\"],\n            unload_id=trip[\"unload_id\"],\n            order=trip[\"order\"]\n        )\n        planned_trips[planned_trip.truck_id].append(planned_trip)\n    return planned_trips",
      "imports": [],
      "calls": [
        "defaultdict",
        "total_seconds",
        "append",
        "int",
        "run_planning",
        "pop",
        "PlannedTrip"
      ]
    },
    {
      "id": "function:extract_metric@app/sim_engine/reliability.py",
      "name": "extract_metric",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Извлекает выбранную метрику из первых записей\n\nПараметры:\n    runs   : исходные записи симуляций\n    metric : название метрики: \"trips\" | \"volume\" | \"weight\"\n\nВозвращает:\n    Массив значений выбранной метрики без пропусков.",
      "source_code": "def extract_metric(runs: list[dict], metric: str) -> np.ndarray:\n    \"\"\"\n    Извлекает выбранную метрику из первых записей\n\n    Параметры:\n        runs   : исходные записи симуляций\n        metric : название метрики: \"trips\" | \"volume\" | \"weight\"\n\n    Возвращает:\n        Массив значений выбранной метрики без пропусков.\n    \"\"\"\n    xs: list[float] = []\n    for rec in runs:\n        s = (rec or {}).get(\"summary\", {}) or {}\n        if metric == \"trips\":\n            v = s.get(\"trips\")\n        elif metric == \"volume\":\n            v = s.get(\"volume\")\n        elif metric == \"weight\":\n            v = s.get(\"weight\")\n        else:\n            raise ValueError(f\"Неизвестная метрика: {metric}\")\n        if v is not None:\n            xs.append(float(v))\n    x = np.asarray(xs, float)\n    return x[~np.isnan(x)]",
      "imports": [],
      "calls": [
        "np",
        "ValueError",
        "asarray",
        "xs",
        "get",
        "isnan",
        "append",
        "s",
        "float"
      ]
    },
    {
      "id": "function:descriptive_stats@app/sim_engine/reliability.py",
      "name": "descriptive_stats",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Краткая описательная статистика, полезная для понимания формы распределения\n\nВозвращает:\n    n        : объём выборки\n    mean     : среднее\n    std      : выборочное стандартное отклонение\n    median   : медиана\n    q1, q3   : квартильный интервал\n    iqr      : межквартильный размах\n    skew     : асимметрия\n    kurtosis : избыточный эксцесс\n    xmin,xmax: минимальное и максимальное наблюдения",
      "source_code": "def descriptive_stats(x: np.ndarray) -> dict:\n    \"\"\"\n    Краткая описательная статистика, полезная для понимания формы распределения\n\n    Возвращает:\n        n        : объём выборки\n        mean     : среднее\n        std      : выборочное стандартное отклонение\n        median   : медиана\n        q1, q3   : квартильный интервал\n        iqr      : межквартильный размах\n        skew     : асимметрия\n        kurtosis : избыточный эксцесс\n        xmin,xmax: минимальное и максимальное наблюдения\n    \"\"\"\n    x = np.asarray(x, float)\n    n = len(x)\n    m = float(np.mean(x)) if n else np.nan\n    s = float(np.std(x, ddof=1)) if n > 1 else np.nan\n    med = float(np.median(x)) if n else np.nan\n    q1, q3 = (np.quantile(x, 0.25), np.quantile(x, 0.75)) if n > 0 else (np.nan, np.nan)\n    iqr = float(q3 - q1) if n > 0 else np.nan\n    sk = stats.skew(x, bias=False) if n > 2 else np.nan\n    kurt = stats.kurtosis(x, fisher=True, bias=False) if n > 3 else np.nan\n    return dict(n=n, mean=m, std=s, median=med, q1=q1, q3=q3, iqr=iqr,\n                skew=sk, kurtosis=kurt, xmin=float(np.min(x)), xmax=float(np.max(x)))",
      "imports": [],
      "calls": [
        "np",
        "len",
        "asarray",
        "min",
        "quantile",
        "stats",
        "kurtosis",
        "dict",
        "median",
        "mean",
        "skew",
        "max",
        "float",
        "std"
      ]
    },
    {
      "id": "function:predictive_interval_t@app/sim_engine/reliability.py",
      "name": "predictive_interval_t",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Двусторонний t-предиктивный интервал уровня 1-α для будущего наблюдения\n\nИдея:\n    Если данные близки к симметрии и нормальности, то\n    (X_new - среднее)/[S*sqrt(1+1/n)] ~ t_{n-1}.\n    Отсюда границы: среднее ± t_{1-α/2, n-1} * S * sqrt(1+1/n).\n\nВозвращает:\n    (нижняя, верхняя) границы вероятностного коридора",
      "source_code": "def predictive_interval_t(x: np.ndarray, alpha: float = 0.05) -> tuple[float, float]:\n    \"\"\"\n    Двусторонний t-предиктивный интервал уровня 1-α для будущего наблюдения\n\n    Идея:\n        Если данные близки к симметрии и нормальности, то\n        (X_new - среднее)/[S*sqrt(1+1/n)] ~ t_{n-1}.\n        Отсюда границы: среднее ± t_{1-α/2, n-1} * S * sqrt(1+1/n).\n\n    Возвращает:\n        (нижняя, верхняя) границы вероятностного коридора\n    \"\"\"\n    x = np.asarray(x, float)\n    n = len(x)\n    if n == 0:\n        return (np.nan, np.nan)\n    m = float(np.mean(x))\n    if n == 1:\n        # При одном наблюдении разумной ширины нет - обе границы равны ему\n        return (m, m)\n    s = float(np.std(x, ddof=1))\n    tval = float(stats.t.ppf(1 - alpha / 2, df=n - 1))\n    half = tval * s * np.sqrt(1 + 1 / n)\n    return (m - half, m + half)",
      "imports": [],
      "calls": [
        "np",
        "ppf",
        "sqrt",
        "len",
        "asarray",
        "mean",
        "float",
        "std"
      ]
    },
    {
      "id": "function:robust_pi_quantiles@app/sim_engine/reliability.py",
      "name": "robust_pi_quantiles",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Робастный предиктивный интервал по эмпирическим квантилям.\n\nИдея:\n    Никаких предположений о форме: берём квантиль α/2 и 1-α/2.\n    Интервал естественно подстраивается под асимметрию распределения",
      "source_code": "def robust_pi_quantiles(x: np.ndarray, alpha: float = 0.05) -> tuple[float, float]:\n    \"\"\"\n    Робастный предиктивный интервал по эмпирическим квантилям.\n\n    Идея:\n        Никаких предположений о форме: берём квантиль α/2 и 1-α/2.\n        Интервал естественно подстраивается под асимметрию распределения\n    \"\"\"\n    x = np.asarray(x, float)\n    if len(x) == 0:\n        return (np.nan, np.nan)\n    lo, hi = np.quantile(x, [alpha / 2, 1 - alpha / 2])\n    return float(lo), float(hi)",
      "imports": [],
      "calls": [
        "np",
        "len",
        "asarray",
        "quantile",
        "float"
      ]
    },
    {
      "id": "function:split_conformal_pi@app/sim_engine/reliability.py",
      "name": "split_conformal_pi",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Симметричный split-conformal интервал с гарантией покрытия ≈ 1-α\n\nИдея:\n    Делим данные на обучение и калибровку.\n    На обучении считаем центр (среднее), на калибровке - остатки |X-центр|\n    Берём дискретный квантиль остатка уровня 1-α\n    симметрично откладываем от центра.",
      "source_code": "def split_conformal_pi(x: np.ndarray, alpha: float = 0.05, seed: int = 123) -> tuple[float, float]:\n    \"\"\"\n    Симметричный split-conformal интервал с гарантией покрытия ≈ 1-α\n\n    Идея:\n        Делим данные на обучение и калибровку.\n        На обучении считаем центр (среднее), на калибровке - остатки |X-центр|\n        Берём дискретный квантиль остатка уровня 1-α\n        симметрично откладываем от центра.\n\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    x = np.asarray(x, float).copy()\n    n = len(x)\n    if n == 0:\n        return (np.nan, np.nan)\n    if n == 1:\n        return float(x[0]), float(x[0])\n    rng.shuffle(x)\n    n_cal = n // 2\n    train, cal = x[: n - n_cal], x[n - n_cal :]\n    mu = float(np.mean(train))\n    scores = np.abs(cal - mu)\n\n    k = int(np.ceil((1 - alpha) * (n_cal + 1)))\n    k = np.clip(k, 1, n_cal)\n    q = float(np.partition(np.sort(scores), k - 1)[k - 1])\n    return (mu - q, mu + q)",
      "imports": [],
      "calls": [
        "ceil",
        "np",
        "sort",
        "float",
        "len",
        "asarray",
        "clip",
        "copy",
        "default_rng",
        "abs",
        "int",
        "mean",
        "partition",
        "rng",
        "shuffle"
      ]
    },
    {
      "id": "function:lognormal_pi@app/sim_engine/reliability.py",
      "name": "lognormal_pi",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Интервал при лог-нормальной аппроксимации",
      "source_code": "def lognormal_pi(x: np.ndarray, alpha: float = 0.05) -> tuple[float, float]:\n    \"\"\"\n    Интервал при лог-нормальной аппроксимации\n    \"\"\"\n    x = np.asarray(x, float)\n    if np.any(x <= 0) or len(x) < 2:\n        return predictive_interval_t(x, alpha=alpha)\n    lx = np.log(x)\n    m = float(np.mean(lx))\n    s = float(np.std(lx, ddof=1))\n    tval = float(stats.t.ppf(1 - alpha / 2, df=len(x) - 1))\n    half = tval * s * np.sqrt(1 + 1 / len(x))\n    return float(np.exp(m - half)), float(np.exp(m + half))",
      "imports": [],
      "calls": [
        "exp",
        "np",
        "ppf",
        "sqrt",
        "len",
        "asarray",
        "predictive_interval_t",
        "mean",
        "log",
        "float",
        "any",
        "std"
      ]
    },
    {
      "id": "function:kde_hdi@app/sim_engine/reliability.py",
      "name": "kde_hdi",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Интервал наибольшей плотности (HDI) по сглаженной оценке плотности (KDE).",
      "source_code": "def kde_hdi(x: np.ndarray, alpha: float = 0.05, grids: int = 2048) -> tuple[float, float]:\n    \"\"\"\n    Интервал наибольшей плотности (HDI) по сглаженной оценке плотности (KDE).\n\n    \"\"\"\n    x = np.asarray(x, float)\n    kde = stats.gaussian_kde(x)\n    g = np.linspace(np.min(x), np.max(x), grids)\n    f = kde(g)\n    idx = np.argsort(f)[::-1]            # точки сетки в порядке убывания плотности\n    cs = np.cumsum(f[idx])\n    cs /= cs[-1]                          # нормировка до 1\n    mask = cs <= (1 - alpha)\n    sel = np.sort(g[idx][mask])\n    if len(sel) == 0:\n        return float(np.min(x)), float(np.max(x))\n    return float(sel[0]), float(sel[-1])",
      "imports": [],
      "calls": [
        "np",
        "sort",
        "float",
        "min",
        "asarray",
        "len",
        "cumsum",
        "gaussian_kde",
        "stats",
        "argsort",
        "kde",
        "max",
        "linspace"
      ]
    },
    {
      "id": "function:bootstrap_pi@app/sim_engine/reliability.py",
      "name": "bootstrap_pi",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Бутстрэп-интервал (перцентильный): эмпирическое предиктивное распределение.",
      "source_code": "def bootstrap_pi(x: np.ndarray, alpha: float = 0.05, B: int = 5000, seed: int = 123) -> tuple[float, float]:\n    \"\"\"\n    Бутстрэп-интервал (перцентильный): эмпирическое предиктивное распределение.\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    x = np.asarray(x, float)\n    draws = rng.choice(x, size=B, replace=True)\n    lo, hi = np.quantile(draws, [alpha / 2, 1 - alpha / 2])\n    return float(lo), float(hi)",
      "imports": [],
      "calls": [
        "np",
        "float",
        "asarray",
        "default_rng",
        "quantile",
        "rng",
        "choice"
      ]
    },
    {
      "id": "function:jackknife_plus_pi@app/sim_engine/reliability.py",
      "name": "jackknife_plus_pi",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Интервал Jackknife+",
      "source_code": "def jackknife_plus_pi(x: np.ndarray, alpha: float = 0.05) -> tuple[float, float]:\n    \"\"\"\n    Интервал Jackknife+\n    \"\"\"\n    x = np.asarray(x, float)\n    n = len(x)\n    if n <= 1:\n        return predictive_interval_t(x, alpha=alpha)\n    mu_full = float(np.mean(x))\n    mu_loo = np.array([(np.sum(x) - xi) / (n - 1) for xi in x])\n    resid = np.abs(x - mu_loo)\n    q = np.quantile(resid, 1 - alpha, method=\"higher\")\n    return float(mu_full - q), float(mu_full + q)",
      "imports": [],
      "calls": [
        "np",
        "sum",
        "len",
        "asarray",
        "array",
        "predictive_interval_t",
        "abs",
        "mean",
        "quantile",
        "float"
      ]
    },
    {
      "id": "function:split_conformal_asymmetric@app/sim_engine/reliability.py",
      "name": "split_conformal_asymmetric",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Асимметричный split-conformal",
      "source_code": "def split_conformal_asymmetric(x: np.ndarray, alpha: float = 0.05, seed: int = 123) -> tuple[float, float]:\n    \"\"\"\n    Асимметричный split-conformal\n    \"\"\"\n    rng = np.random.default_rng(seed)\n    x = np.asarray(x, float).copy()\n    n = len(x)\n    if n == 0:\n        return (np.nan, np.nan)\n    if n == 1:\n        return float(x[0]), float(x[0])\n    rng.shuffle(x)\n    n_cal = n // 2\n    tr, cal = x[:-n_cal], x[-n_cal:]\n    mu = float(np.mean(tr))\n    e = cal - mu\n    q_lo = np.quantile(e, alpha / 2, method=\"lower\")\n    q_hi = np.quantile(e, 1 - alpha / 2, method=\"higher\")\n    return float(mu + q_lo), float(mu + q_hi)",
      "imports": [],
      "calls": [
        "np",
        "float",
        "len",
        "asarray",
        "copy",
        "default_rng",
        "mean",
        "quantile",
        "rng",
        "shuffle"
      ]
    },
    {
      "id": "function:yeojohnson_pi@app/sim_engine/reliability.py",
      "name": "yeojohnson_pi",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Интервал на основе преобразования Йео–Джонсона",
      "source_code": "def yeojohnson_pi(x: np.ndarray, alpha: float = 0.05) -> tuple[float, float]:\n    \"\"\"\n    Интервал на основе преобразования Йео–Джонсона\n    \"\"\"\n    x = np.asarray(x, float)\n    if len(x) < 2:\n        return predictive_interval_t(x, alpha=alpha)\n\n    lam = stats.yeojohnson_normmax(x)     # оценка параметра преобразования\n    y = stats.yeojohnson(x, lmbda=lam)\n    n = len(y)\n    m, s = float(np.mean(y)), float(np.std(y, ddof=1))\n    tval = float(stats.t.ppf(1 - alpha / 2, df=n - 1))\n    half = tval * s * np.sqrt(1 + 1 / n)\n    lo_y, hi_y = m - half, m + half\n\n    # Обратное преобразование Йео–Джонсона (устойчивая реализация):\n    #   для y >= 0: x = ((y*λ + 1)^(1/λ) - 1)   (λ ≠ 0), иначе предел exp(y) - 1\n    #   для y <  0: x = 1 - (1 - y*(2-λ))^(1/(2-λ))   (λ ≠ 2), иначе предел 1 - exp(-y)\n    def inv_yj(yv: np.ndarray, lmbda: float) -> np.ndarray:\n        yv = np.asarray(yv, float)\n        out = np.empty_like(yv)\n\n        pos = yv >= 0\n        l2 = 2.0 - lmbda\n        tiny = np.finfo(float).tiny  # защита от нулевого основания степени\n\n        with np.errstate(invalid=\"ignore\", over=\"raise\", under=\"ignore\", divide=\"ignore\"):\n            # Ветвь y >= 0\n            if pos.any():\n                if abs(lmbda) > 1e-12:\n                    base_pos = yv[pos] * lmbda + 1.0\n                    base_pos = np.maximum(base_pos, tiny)\n                    out[pos] = np.power(base_pos, 1.0 / lmbda) - 1.0\n                else:\n                    out[pos] = np.expm1(yv[pos])  # предел при λ → 0\n\n            # Ветвь y < 0\n            neg = ~pos\n            if neg.any():\n                if abs(l2) > 1e-12:\n                    base_neg = 1.0 - yv[neg] * l2\n                    base_neg = np.maximum(base_neg, tiny)\n                    out[neg] = 1.0 - np.power(base_neg, 1.0 / l2)\n                else:\n                    out[neg] = 1.0 - np.exp(-yv[neg])  # предел при λ → 2\n\n        return out\n\n    # Из-за монотонности преобразования достаточно обратить границы и отсортировать\n    lo = float(np.min(inv_yj(np.array([lo_y, hi_y]), lam)))\n    hi = float(np.max(inv_yj(np.array([lo_y, hi_y]), lam)))\n    return lo, hi",
      "imports": [],
      "calls": [
        "yeojohnson_normmax",
        "sqrt",
        "power",
        "inv_yj",
        "float",
        "any",
        "exp",
        "min",
        "asarray",
        "predictive_interval_t",
        "stats",
        "abs",
        "finfo",
        "pos",
        "std",
        "np",
        "len",
        "mean",
        "neg",
        "errstate",
        "ppf",
        "expm1",
        "maximum",
        "empty_like",
        "array",
        "yeojohnson",
        "max"
      ]
    },
    {
      "id": "function:half_sample_mode@app/sim_engine/reliability.py",
      "name": "half_sample_mode",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Робастная мода (Half-Sample Mode, HSM).",
      "source_code": "def half_sample_mode(x: np.ndarray) -> float:\n    \"\"\"\n    Робастная мода (Half-Sample Mode, HSM).\n    \"\"\"\n    y = np.sort(np.asarray(x, float))\n    n = len(y)\n    if n <= 2:\n        return float(np.mean(y))\n    k = n // 2\n    widths = y[k:] - y[:n - k]\n    j = int(np.argmin(widths))\n    return half_sample_mode(y[j:j + k + (n % 2)])",
      "imports": [],
      "calls": [
        "np",
        "sort",
        "len",
        "asarray",
        "half_sample_mode",
        "int",
        "mean",
        "argmin",
        "float"
      ]
    },
    {
      "id": "function:kde_mode@app/sim_engine/reliability.py",
      "name": "kde_mode",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Мода по сглаженной плотности (KDE)",
      "source_code": "def kde_mode(x: np.ndarray, grids: int = 512) -> float:\n    \"\"\"\n    Мода по сглаженной плотности (KDE)\n    \"\"\"\n    kde = stats.gaussian_kde(x)\n    grid = np.linspace(np.min(x), np.max(x), grids)\n    dens = kde(grid)\n    return float(grid[np.argmax(dens)])",
      "imports": [],
      "calls": [
        "np",
        "float",
        "min",
        "argmax",
        "gaussian_kde",
        "stats",
        "kde",
        "max",
        "linspace"
      ]
    },
    {
      "id": "function:loo_coverage@app/sim_engine/reliability.py",
      "name": "loo_coverage",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Эмпирическое покрытие leave-one-out кросс-валидайция",
      "source_code": "def loo_coverage(x: np.ndarray, get_interval, alpha: float = 0.05, **kwargs) -> float:\n    \"\"\"\n    Эмпирическое покрытие leave-one-out кросс-валидайция\n\n    \"\"\"\n    x = np.asarray(x, float)\n    n = len(x)\n    if n < 3:\n        return np.nan\n    inside = 0\n    for i in range(n):\n        x_ = np.delete(x, i)\n        lo, hi = get_interval(x_, alpha=alpha, **kwargs)\n        inside += int(lo <= x[i] <= hi)\n    return inside / n",
      "imports": [],
      "calls": [
        "range",
        "np",
        "len",
        "asarray",
        "int",
        "get_interval",
        "delete"
      ]
    },
    {
      "id": "function:pit_values_t_predictive@app/sim_engine/reliability.py",
      "name": "pit_values_t_predictive",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "PIT (вероятностное преобразование) для t-предиктивной модели",
      "source_code": "def pit_values_t_predictive(x: np.ndarray) -> np.ndarray:\n    \"\"\"\n    PIT (вероятностное преобразование) для t-предиктивной модели\n    \"\"\"\n    x = np.asarray(x, float)\n    n = len(x)\n    m = float(np.mean(x))\n    s = float(np.std(x, ddof=1)) if n > 1 else 1.0\n    scale = s * np.sqrt(1 + 1 / n) if n > 0 else 1.0\n    z = (x - m) / (scale if scale > 0 else 1.0)\n    return stats.t.cdf(z, df=max(n - 1, 1))",
      "imports": [],
      "calls": [
        "np",
        "sqrt",
        "len",
        "asarray",
        "mean",
        "cdf",
        "max",
        "float",
        "std"
      ]
    },
    {
      "id": "function:interval_width@app/sim_engine/reliability.py",
      "name": "interval_width",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Ширина интервала. Если границы нечисловые - вернуть бесконечность,\nчтобы такой метод оказался в конце при сравнении",
      "source_code": "def interval_width(iv: tuple[float, float]) -> float:\n    \"\"\"\n    Ширина интервала. Если границы нечисловые - вернуть бесконечность,\n    чтобы такой метод оказался в конце при сравнении\n    \"\"\"\n    lo, hi = iv\n    return float(hi - lo) if (np.isfinite(hi) and np.isfinite(lo)) else np.inf",
      "imports": [],
      "calls": [
        "isfinite",
        "np",
        "float"
      ]
    },
    {
      "id": "function:select_best_interval@app/sim_engine/reliability.py",
      "name": "select_best_interval",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Выбирает лучший интервал по простому и понятному правилу.\n\nПравило:\n    1) Сначала фильтруем методы с покрытием LOO не хуже цели (1-α-допуск)\n    2) Среди них берём наименьшую ширину\n    3) При сильной асимметрии (|skew|>1) отдаём предпочтение робастным методам\n\nВозвращает:\n    (название метода, его интервал, строка-обоснование выбора)",
      "source_code": "def select_best_interval(\n    alpha: float,\n    intervals: dict[str, tuple[float, float]],\n    coverages: dict[str, float],\n    skew: float,\n    tol: float = 0.03,\n) -> tuple[str, tuple[float, float], str]:\n    \"\"\"\n    Выбирает лучший интервал по простому и понятному правилу.\n\n    Правило:\n        1) Сначала фильтруем методы с покрытием LOO не хуже цели (1-α-допуск)\n        2) Среди них берём наименьшую ширину\n        3) При сильной асимметрии (|skew|>1) отдаём предпочтение робастным методам\n\n    Возвращает:\n        (название метода, его интервал, строка-обоснование выбора)\n    \"\"\"\n    target = 1 - alpha\n    robust_names = {\n        \"quantile-PI\", \"conformal-PI\", \"asym-conformal-PI\",\n        \"jackknife+-PI\", \"bootstrap-PI\", \"kde-HDI\"\n    }\n\n    def score(name: str):\n        iv = intervals[name]\n        cov = coverages.get(name, np.nan)\n        width = interval_width(iv)\n\n        # Методы без оценённого покрытия (или с NaN) не ставим в приоритет первыми\n        if np.isnan(cov):\n            return (0, 1.0, 0, -width)\n\n        ok = 1 if cov >= target - tol else 0\n        shortfall = max(0.0, target - cov)\n        robust_bonus = 1 if (abs(skew) > 1.0 and name in robust_names) else 0\n\n        return (ok, -shortfall, robust_bonus, -width)\n\n    ranked = sorted(intervals.keys(), key=lambda nm: score(nm), reverse=True)\n    best = ranked[0]\n    iv = intervals[best]\n    cov = coverages.get(best, np.nan)\n    w = interval_width(iv)\n\n    reasons = []\n    if not np.isnan(cov):\n        if cov >= target - tol:\n            reasons.append(f\"покрытие LOO {cov:.3f} близко к целевому {target:.3f}\")\n        else:\n            reasons.append(f\"лучшая калибровка среди методов (LOO {cov:.3f} при цели {target:.3f})\")\n    reasons.append(f\"минимальная ширина среди сопоставимых: {w:.2f}\")\n    if abs(skew) > 1.0 and best in robust_names:\n        reasons.append(f\"учёт асимметрии (|асимметрия|={abs(skew):.2f}) - робастный метод предпочтительнее\")\n\n    return best, iv, \"; \".join(reasons)",
      "imports": [],
      "calls": [
        "np",
        "interval_width",
        "score",
        "get",
        "isnan",
        "keys",
        "intervals",
        "sorted",
        "append",
        "abs",
        "max",
        "reasons",
        "join",
        "coverages"
      ]
    },
    {
      "id": "function:assess_stability@app/sim_engine/reliability.py",
      "name": "assess_stability",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Оценка стабильности переданного набора данных с учётом предыдущих оценок на более\nузкой выборке (от предыдущего запуска требуются `prev_metric_median` и `cur_stable_streak`).\n\nКритерии оценки:\n    1) Относительная половина ширины t-интервала мала:\n       ((верх - низ)/2) / |медиана| ≤ r_target.\n       Это означает, что коридор неопределённости относительно уровня\n       метрики уже достаточно узок\n    2) Медиана почти не меняется относительно предыдущего шага:\n       |сдвиг медианы| / |медиана| ≤ delta_target\n\nПараметр `consecutive` требует, чтобы оба условия выполнялись указанное\nчисло шагов подряд - так мы избегаем преждевременной остановки\nиз-за случайных колебаний",
      "source_code": "def assess_stability(\n        results: list[dict],\n        metric: str = \"weight\",\n        prev_metric_median: float | None = None,\n        cur_stable_streak: int = 0,\n        alpha: float = 0.05,  # Уровень α (по умолчанию 0.05 → 95% предиктивный интервал)\n        r_target: float = 0.05,  # Порог относительной половины ширины t-интервала\n        delta_target: float = 0.01,  # Порог относительного сдвига медианы между шагами\n        consecutive: int = 2,  # Сколько раз подряд должны выполниться оба порога\n) -> tuple[bool, np.ndarray, float, int]:\n    \"\"\"\n    Оценка стабильности переданного набора данных с учётом предыдущих оценок на более\n    узкой выборке (от предыдущего запуска требуются `prev_metric_median` и `cur_stable_streak`).\n\n    Критерии оценки:\n        1) Относительная половина ширины t-интервала мала:\n           ((верх - низ)/2) / |медиана| ≤ r_target.\n           Это означает, что коридор неопределённости относительно уровня\n           метрики уже достаточно узок\n        2) Медиана почти не меняется относительно предыдущего шага:\n           |сдвиг медианы| / |медиана| ≤ delta_target\n\n    Параметр `consecutive` требует, чтобы оба условия выполнялись указанное\n    число шагов подряд - так мы избегаем преждевременной остановки\n    из-за случайных колебаний\n    \"\"\"\n\n    metric_array = extract_metric(results, metric)\n\n    eps = 1e-12\n    n_total = len(metric_array)\n\n    sub = metric_array[:]\n    lo, hi = predictive_interval_t(sub, alpha=alpha)\n    half = 0.5 * (hi - lo)\n    metric_median = float(np.median(sub))\n    rel_half = half / max(abs(metric_median), eps)\n    rel_delta = (\n        np.inf\n        if prev_metric_median is None\n        else abs(metric_median - prev_metric_median) / max(abs(metric_median), eps)\n    )\n\n    ok = (rel_half <= r_target) and (prev_metric_median is not None and rel_delta <= delta_target)\n    stable_streak = (cur_stable_streak + 1) if ok else 0\n    stability_achieved = stable_streak >= consecutive\n\n    logger.info(\"ШАГ ОЦЕНКИ ДАННЫХ\")\n    rd_txt = \"-\" if prev_metric_median is None else f\"{rel_delta:.4f}\"\n    logger.info(\n        f\"metric={metric} | n={n_total} | median={metric_median:.3f} | tPI=[{lo:.3f},{hi:.3f}] \"\n        f\"| rel_half={rel_half:.4f} | rel_delta={rd_txt} | ok={ok} | streak={stable_streak}\"\n    )\n    if stability_achieved:\n        logger.info(\"СТАБИЛЬНОСТЬ ДОСТИГНУТА\")\n    else:\n        logger.info(\"СТАБИЛЬНОСТЬ НЕ ДОСТИГНУТА\")\n    return stability_achieved, metric_array, metric_median, stable_streak",
      "imports": [],
      "calls": [
        "extract_metric",
        "logger",
        "np",
        "info",
        "len",
        "predictive_interval_t",
        "abs",
        "median",
        "max",
        "float"
      ]
    },
    {
      "id": "function:calc_reliability@app/sim_engine/reliability.py",
      "name": "calc_reliability",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Расчёт наиболее правдоподобного значения на основании стабильной выборки данных",
      "source_code": "def calc_reliability(\n        metric_array: np.ndarray,\n        alpha: float = 0.05,  # Уровень α (по умолчанию 0.05 → 95% предиктивный интервал)\n        boot_b: int = 5000,  # Число пересэмплирований для бутстрэпа\n        seed: int | None = None,  # Зерно случайности для методов со сплитом\n) -> tuple[float, float, float]:\n    \"\"\"Расчёт наиболее правдоподобного значения на основании стабильной выборки данных\"\"\"\n\n    if seed is None:\n        seed = random.getrandbits(128)\n\n    # Базовые характеристики и тесты формы (для понимания, когда t-модель уместна)\n    desc = descriptive_stats(metric_array)\n    # Шапиро–Уилк нормальность\n    sh_stat, sh_p = stats.shapiro(metric_array) if len(metric_array) <= 5000 else (np.nan, np.nan)\n    # Андерсон–Дарлинг - чувствителен к хвостам\n    ad_stat, _, _ = stats.anderson(metric_array, dist=\"norm\")\n\n    logger.info(f\"Базовые статистики метрики (n={len(metric_array)}, α={alpha})\")\n    for k, v in desc.items():\n        logger.info(f\"{k}: {v}\")\n    logger.info(f\"Shapiro p={sh_p:.3g} ; Anderson stat={ad_stat:.3f}\")\n\n    # Интервалы (разные подходы)\n    tpi   = predictive_interval_t(metric_array, alpha=alpha)\n    qpi   = robust_pi_quantiles(metric_array, alpha=alpha)\n    cpi   = split_conformal_pi(metric_array, alpha=alpha, seed=seed)\n    lnpi  = lognormal_pi(metric_array, alpha=alpha)\n    hdi   = kde_hdi(metric_array, alpha=alpha)\n    boot  = bootstrap_pi(metric_array, alpha=alpha, B=boot_b, seed=seed)\n    jack  = jackknife_plus_pi(metric_array, alpha=alpha)\n    asymc = split_conformal_asymmetric(metric_array, alpha=alpha, seed=seed)\n    yjpi  = yeojohnson_pi(metric_array, alpha=alpha)\n\n    intervals: dict[str, tuple[float, float]] = {\n        \"t-PI\": tpi,\n        \"quantile-PI\": qpi,\n        \"conformal-PI\": cpi,\n        \"lognormal-PI\": lnpi,\n        \"kde-HDI\": hdi,\n        \"bootstrap-PI\": boot,\n        \"jackknife+-PI\": jack,\n        \"asym-conformal-PI\": asymc,\n        \"yeojohnson-PI\": yjpi,\n    }\n\n    # Эмпирическое покрытие LOO по каждому методы\n    coverages: dict[str, float] = {}\n    coverages[\"t-PI\"]              = loo_coverage(metric_array, predictive_interval_t, alpha=alpha)\n    coverages[\"quantile-PI\"]       = loo_coverage(metric_array, robust_pi_quantiles, alpha=alpha)\n    coverages[\"conformal-PI\"]      = loo_coverage(metric_array, split_conformal_pi, alpha=alpha, seed=seed)\n    coverages[\"jackknife+-PI\"]     = loo_coverage(metric_array, jackknife_plus_pi, alpha=alpha)\n    coverages[\"asym-conformal-PI\"] = loo_coverage(metric_array, split_conformal_asymmetric, alpha=alpha, seed=seed)\n    coverages[\"bootstrap-PI\"]      = loo_coverage(metric_array, bootstrap_pi, alpha=alpha, B=boot_b, seed=seed)\n\n    logger.info(\"ПРЕДИКТИВНЫЕ ИНТЕРВАЛЫ (ширина и покрытие LOO, если применимо)\")\n    for name, (lo, hi) in intervals.items():\n        w = interval_width((lo, hi))\n        cov = coverages.get(name, np.nan)\n        cov_txt = f\"  LOO cover={cov:.3f}\" if not np.isnan(cov) else \"\"\n        logger.info(f\"{name:17s} [{lo:.6g}, {hi:.6g}]  width={w:.6g}{cov_txt}\")\n\n    # Диагностика t-модели через PIT\n    u = pit_values_t_predictive(metric_array)\n    ks_stat, ks_p = stats.kstest(u, \"uniform\")  # сравнение распределения PIT с равномерным\n    pit_cov = float(np.mean((u >= alpha/2) & (u <= 1 - alpha/2)))\n\n    logger.info(\"=== PIT (t-модель) ===\")\n    logger.info(f\"KS vs U(0,1): stat={ks_stat:.3f}, p={ks_p:.3g}; доля u∈({alpha/2:.3f},{1-alpha/2:.3f})={pit_cov:.3f}\")\n\n    #Автоматический выбор лучшего интервала и точек\n    best_name, best_iv, why = select_best_interval(\n        alpha=alpha, intervals=intervals, coverages=coverages, skew=desc[\"skew\"], tol=0.03\n    )\n    best_lo, best_hi = best_iv\n\n    # Наиболее правдоподобные точки: HSM (робастная мода), мода по KDE, медиана\n    mode_kde = kde_mode(metric_array)\n    mode_hsm = half_sample_mode(metric_array)\n    median   = float(np.median(metric_array))\n\n    logger.info(\"АВТО-ВЫБОР ЛУЧШЕГО ИНТЕРВАЛА\")\n    logger.info(f\"Лучший метод: {best_name}\")\n    logger.info(f\"MIN={best_lo:.6g}, MAX={best_hi:.6g}\")\n    logger.info(f\"Наиболее правдоподобное (HSM)={mode_hsm:.6g}; (мода KDE)={mode_kde:.6g}; (медиана)={median:.6g}\")\n    logger.info(f\"Обоснование: {why}\")\n    return mode_hsm, best_lo, best_hi",
      "imports": [],
      "calls": [
        "loo_coverage",
        "logger",
        "pit_values_t_predictive",
        "split_conformal_pi",
        "bootstrap_pi",
        "float",
        "split_conformal_asymmetric",
        "kstest",
        "lognormal_pi",
        "interval_width",
        "kde_hdi",
        "shapiro",
        "predictive_interval_t",
        "intervals",
        "isnan",
        "stats",
        "yeojohnson_pi",
        "descriptive_stats",
        "anderson",
        "np",
        "select_best_interval",
        "getrandbits",
        "kde_mode",
        "info",
        "robust_pi_quantiles",
        "len",
        "jackknife_plus_pi",
        "mean",
        "random",
        "items",
        "get",
        "half_sample_mode",
        "median",
        "coverages",
        "desc"
      ]
    },
    {
      "id": "function:find_closest_result@app/sim_engine/reliability.py",
      "name": "find_closest_result",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/reliability.py",
      "docstring": "Поиск ближайшего к правдоподобному значению результата, не превышающего лучшее максимальное",
      "source_code": "def find_closest_result(\n        results: list[dict],\n        metric_reliable: float,\n        metric_best_max: float,\n        metric: str = \"weight\",\n) -> dict:\n    \"\"\"Поиск ближайшего к правдоподобному значению результата, не превышающего лучшее максимальное\"\"\"\n\n    closest_idx = 0\n    closest_diff = metric_best_max\n    for i, result in enumerate(results):\n        metric_value = result[\"summary\"][metric]\n        weight_diff = abs(metric_value - metric_reliable)\n        if weight_diff < closest_diff and metric_value < metric_best_max:\n            closest_idx = i\n            closest_diff = weight_diff\n    closest_result = results[closest_idx]\n\n    return closest_result",
      "imports": [],
      "calls": [
        "abs",
        "enumerate"
      ]
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "name": "SimDataSerializer",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/serializer.py",
      "docstring": "Преобразует входной dict (как в run_simulation) в набор датаклассов.",
      "methods": [
        "serialize"
      ],
      "source_code": "class SimDataSerializer:\n    \"\"\"Преобразует входной dict (как в run_simulation) в набор датаклассов.\"\"\"\n\n    @classmethod\n    def serialize(cls, data: dict) -> SimData:\n        # --- время ---\n        timezone = data[\"quarry\"][\"timezone\"]\n        start_time = utc_to_enterprise(data[\"start_time\"], timezone)\n        end_time = utc_to_enterprise(data[\"end_time\"], timezone)\n        seconds = int((end_time - start_time).total_seconds())\n\n        # --- зерно рандома ---\n        if data.get('seed') is None:\n            # будет сгенерировано в начале симуляции\n            seed = None\n        else:\n            # предопределено\n            seed = int(data['seed'])\n\n        # --- экскаваторы ---\n        shovels: dict[int, Shovel] = {}\n        for raw in data[\"quarry\"].get(\"shovel_list\", []):\n            shovel_props = ShovelProperties(\n                obem_kovsha_m3=raw[\"bucket_volume\"],\n                skorost_podem_m_s=raw[\"bucket_lift_speed\"],\n                skorost_povorot_rad_s=raw[\"arm_turn_speed\"],\n                skorost_vrezki_m_s=raw[\"bucket_dig_speed\"],\n                skorost_napolneniya_m_s=raw[\"bucket_fill_speed\"],\n                koef_zapolneniya=raw.get(\"bucket_fill_coef\", 0.8),\n                tip_porody=raw.get(\"payload_type\", \"sand\"),\n                koef_vozvrata=raw.get(\"return_move_coef\", 0.85),\n                initial_operating_time=raw.get(\"initial_operating_time\", 12),\n                average_repair_duration=raw.get(\"average_repair_duration\", 8),\n                initial_failure_count=raw.get(\"initial_failure_count\", 100),\n                # оставшиеся коэфы — со своими датакласс-дефолтами\n            )\n            shovels[raw[\"id\"]] = Shovel(\n                id=raw[\"id\"],\n                name=raw[\"name\"],\n                initial_lat=raw[\"initial_lat\"],\n                initial_lon=raw[\"initial_lon\"],\n                properties=shovel_props,\n            )\n\n        # --- пункты разгрузки ---\n        unloads: dict[int, Unload] = {}\n        for raw in data[\"quarry\"].get(\"unload_list\", []):\n            unl_props = UnlProperties(\n                angle=raw[\"angle\"],\n                material_type=raw.get(\"payload_type\", \"unknown\"),\n                type_unloading=raw[\"unload_type\"],\n                trucks_at_once=raw.get(\"trucks_at_once\", 100),\n                initial_operating_time=raw.get(\"initial_operating_time\", 24),\n                average_repair_duration=raw.get(\"average_repair_duration\", 24),\n                initial_failure_count=raw.get(\"initial_failure_count\", 50),\n            )\n            unloads[raw[\"id\"]] = Unload(\n                    id=raw[\"id\"],\n                    name=raw[\"name\"],\n                    properties=unl_props,\n                )\n\n        # --- заправки ---\n        fuel_stations: dict[int, FuelStation] = {}\n        for raw in data[\"quarry\"].get(\"fuel_station_list\", []):\n            fs_props = FuelStationProperties(\n                num_pumps=raw[\"num_pumps\"],\n                flow_rate=raw[\"flow_rate\"],\n            )\n            fuel_stations[raw[\"id\"]] = FuelStation(\n                id=raw[\"id\"],\n                name=raw[\"name\"],\n                initial_lat=raw[\"initial_lat\"],\n                initial_lon=raw[\"initial_lon\"],\n                properties=fs_props,\n            )\n\n        # --- Зоны пересменки ---\n        idle_areas: list[IdleArea] = []\n        for raw in data[\"quarry\"].get(\"idle_area_list\", []):\n            area = IdleArea(\n                id=raw[\"id\"],\n                name=raw[\"name\"],\n                initial_lat=raw[\"initial_lat\"],\n                initial_lon=raw[\"initial_lon\"],\n                is_shift_change_area=raw[\"is_shift_change_area\"],\n                is_lunch_area=raw[\"is_lunch_area\"],\n                is_blast_waiting_area=raw[\"is_blast_waiting_area\"],\n                is_planned_idle_area=raw[\"is_repair_area\"]\n            )\n            idle_areas.append(area)\n        idle_areas_storage = IdleAreaStorage(areas=idle_areas)\n\n        # --- самосвалы ---\n        trucks: dict[int, Truck] = {}\n        for raw in data[\"quarry\"].get(\"truck_list\", []):\n            truck_props = TruckProperties(\n                body_capacity=raw[\"body_capacity\"],\n                speed_empty_kmh=raw[\"speed_empty\"],\n                speed_loaded_kmh=raw[\"speed_loaded\"],\n                initial_operating_time=raw.get(\"initial_operating_time\", 12),\n                average_repair_duration=raw.get(\"average_repair_duration\", 4),\n                initial_failure_count=raw.get(\"initial_failure_count\", 50),\n                # топливо\n                fuel_capacity=raw[\"fuel_capacity\"],\n                fuel_threshold_critical=raw[\"fuel_threshold_critical\"],\n                fuel_threshold_planned=raw[\"fuel_threshold_planned\"],\n                fuel_level=raw[\"fuel_level\"],\n                fuel_idle_lph=raw[\"fuel_idle_lph\"],\n                fuel_specific_consumption=raw[\"fuel_specific_consumption\"],\n                fuel_density=raw[\"fuel_density\"],\n                engine_power_kw=raw[\"engine_power_kw\"],\n                # acceleration/skill — остаются дефолтами датакласса, либо можно raw.get(...)\n            )\n            trucks[raw[\"id\"]] = Truck(\n                id=raw[\"id\"],\n                name=raw[\"name\"],\n                initial_lat=raw[\"initial_lat\"],\n                initial_lon=raw[\"initial_lon\"],\n                properties=truck_props,\n                initial_edge_id=None\n            )\n\n        # --- маршруты ---\n        routes: list[Route] = []\n        for raw in data[\"quarry\"].get(\"trail_list\", []):\n            segments = [\n                Segment(\n                    start=Point(lat=s[\"start\"][0], lon=s[\"start\"][1]),\n                    end=Point(lat=s[\"end\"][0], lon=s[\"end\"][1]),\n                )\n                for s in raw[\"segments\"]\n            ]\n            routes.append(\n                Route(\n                    id=raw[\"id\"],\n                    segments=segments,\n                    shovel_id=raw[\"shovel_id\"],\n                    unload_id=raw[\"unload_id\"],\n                    truck_ids=raw.get(\"trucks\", []),\n                )\n            )\n\n        # --- обеды ---\n        lunch_times = []\n        if data[\"quarry\"].get(\"lunch_break_offset\") and data[\"quarry\"].get(\"lunch_break_duration\"):\n            lunch_times = calculate_lunch_breaks(\n                start_time=start_time,\n                end_time=end_time,\n                shift_config=data[\"quarry\"].get(\"shift_config\", []),\n                lunch_break_offset=data[\"quarry\"].get(\"lunch_break_offset\"),\n                lunch_break_duration=data[\"quarry\"].get(\"lunch_break_duration\"),\n            )\n\n        # --- плановые простои ---\n        planned_idles = {}\n        idles_data = data[\"quarry\"].get(\"schedules\", {}).get('planned_idle')\n        if idles_data:\n            planned_idles = collect_planned_idles(idles_data)\n\n        # --- взрывные работы ---\n        blasting_list = []\n        blasting_data = data[\"quarry\"].get(\"schedules\", {}).get('blasting')\n        if blasting_data:\n            blasting_list = create_blasting_list(data=blasting_data, timezone=timezone)\n\n        # Примечание: trail_list/маршруты здесь намеренно не собираем —\n        # твои «чистые» датаклассы их не содержат. Если нужно — добавим\n        # отдельные dataclass'ы и поля в SimData.\n        return SimData(\n            start_time=start_time,\n            end_time=end_time,\n            duration=seconds,\n            seed=seed,\n            trucks=trucks,\n            shovels=shovels,\n            unloads=unloads,\n            fuel_stations=fuel_stations,\n            routes=routes,\n            road_net=data[\"quarry\"][\"road_net\"],\n            idle_areas=idle_areas_storage,\n            lunch_times=lunch_times,\n            planned_idles=planned_idles,\n            blasting_list=blasting_list,\n        )",
      "imports": [],
      "calls": [
        "Truck",
        "utc_to_enterprise",
        "UnlProperties",
        "IdleArea",
        "collect_planned_idles",
        "calculate_lunch_breaks",
        "Segment",
        "FuelStationProperties",
        "Shovel",
        "Unload",
        "routes",
        "raw",
        "create_blasting_list",
        "append",
        "int",
        "TruckProperties",
        "ShovelProperties",
        "IdleAreaStorage",
        "idle_areas",
        "Point",
        "FuelStation",
        "total_seconds",
        "get",
        "data",
        "Route",
        "SimData"
      ]
    },
    {
      "id": "function:calculate_lunch_breaks@app/sim_engine/serializer.py",
      "name": "calculate_lunch_breaks",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/serializer.py",
      "docstring": "Расчитывает обеденные перерывы в заданном временном интервале",
      "source_code": "def calculate_lunch_breaks(\n        start_time: datetime,\n        end_time: datetime,\n        shift_config: list[dict],\n        lunch_break_offset: int,\n        lunch_break_duration: int\n):\n    \"\"\"\n    Расчитывает обеденные перерывы в заданном временном интервале\n    \"\"\"\n    lunch_breaks = []\n\n    # Начинаем анализ за день до start_time, чтобы захватить ночные смены\n    analysis_start_day = (start_time - timedelta(days=1)).replace(hour=0, minute=0, second=0, microsecond=0)\n    analysis_end_day = end_time.replace(hour=0, minute=0, second=0, microsecond=0)\n\n    current_day = analysis_start_day\n    while current_day <= analysis_end_day:\n        # Для каждой смены в конфигурации\n        for shift in shift_config:\n            # Определяем начало и конец смены для текущего дня\n            shift_start = current_day + timedelta(minutes=shift[\"begin_offset\"])\n\n            # Вычисляем обед для этой смены\n            lunch_start = shift_start + timedelta(minutes=lunch_break_offset)\n            lunch_end = lunch_start + timedelta(minutes=lunch_break_duration)\n\n            # Проверяем, пересекается ли обед с нашим временным интервалом\n            if lunch_end > start_time and lunch_start < end_time:\n                # Обрезаем по границам интервала\n                actual_lunch_start = max(lunch_start, start_time)\n                actual_lunch_end = min(lunch_end, end_time)\n\n                if actual_lunch_start < actual_lunch_end:\n                    # Проверяем, что обед не дублируется\n                    if not any(abs((lb[0] - actual_lunch_start).total_seconds()) < 60 for lb in lunch_breaks):\n                        lunch_breaks.append(\n                            (actual_lunch_start, actual_lunch_end)\n                        )\n\n        # Переходим к следующему дню\n        current_day += timedelta(days=1)\n\n    # Сортируем по времени начала\n    lunch_breaks.sort(key=lambda x: x[0])\n\n    return lunch_breaks",
      "imports": [],
      "calls": [
        "sort",
        "replace",
        "timedelta",
        "lunch_breaks",
        "min",
        "total_seconds",
        "append",
        "abs",
        "max",
        "end_time",
        "any"
      ]
    },
    {
      "id": "function:collect_planned_idles@app/sim_engine/serializer.py",
      "name": "collect_planned_idles",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/serializer.py",
      "docstring": "Организует список плановых простоев в словарь,\nсгруппированный по vehicle_type и vehicle_id,\nс сортировкой по start_time.\n\nArgs:\n    idles_data (list): Список словарей с информацией о простоях\n\nReturns:\n    dict: Словарь вида {(vehicle_type, vehicle_id): [sorted_downtimes]}}",
      "source_code": "def collect_planned_idles(idles_data: list[dict]):\n    \"\"\"\n        Организует список плановых простоев в словарь,\n        сгруппированный по vehicle_type и vehicle_id,\n        с сортировкой по start_time.\n\n        Args:\n            idles_data (list): Список словарей с информацией о простоях\n\n        Returns:\n            dict: Словарь вида {(vehicle_type, vehicle_id): [sorted_downtimes]}}\n        \"\"\"\n    result = {}\n\n    for idle in idles_data:\n        vehicle_key = (idle[\"vehicle_type\"], idle[\"vehicle_id\"])\n\n        if vehicle_key not in result:\n            result[vehicle_key] = []\n\n        start_time = idle[\"start_time\"].isoformat() if isinstance(idle[\"start_time\"], datetime) else idle[\"start_time\"]\n        end_time = idle[\"end_time\"].isoformat() if isinstance(idle[\"end_time\"], datetime) else idle[\"end_time\"]\n\n        # Добавляем текущий простой в список\n        result[vehicle_key].append(\n            PlannedIdle(\n                id=idle[\"id\"],\n                vehicle_type=idle[\"vehicle_type\"],\n                start_time=utc_to_enterprise(start_time),\n                end_time=utc_to_enterprise(end_time),\n                quarry_id=idle[\"quarry_id\"],\n                vehicle_id=idle[\"vehicle_id\"],\n            )\n        )\n\n    # Сортируем списки по start_time\n    for idles in result.values():\n        idles.sort(key=lambda x: x.start_time)\n\n    return result",
      "imports": [],
      "calls": [
        "sort",
        "PlannedIdle",
        "values",
        "isoformat",
        "utc_to_enterprise",
        "idles",
        "append",
        "result",
        "isinstance"
      ]
    },
    {
      "id": "function:create_blasting_list@app/sim_engine/serializer.py",
      "name": "create_blasting_list",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/serializer.py",
      "docstring": "Создает список объектов Blasting из данных взрывных работ.\n\nArgs:\n    data: Словарь с данными взрывных работ\n    timezone: Часовой пояс\n\nReturns:\n    List[Blasting]: Отсортированный по start_time список объектов Blasting",
      "source_code": "def create_blasting_list(data: dict, timezone: str = TZ) -> list[Blasting]:\n    \"\"\"\n    Создает список объектов Blasting из данных взрывных работ.\n\n    Args:\n        data: Словарь с данными взрывных работ\n        timezone: Часовой пояс\n\n    Returns:\n        List[Blasting]: Отсортированный по start_time список объектов Blasting\n    \"\"\"\n    blasting_list = []\n\n    for item in data:\n        zones = []\n        for feature in item[\"geojson_data\"][\"features\"]:\n            if feature[\"geometry\"][\"type\"] == \"Polygon\":\n                coordinates = feature[\"geometry\"][\"coordinates\"][0]\n                zones.append(coordinates)\n\n        start_time = item[\"start_time\"].isoformat() if isinstance(item[\"start_time\"], datetime) else item[\"start_time\"]\n        end_time = item[\"end_time\"].isoformat() if isinstance(item[\"end_time\"], datetime) else item[\"end_time\"]\n\n        blasting = Blasting(\n            id=item[\"id\"],\n            zones=zones,\n            start_time=utc_to_enterprise(start_time, timezone),\n            end_time=utc_to_enterprise(end_time, timezone),\n        )\n        blasting_list.append(blasting)\n\n    # Сортировка по start_time\n    blasting_list.sort(key=lambda x: x.start_time)\n\n    return blasting_list",
      "imports": [],
      "calls": [
        "zones",
        "sort",
        "isoformat",
        "utc_to_enterprise",
        "isinstance",
        "append",
        "blasting_list",
        "Blasting"
      ]
    },
    {
      "id": "class:DataValidateError@app/sim_engine/simulate.py",
      "name": "DataValidateError",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/simulate.py",
      "docstring": "",
      "methods": [],
      "source_code": "class DataValidateError(Exception):\n    pass",
      "imports": [],
      "calls": []
    },
    {
      "id": "function:sim_data_validate@app/sim_engine/simulate.py",
      "name": "sim_data_validate",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/simulate.py",
      "docstring": "",
      "source_code": "def sim_data_validate(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            result = func(*args, **kwargs)\n            return result\n        except KeyError as e:\n            missing_field = e.args[0]\n            error = f\"ERROR! missing required argument in data: {missing_field}\"\n            raise DataValidateError(error)\n\n    return wrapper",
      "imports": [],
      "calls": [
        "func",
        "functools",
        "DataValidateError",
        "wraps"
      ]
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py",
      "name": "run_simulation",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/simulate.py",
      "docstring": "Run simulation with manual truck routes\n\nThis func needs to be **picklable** for `run_reliability` (multiprocessing limitations)",
      "source_code": "def run_simulation(\n        sim_data: SimData,\n        writer: IWriter,\n        sim_conf: dict,\n) -> dict:\n    \"\"\"\n    Run simulation with manual truck routes\n\n    This func needs to be **picklable** for `run_reliability` (multiprocessing limitations)\n    \"\"\"\n\n    env = QSimEnvironment(\n        sim_data=sim_data,\n        writer=writer,\n        sim_conf=sim_conf,\n    )\n\n    quarry = Quarry()\n    quarry.sim_data = sim_data\n    quarry.planned_trips = {}\n\n    quarry.prepare_seeded_random()\n    writer.update_data(\"meta\", seed=quarry.sim_data.seed)\n\n    # --- Экскаваторы ---\n    sim_shovels_map: dict[int, Shovel] = {}\n    for shovel in sim_data.shovels.values():\n        shovel_sim = Shovel(\n            unit_id=shovel.id,\n            name=shovel.name,\n            position=Point(shovel.initial_lat, shovel.initial_lon),\n            properties=shovel.properties,\n            quarry=quarry\n        )\n        sim_shovels_map[shovel.id] = shovel_sim\n\n    quarry.shovel_map = sim_shovels_map\n\n    # --- Пункты разгрузки ---\n    sim_unloads_map: dict[int, Unload] = {}\n    for unload in sim_data.unloads.values():\n        unl_sim = Unload(\n            properties=unload.properties,\n            unit_id=unload.id,\n            name=unload.name,\n            quarry=quarry,\n        )\n        sim_unloads_map[unload.id] = unl_sim\n\n    quarry.unload_map = sim_unloads_map\n\n    # --- Заправочные станции ---\n    sim_fuel_stations: list[FuelStation] = []\n    for fs in sim_data.fuel_stations.values():\n        fs_sim = FuelStation(\n            properties=fs.properties,\n            unit_id=fs.id,\n            name=fs.name,\n            initial_position=Point(fs.initial_lat, fs.initial_lon),\n        )\n        sim_fuel_stations.append(fs_sim)\n\n    # --- Зона пересменки ---\n    shift_change_area = sim_data.idle_areas.shift_change_areas[0]\n    quarry.shift_change_area = shift_change_area\n\n    # --- Маршруты и привязки грузовиков ---\n    truck_route_map: dict[int, tuple[Route, RouteEdge, RouteEdge, Shovel, Unload]] = {}\n    for route in getattr(sim_data, \"routes\", []) or []:\n\n        route_sim = build_route_by_road_net(route.shovel_id, route.unload_id, sim_data.road_net)\n        route_edge = build_route_edges_by_road_net(\n            from_object_id=route.shovel_id,\n            from_object_type=ObjectType.SHOVEL,\n            to_object_id=route.unload_id,\n            to_object_type=ObjectType.UNLOAD,\n            road_net=sim_data.road_net\n        )\n        # route_sim = build_route_sim(route)\n\n        shift_start_route = build_route_edges_by_road_net(\n            from_object_id=shift_change_area.id,\n            from_object_type=ObjectType.IDLE_AREA,\n            to_object_id=route.shovel_id,\n            to_object_type=ObjectType.SHOVEL,\n            road_net=sim_data.road_net\n        )\n\n        shovel_sim = sim_shovels_map[route.shovel_id]\n        unl_sim = sim_unloads_map[route.unload_id]\n        for truck_id in route.truck_ids:\n            truck_route_map[truck_id] = (route_sim, route_edge, shift_start_route, shovel_sim, unl_sim)\n\n    # --- Самосвалы ---\n    for truck in sim_data.trucks.values():\n        props = truck.properties\n        if truck.id not in truck_route_map:\n            continue\n        route, route_edge, shift_start_route, shovel_sim, unl_sim = truck_route_map[truck.id]\n        Truck(\n            unit_id=truck.id,\n            name=truck.name,\n            initial_position=Point(truck.initial_lat, truck.initial_lon),\n            route=route,\n            route_edge=route_edge,\n            start_route=shift_start_route,\n            planned_trips=[PlannedTrip(truck_id=truck.id, shovel_id=shovel_sim.id, unload_id=unl_sim.id, order=1)],\n            quarry=quarry,\n            shovel=shovel_sim,\n            unload=unl_sim,\n            properties=props,\n            fuel_stations=sim_fuel_stations\n        )\n\n    env.run(until=sim_data.duration)\n    logger.info(\"[done] Симуляция завершена\")\n    result = writer.finalize()\n    result[\"summary\"] = quarry.get_summary(sim_data.end_time)\n\n    return result",
      "imports": [],
      "calls": [
        "Truck",
        "logger",
        "finalize",
        "build_route_by_road_net",
        "run",
        "prepare_seeded_random",
        "writer",
        "get_summary",
        "sim_fuel_stations",
        "getattr",
        "Shovel",
        "Quarry",
        "info",
        "Unload",
        "quarry",
        "append",
        "PlannedTrip",
        "build_route_edges_by_road_net",
        "update_data",
        "values",
        "FuelStation",
        "Point",
        "QSimEnvironment",
        "env"
      ]
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "name": "run_simulation_for_planned_trips",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/simulate.py",
      "docstring": "Run simulation with auto truck routes\n\nThis func needs to be **picklable** for `run_reliability` (multiprocessing limitations)",
      "source_code": "def run_simulation_for_planned_trips(\n        sim_data: SimData,\n        writer: IWriter,\n        planned_trips: dict[int, list[PlannedTrip]],\n        sim_conf: dict,\n) -> dict:\n    \"\"\"\n    Run simulation with auto truck routes\n\n    This func needs to be **picklable** for `run_reliability` (multiprocessing limitations)\n    \"\"\"\n\n    env = QSimEnvironment(\n        sim_data=sim_data,\n        writer=writer,\n        sim_conf=sim_conf,\n    )\n\n    quarry = Quarry()\n    quarry.sim_data = sim_data\n    quarry.planned_trips = planned_trips\n\n    quarry.prepare_seeded_random()\n    writer.update_data(\"meta\", seed=quarry.sim_data.seed)\n\n    # --- Экскаваторы ---\n    sim_shovels_map: dict[int, Shovel] = {}\n    for shovel in sim_data.shovels.values():\n        shovel_sim = Shovel(\n            unit_id=shovel.id,\n            name=shovel.name,\n            position=Point(shovel.initial_lat, shovel.initial_lon),\n            properties=shovel.properties,\n            quarry=quarry\n        )\n        sim_shovels_map[shovel.id] = shovel_sim\n\n    quarry.shovel_map = sim_shovels_map\n    env.sim_context.shovels = sim_shovels_map\n\n    # --- Пункты разгрузки ---\n    sim_unloads_map: dict[int, Unload] = {}\n    for unload in sim_data.unloads.values():\n        unl_sim = Unload(\n            properties=unload.properties,\n            unit_id=unload.id,\n            name=unload.name,\n            quarry=quarry\n        )\n        sim_unloads_map[unload.id] = unl_sim\n\n    quarry.unload_map = sim_unloads_map\n    env.sim_context.unloads = sim_unloads_map\n\n    # --- Заправочные станции ---\n    sim_fuel_stations: list[FuelStation] = []\n    for fs in sim_data.fuel_stations.values():\n        fs_sim = FuelStation(\n            properties=fs.properties,\n            unit_id=fs.id,\n            name=fs.name,\n            initial_position=Point(fs.initial_lat, fs.initial_lon),\n        )\n        sim_fuel_stations.append(fs_sim)\n\n    # --- Зона пересменки ---\n    quarry.shift_change_area = sim_data.idle_areas.shift_change_areas[0]\n\n    # --- Самосвалы ---\n    sim_truck_map: dict[int, Truck] = {}\n    for truck in sim_data.trucks.values():\n        props = truck.properties\n\n        sim_truck = Truck(\n            unit_id=truck.id,\n            name=truck.name,\n            initial_position=Point(truck.initial_lat, truck.initial_lon),\n            route=None,\n            route_edge=None,\n            start_route=None,\n            planned_trips=planned_trips.get(truck.id, []),\n            quarry=quarry,\n            shovel=None,\n            unload=None,\n            properties=props,\n            fuel_stations=sim_fuel_stations,\n        )\n        sim_truck_map[truck.id] = sim_truck\n    quarry.truck_map = sim_truck_map\n    env.sim_context.trucks = sim_truck_map\n\n    env.run(until=sim_data.duration)\n    logger.info(\"[done] Симуляция завершена\")\n    result = writer.finalize()\n    result[\"summary\"] = quarry.get_summary(sim_data.end_time)\n\n    return result",
      "imports": [],
      "calls": [
        "Truck",
        "planned_trips",
        "logger",
        "finalize",
        "run",
        "prepare_seeded_random",
        "writer",
        "get_summary",
        "sim_fuel_stations",
        "Shovel",
        "Quarry",
        "info",
        "Unload",
        "quarry",
        "append",
        "update_data",
        "values",
        "FuelStation",
        "Point",
        "get",
        "QSimEnvironment",
        "env"
      ]
    },
    {
      "id": "function:run_reliability@app/sim_engine/simulate.py",
      "name": "run_reliability",
      "type": "function",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/simulate.py",
      "docstring": "Run given simulation engaging reliablility calculation\n\n`run_func` needs to be **picklable** (multiprocessing limitations)",
      "source_code": "def run_reliability(\n        run_func: Callable,\n        sim_data: SimData,\n        writer: IWriter,\n        sim_conf: dict,\n        *extra_run_func_args: tuple,\n        metric: str = \"weight\",\n        processes_number: int | None = None,\n        init_runs_number: int = 15,\n        step_runs_number: int = 15,\n        max_runs_number: int = 105,\n        alpha: float = 0.05,\n        r_target: float = 0.05,\n        delta_target: float = 0.01,\n        consecutive: int = 2,\n        boot_b: int = 5000,\n) -> dict:\n    \"\"\"\n    Run given simulation engaging reliablility calculation\n\n    `run_func` needs to be **picklable** (multiprocessing limitations)\n    \"\"\"\n    if processes_number is None:\n        processes = int(multiprocessing.cpu_count() / 2)\n    else:\n        processes = processes_number\n\n    logger.info('run_reliability', {\n        'func': f\"{run_func.__name__}\",\n        'metric': f\"{metric}\",\n        'proc': f\"{processes}\",\n        'init': f\"{init_runs_number}\",\n        'step': f\"{step_runs_number}\",\n        'max': f\"{max_runs_number}\",\n        'alpha': f\"{alpha}\",\n        'r_target': f\"{r_target}\",\n        'd_target': f\"{delta_target}\",\n        'consec': f\"{consecutive}\",\n        'boot_b': f\"{boot_b}\",\n    })\n\n    next_runs_number = init_runs_number\n    prev_metric_median = None\n    cur_stable_streak = 0\n\n    go_for_more = True\n    all_results = []\n\n    ctx = multiprocessing.get_context(\"spawn\")\n    with ctx.Pool(processes=processes) as pool:\n        while go_for_more:\n            starmap_args_list = [\n                (sim_data, DictReliabilityWriter(), sim_conf, *extra_run_func_args)\n                for i in range(next_runs_number)\n            ]\n            logger.info(f\"Run {next_runs_number} simulations on {processes} processes\")\n            attempt_results = pool.starmap(run_func, starmap_args_list)\n            logger.info(\"Finished executing simulations\")\n            all_results.extend(attempt_results)\n\n            is_stable, metric_array, metric_median, stable_streak = assess_stability(\n                all_results,\n                metric=metric,\n                prev_metric_median=prev_metric_median,\n                cur_stable_streak=cur_stable_streak,\n                alpha=alpha,\n                r_target=r_target,\n                delta_target=delta_target,\n                consecutive=consecutive,\n            )\n\n            if is_stable or len(all_results) >= max_runs_number:\n                logger.info(\"Achieved stability or exceeded max results number\")\n                go_for_more = False\n            else:\n                logger.info(\"Going to next attempt to achieve stability\")\n                next_runs_number = step_runs_number\n                prev_metric_median = metric_median\n                cur_stable_streak = stable_streak\n\n    logger.info(\"Calc reliable metric\")\n    metric_reliable, metric_best_min, metric_best_max = calc_reliability(\n        metric_array, alpha=alpha, boot_b=boot_b\n    )\n\n    logger.info(\"Find result closest to reliable metric\")\n    closest_result = find_closest_result(all_results, metric_reliable, metric_best_max, metric)\n\n    sim_data.seed = closest_result[\"meta\"][\"seed\"]\n\n    logger.info(f\"Reproduce closest result by seed: {sim_data.seed}\")\n\n    final_result = run_func(sim_data, writer, sim_conf, *extra_run_func_args)\n    final_result[\"summary\"][f\"{metric}_reliable\"] = round(metric_reliable)\n    final_result[\"summary\"][f\"{metric}_best_min\"] = round(metric_best_min)\n    final_result[\"summary\"][f\"{metric}_best_max\"] = round(metric_best_max)\n    final_result[\"summary\"][\"is_stable\"] = is_stable\n    final_result[\"summary\"][\"confidence_interval\"] = (1 - alpha) * 100\n    fsum = final_result[\"summary\"]\n\n    logger.info('final summary', {\n        'result': f\"{metric} {fsum[metric]}\",\n        'reliable': f\"{fsum[f\"{metric}_reliable\"]}\",\n        'best_min': f\"{fsum[f\"{metric}_best_min\"]}\",\n        'best_max': f\"{fsum[f\"{metric}_best_max\"]}\",\n        'is_stable': f\"{fsum[\"is_stable\"]}\",\n        'confidence_interval': f\"{fsum[\"confidence_interval\"]}\",\n    })\n\n    return final_result",
      "imports": [],
      "calls": [
        "range",
        "logger",
        "find_closest_result",
        "pool",
        "cpu_count",
        "multiprocessing",
        "calc_reliability",
        "assess_stability",
        "DictReliabilityWriter",
        "info",
        "len",
        "all_results",
        "int",
        "round",
        "ctx",
        "get_context",
        "run_func",
        "starmap",
        "Pool",
        "extend"
      ]
    },
    {
      "id": "class:ManagerValidationError@app/sim_engine/simulation_manager.py",
      "name": "ManagerValidationError",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/simulation_manager.py",
      "docstring": "Любые ошибки валидации для менеджера",
      "methods": [],
      "source_code": "class ManagerValidationError(Exception):\n    \"\"\"Любые ошибки валидации для менеджера\"\"\"\n    pass",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:SimDataValidationError@app/sim_engine/simulation_manager.py",
      "name": "SimDataValidationError",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/simulation_manager.py",
      "docstring": "Ошибка валидации входных данных симуляции",
      "methods": [],
      "source_code": "class SimDataValidationError(ManagerValidationError):\n    \"\"\"Ошибка валидации входных данных симуляции\"\"\"\n    pass",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:SimConfigValidationError@app/sim_engine/simulation_manager.py",
      "name": "SimConfigValidationError",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/simulation_manager.py",
      "docstring": "Ошибка валидации конфигурации симуляции",
      "methods": [],
      "source_code": "class SimConfigValidationError(ManagerValidationError):\n    \"\"\"Ошибка валидации конфигурации симуляции\"\"\"\n    pass",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:SimWriterValidationError@app/sim_engine/simulation_manager.py",
      "name": "SimWriterValidationError",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/simulation_manager.py",
      "docstring": "Ошибка валидации писаря результатов симуляции",
      "methods": [],
      "source_code": "class SimWriterValidationError(ManagerValidationError):\n    \"\"\"Ошибка валидации писаря результатов симуляции\"\"\"\n    pass",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ValidatorValidationError@app/sim_engine/simulation_manager.py",
      "name": "ValidatorValidationError",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/simulation_manager.py",
      "docstring": "Ошибка валидации валидатора, используемого в менеджере",
      "methods": [],
      "source_code": "class ValidatorValidationError(ManagerValidationError):\n    \"\"\"Ошибка валидации валидатора, используемого в менеджере\"\"\"\n    pass",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:IManagerValidator@app/sim_engine/simulation_manager.py",
      "name": "IManagerValidator",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/simulation_manager.py",
      "docstring": "",
      "methods": [
        "validate"
      ],
      "source_code": "class IManagerValidator:\n    @staticmethod\n    def validate(data: Any) -> Any:\n        raise NotImplementedError",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:RawSimDataValidator@app/sim_engine/simulation_manager.py",
      "name": "RawSimDataValidator",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/simulation_manager.py",
      "docstring": "",
      "methods": [
        "validate"
      ],
      "source_code": "class RawSimDataValidator(IManagerValidator):\n    @staticmethod\n    def validate(data: dict) -> dict:\n        if not data:\n            if isinstance(data, dict):\n                raise SimDataValidationError('Input data is empty!')\n            raise SimDataValidationError(f'Input data is invalid! Your data is {data}.')\n        return data",
      "imports": [],
      "calls": [
        "SimDataValidationError",
        "isinstance"
      ]
    },
    {
      "id": "class:SimConfigOptionsValidator@app/sim_engine/simulation_manager.py",
      "name": "SimConfigOptionsValidator",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/simulation_manager.py",
      "docstring": "",
      "methods": [
        "validate"
      ],
      "source_code": "class SimConfigOptionsValidator(IManagerValidator):\n    @staticmethod\n    def validate(data: dict) -> dict:\n        if not isinstance(data, dict):\n            raise SimConfigValidationError(f'Input config is invalid! Your config is {data}.')\n        return data",
      "imports": [],
      "calls": [
        "isinstance",
        "SimConfigValidationError"
      ]
    },
    {
      "id": "class:SimulationManager@app/sim_engine/simulation_manager.py",
      "name": "SimulationManager",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/simulation_manager.py",
      "docstring": "Менеджер для управления запуском симуляции в ручном/автоматическом режиме",
      "methods": [
        "__init__",
        "simdata",
        "config",
        "writer",
        "result",
        "set_new_simdata",
        "set_options",
        "__set_default_config",
        "validate_writer",
        "validate_validator",
        "set_raw_data_validator",
        "set_options_validator",
        "run",
        "_run_using_multiprocessing",
        "_multiprocessing_simulation_callback",
        "_process_simulation"
      ],
      "source_code": "class SimulationManager:\n    \"\"\"Менеджер для управления запуском симуляции в ручном/автоматическом режиме\"\"\"\n\n    def __init__(\n            self,\n            raw_data: dict,\n            options: dict | None = None,\n            writer: type[IWriter] = DictSimpleWriter,\n            raw_data_validator: type[IManagerValidator] = RawSimDataValidator,\n            options_validator: type[IManagerValidator] = SimConfigOptionsValidator,\n            use_multiprocessing: bool = False,\n    ) -> None:\n        \"\"\"\n            Инициализация менеджера.\n\n            Аргументы:\n            raw_data - сырые данные, необходимые для проведения симуляции/планирования\n            options - опции конфигурации для применения в процессе симуляции/планирования\n            writer - писарь результатов симуляции\n            raw_data_validator - валидатор сырых данных raw_data\n            options_validator - валидатор опций конфигурации\n        \"\"\"\n        self.raw_data_validator: IManagerValidator = self.validate_validator(validator=raw_data_validator)\n        self.options_validator: IManagerValidator = self.validate_validator(validator=options_validator)\n\n        self.raw_data_validator.validate(raw_data)\n\n        self._writer: IWriter = self.validate_writer(writer)\n\n        self._simdata: SimData = SimDataSerializer.serialize(data=raw_data)\n        self.__use_multiprocessing = use_multiprocessing\n\n        # Валидируем опции конфигурации и применяем их\n        self.__set_default_config()\n        if options:\n            self.set_options(options)\n\n        self._result: dict | None = None\n\n    @property\n    def simdata(self) -> SimData:\n        \"\"\"Возвращает текущие сериализованные данные, используемые для симуляции\"\"\"\n        return self._simdata\n\n    @property\n    def config(self) -> dict:\n        \"\"\"Возвращает текущую конфигурацию\"\"\"\n        return self._config\n\n    @property\n    def writer(self) -> IWriter:\n        \"\"\"Возвращает текущий класс логгера симуляции\"\"\"\n        return self._writer\n\n    @property\n    def result(self) -> dict:\n        \"\"\"Возвращает результат симуляции при его наличии\"\"\"\n        if self._result:\n            return self._result\n        raise RuntimeError('Result is not calculated. Use \"run\" method for calculation before calling this method.')\n\n    def set_new_simdata(self, raw_data: dict) -> None:\n        \"\"\"\n            Проводит валидацию переданных сырых данных для симуляции и\n            устанавливает сериализованные данные в качестве текущих\n        \"\"\"\n        self.raw_data_validator.validate(raw_data)\n        self._simdata = SimDataSerializer.serialize(data=raw_data)\n\n    def set_options(self, options: dict) -> None:\n        \"\"\"Проводит валидацию и устанавливает переданные опции конфигурации\"\"\"\n        if options:\n            self.options_validator.validate(options)\n            self._config.update(options)\n\n    def __set_default_config(self):\n        \"\"\"Устанавливает опции конфигурации по умолчанию\"\"\"\n        self._config = SIM_CONFIG.copy()\n\n    @staticmethod\n    def validate_writer(writer: Any) -> IWriter:\n        \"\"\"Производит валидацию переданного писаря результатов симуляции\"\"\"\n        is_class = inspect.isclass(writer)\n        if is_class and not issubclass(writer, IWriter):\n            raise SimWriterValidationError(f'Your writer {writer.__name__} is not an subclass of IWriter!')\n        if not is_class and not isinstance(writer, IWriter):\n            raise SimWriterValidationError(f'Your writer {writer.__name__} is not an instance of IWriter!')\n        return writer() if is_class else writer\n\n    @staticmethod\n    def validate_validator(validator: Any) -> IManagerValidator:\n        \"\"\"Производит валидацию переданного валидатора\"\"\"\n        is_class = inspect.isclass(validator)\n        if is_class and not issubclass(validator, IManagerValidator):\n            raise ValidatorValidationError(\n                f'Your validator {validator.__name__} is not an subclass of IManagerValidator!'\n            )\n        if not is_class and not isinstance(validator, IManagerValidator):\n            raise ValidatorValidationError(\n                f'Your validator {validator.__name__} is not an instance of IManagerValidator!'\n            )\n        return validator() if is_class else validator\n\n    def set_raw_data_validator(self, validator: IManagerValidator) -> None:\n        \"\"\"Устанавливает валидатор сырых данных для симуляции\"\"\"\n        self.raw_data_validator = self.validate_validator(validator=validator)\n\n    def set_options_validator(self, validator: IManagerValidator) -> None:\n        \"\"\"Устанавливает валидатор опций конфигурации\"\"\"\n        self.options_validator = self.validate_validator(validator=validator)\n\n    def run(self) -> dict:\n        \"\"\"\n        Запускает симуляцию в ручном/автоматическом режиме (зависит от текущей конфигурации)\n        в отдельном процессе\n        \"\"\"\n        if self.__use_multiprocessing:\n            return self._run_using_multiprocessing()\n\n        return self._process_simulation()\n\n    def _run_using_multiprocessing(self) -> dict:\n        with Manager() as manager:\n            manager_dict = manager.dict()\n\n            process = multiprocessing.Process(\n                target=self._multiprocessing_simulation_callback,\n                args=(\n                    manager_dict,\n                )\n            )\n\n            process.start()\n            process.join()\n\n            error_message = 'Не удалось получить результаты выполнения симуляции'\n\n            if 'exception' in manager_dict:\n                logger.error(error_message, {\n                    'exception': manager_dict['exception']\n                })\n                raise RuntimeError(error_message)\n\n            if 'result' not in manager_dict:\n                raise RuntimeError(error_message)\n\n            return manager_dict['result']\n\n    def _multiprocessing_simulation_callback(self, manager_dict: DictProxy) -> None:\n        try:\n            result = self._process_simulation()\n            manager_dict['result'] = result\n        except Exception as e:\n            manager_dict['exception'] = {\n                \"exception_type\": type(e).__name__,\n                \"exception_message\": str(e),\n                \"traceback\": traceback.format_exc(),\n                \"file\": e.__traceback__.tb_frame.f_code.co_filename,\n                \"line\": e.__traceback__.tb_lineno\n            }\n\n    @catch_errors\n    def _process_simulation(self) -> dict:\n        mode = self.config.get('mode')\n        if not mode:\n            raise RuntimeError('Missing mode parameter in simulation config!')\n\n        reliability_calc_enabled = self.config['reliability_calc_enabled']\n\n        # Запуск симуляции с планировщиком маршрутов\n        if mode == 'auto':\n            planned_trips = defaultdict(list)\n\n            if self.config[\"solver\"] != \"GREEDY\":\n                # Запускаем планировщик, планируем рейсы на все время симуляции\n                planner = Planner(\n                    solver=self.config['solver'],\n                    msg=self.config['msg'],\n                    workers=self.config['workers'],\n                    time_limit=self.config['time_limit']\n                )\n                planned = planner.run(self.simdata)\n\n                planned_trips = defaultdict(list)\n\n                for trip in planned['trips']:\n                    planned_trip = PlannedTrip(\n                        truck_id=trip['truck_id'],\n                        shovel_id=trip['shovel_id'],\n                        unload_id=trip['unload_id'],\n                        order=trip['order']\n                    )\n                    planned_trips[planned_trip.truck_id].append(planned_trip)\n\n            if reliability_calc_enabled:\n                return run_reliability(\n                    run_simulation_for_planned_trips,\n                    self.simdata,\n                    self.writer,\n                    planned_trips,\n                    self.config,\n                    metric='weight',\n                    processes_number=self.config['rel_process_num'],\n                    init_runs_number=self.config['rel_init_runs_num'],\n                    step_runs_number=self.config['rel_step_runs_num'],\n                    max_runs_number=self.config['rel_max_runs_num'],\n                    alpha=self.config['rel_alpha'],\n                    r_target=self.config['rel_r_target'],\n                    delta_target=self.config['rel_delta_target'],\n                    consecutive=self.config['rel_consecutive'],\n                    boot_b=self.config['rel_boot_b'],\n                )\n\n            return run_simulation_for_planned_trips(self.simdata, self.writer, planned_trips, self.config)\n\n        # Запуск симуляции с ручным определением маршрутов\n        if mode == 'manual':\n            if reliability_calc_enabled:\n                return run_reliability(\n                    run_simulation,\n                    self.simdata,\n                    self.writer,\n                    self.config,\n                    metric='weight',\n                    processes_number=self.config['rel_process_num'],\n                    init_runs_number=self.config['rel_init_runs_num'],\n                    step_runs_number=self.config['rel_step_runs_num'],\n                    max_runs_number=self.config['rel_max_runs_num'],\n                    alpha=self.config['rel_alpha'],\n                    r_target=self.config['rel_r_target'],\n                    delta_target=self.config['rel_delta_target'],\n                    consecutive=self.config['rel_consecutive'],\n                    boot_b=self.config['rel_boot_b'],\n                )\n\n            return run_simulation(self.simdata, self.writer, self.config)\n\n        raise RuntimeError(\n            f'PlanningAndSimulationManager has no behavior for \"{mode}\" value in \"mode\" parameter. '\n            f'Set \"auto\" or \"manual\" value.'\n        )",
      "imports": [],
      "calls": [
        "SimWriterValidationError",
        "logger",
        "_process_simulation",
        "run_simulation_for_planned_trips",
        "__set_default_config",
        "run_simulation",
        "validate_validator",
        "copy",
        "RuntimeError",
        "inspect",
        "_run_using_multiprocessing",
        "planner",
        "SIM_CONFIG",
        "issubclass",
        "serialize",
        "multiprocessing",
        "type",
        "self",
        "run",
        "writer",
        "manager",
        "isclass",
        "isinstance",
        "ValidatorValidationError",
        "process",
        "join",
        "validate",
        "set_options",
        "defaultdict",
        "error",
        "SimDataSerializer",
        "append",
        "update",
        "dict",
        "validator",
        "PlannedTrip",
        "Planner",
        "Manager",
        "get",
        "str",
        "Process",
        "start",
        "traceback",
        "run_reliability",
        "format_exc",
        "validate_writer"
      ]
    },
    {
      "id": "class:TruckState@app/sim_engine/states.py",
      "name": "TruckState",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/states.py",
      "docstring": "",
      "methods": [
        "is_work",
        "is_moving",
        "__str__",
        "ru",
        "en"
      ],
      "source_code": "class TruckState(Enum):\n    MOVING_EMPTY = (\"moving_empty\", \"Движение порожним\")\n    LOADING = (\"loading\", \"Погрузка\")\n    MOVING_LOADED = (\"moving_loaded\", \"Движение груженым\")\n    UNLOADING = (\"unloading\", \"Разгрузка\")\n    IDLE = (\"idle\", \"Простой\")\n    REPAIR = ('repair', \"Ремонт\")\n    WAITING = (\"waiting\", \"Ожидание\")\n    REFUELING = ('refueling', \"Заправка\")\n    LUNCH = ('lunch', 'Обед')\n    PLANNED_IDLE = ('planned_idle', 'Плановый простой (Ремонт, ТО и т.д.)')\n    BLASTING_IDLE = ('blasting_idle', 'Ожидание проведения взрывных работ')\n\n    @property\n    def is_work(self):\n        return self in [self.MOVING_LOADED, self.MOVING_EMPTY, self.UNLOADING]\n\n    @property\n    def is_moving(self):\n        return self in [self.MOVING_LOADED, self.MOVING_EMPTY]\n\n    def __str__(self):\n        return self.value[0]  # По умолчанию — английский\n\n    def ru(self):\n        return self.value[1]\n\n    def en(self):\n        return self.value[0]",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ExcState@app/sim_engine/states.py",
      "name": "ExcState",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/states.py",
      "docstring": "",
      "methods": [
        "is_work",
        "__str__",
        "ru",
        "en"
      ],
      "source_code": "class ExcState(Enum):\n    LOADING = (\"loading\", \"Погрузка\")\n    WAITING = (\"waiting\", \"Ожидание\")\n    REPAIR = (\"repair\", \"Ремонт\")\n    PLANNED_IDLE = (\"planned_idle\", \"Плановый простой (Ремонт, ТО и т.д.)\")\n    BLASTING_IDLE = ('blasting_idle', 'Ожидание проведения взрывных работ')\n\n    @property\n    def is_work(self):\n        return self == self.LOADING\n\n    def __str__(self):\n        return self.value[0]  # По умолчанию — английский\n\n    def ru(self):\n        return self.value[1]\n\n    def en(self):\n        return self.value[0]",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:UnloadState@app/sim_engine/states.py",
      "name": "UnloadState",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/states.py",
      "docstring": "",
      "methods": [
        "is_work",
        "__str__",
        "ru",
        "en"
      ],
      "source_code": "class UnloadState(Enum):\n    OPEN = (\"open\", \"Открыт\")\n    CLOSED = (\"closed\", \"Закрыт\")\n    REPAIR = ('repair', \"Ремонт\")\n    BLASTING_IDLE = ('blasting_idle', 'Ожидание проведения взрывных работ')\n\n    @property\n    def is_work(self):\n        return self == self.OPEN\n\n    def __str__(self):\n        return self.value[0]  # По умолчанию — английский\n\n    def ru(self):\n        return self.value[1]\n\n    def en(self):\n        return self.value[0]",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:FuelStationState@app/sim_engine/states.py",
      "name": "FuelStationState",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/states.py",
      "docstring": "",
      "methods": [
        "__str__",
        "ru",
        "en"
      ],
      "source_code": "class FuelStationState(Enum):\n    REFUELING = (\"refueling\", \"Заправка\")\n    WAITING = (\"waiting\", \"Ожидание\")\n\n    def __str__(self):\n        return self.value[0]  # По умолчанию — английский\n\n    def ru(self):\n        return self.value[1]\n\n    def en(self):\n        return self.value[0]",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:IWriter@app/sim_engine/writer.py",
      "name": "IWriter",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/writer.py",
      "docstring": "",
      "methods": [
        "update_data",
        "push_event",
        "writerow",
        "finalize"
      ],
      "source_code": "class IWriter(ABC):\n\n    @abstractmethod\n    def update_data(self, key: str, **kwargs) -> None:\n        pass\n\n    @abstractmethod\n    def push_event(self, evt: Event) -> None:\n        pass\n\n    @abstractmethod\n    def writerow(self, row: dict) -> None:\n        pass\n\n    @abstractmethod\n    def finalize(self):\n        pass",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:DictSimpleWriter@app/sim_engine/writer.py",
      "name": "DictSimpleWriter",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/writer.py",
      "docstring": "",
      "methods": [
        "__init__",
        "update_data",
        "push_event",
        "writerow",
        "finalize"
      ],
      "source_code": "class DictSimpleWriter(IWriter):\n    def __init__(self) -> None:\n        self.data: dict = {\n            \"telemetry\": [],\n            \"summary\": {},\n            \"events\": [],\n            \"meta\": {},\n        }\n\n    def update_data(self, key, **kwargs) -> None:\n        self.data[key].update(kwargs)\n\n    def push_event(self, evt: Event) -> None:\n        self.data[\"events\"].append(evt.to_dict())\n\n    def writerow(self, row: dict) -> None:\n        self.data[\"telemetry\"].append(row)\n\n    def finalize(self) -> dict:\n        return self.data",
      "imports": [],
      "calls": [
        "evt",
        "append",
        "to_dict",
        "update"
      ]
    },
    {
      "id": "class:DictReliabilityWriter@app/sim_engine/writer.py",
      "name": "DictReliabilityWriter",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/writer.py",
      "docstring": "",
      "methods": [
        "__init__",
        "push_event",
        "writerow"
      ],
      "source_code": "class DictReliabilityWriter(DictSimpleWriter):\n    def __init__(self) -> None:\n        super().__init__()\n        self.data.pop(\"telemetry\", None)\n        self.data.pop(\"events\", None)\n\n    def push_event(self, evt: Event) -> None:\n        pass\n\n    def writerow(self, row: dict) -> None:\n        pass",
      "imports": [],
      "calls": [
        "super",
        "pop",
        "__init__"
      ]
    },
    {
      "id": "class:BatchWriter@app/sim_engine/writer.py",
      "name": "BatchWriter",
      "type": "class",
      "layer": "Движок симуляции",
      "file_path": "app/sim_engine/writer.py",
      "docstring": "",
      "methods": [
        "__init__",
        "update_data",
        "push_event",
        "writerow",
        "finalize"
      ],
      "source_code": "class BatchWriter(IWriter):\n    def __init__(self, batch_size_seconds: int = 60) -> None:\n        self.batch_size_seconds = batch_size_seconds\n        self.batches: dict = {}  # Хранит батчи с последовательной нумерацией 0,1,2...\n        self.events: list = []\n        self.next_batch_index = 0  # Счётчик батчей\n        self.batch_time_map: dict = {}  # Соответствие timestamp → batch_index\n        self.meta = {\n            \"start_timestamp\": None,\n            \"end_timestamp\": None,\n            \"frame_interval\": 1,\n            \"batch_size_seconds\": batch_size_seconds,\n            \"total_frames\": 0,\n        }\n\n    def update_data(self, key, **kwargs) -> None:\n        getattr(self, key).update(kwargs)\n\n    def push_event(self, evt: Event) -> None:\n        self.events.append(evt.to_dict())\n\n    def writerow(self, row: dict) -> None:\n        timestamp = row[\"timestamp\"]\n\n        # Определяем временной интервал\n        time_slot = int(timestamp // self.batch_size_seconds)\n\n        # Находим или создаём batch_index для этого временного интервала\n        if time_slot not in self.batch_time_map:\n            self.batch_time_map[time_slot] = self.next_batch_index\n            self.batches[self.next_batch_index] = {\n                \"start_time\": timestamp,\n                \"end_time\": timestamp,\n                \"time_slot\": time_slot,\n                \"frames\": []\n            }\n            self.next_batch_index += 1\n\n        batch_index = self.batch_time_map[time_slot]\n        batch = self.batches[batch_index]\n\n        # Обновляем границы батча\n        if timestamp < batch[\"start_time\"]:\n            batch[\"start_time\"] = timestamp\n        if timestamp > batch[\"end_time\"]:\n            batch[\"end_time\"] = timestamp\n\n        batch[\"frames\"].append(row)\n        self.meta[\"total_frames\"] += 1\n\n        # Обновляем общие метаданные\n        if self.meta[\"start_timestamp\"] is None or timestamp < self.meta[\"start_timestamp\"]:\n            self.meta[\"start_timestamp\"] = timestamp\n        if self.meta[\"end_timestamp\"] is None or timestamp > self.meta[\"end_timestamp\"]:\n            self.meta[\"end_timestamp\"] = timestamp\n\n    def finalize(self) -> dict:\n        return {\n            \"meta\": {\n                **self.meta,\n                \"total_batches\": len(self.batches),\n                \"batch_keys\": list(self.batches.keys()),\n            },\n            \"batches\": self.batches,\n            \"events\": self.events,\n            \"summary\": {},\n        }",
      "imports": [],
      "calls": [
        "len",
        "keys",
        "evt",
        "append",
        "to_dict",
        "int",
        "update",
        "list",
        "getattr"
      ]
    },
    {
      "id": "function:koef_vlazhnosti@app/sim_engine/core/coefficients.py",
      "name": "koef_vlazhnosti",
      "type": "function",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/coefficients.py",
      "docstring": "Возвращает коэффициент по влажности грунта (%)\n0–5%   → 0.8 (сухой)\n5–15%  → 1.0 (оптимальная)\n15–30% → 1.2 (влажный)\n30–50% → 1.5–2.0 (глинистый)",
      "source_code": "def koef_vlazhnosti(percent: float) -> float:\n    \"\"\"\n    Возвращает коэффициент по влажности грунта (%)\n    0–5%   → 0.8 (сухой)\n    5–15%  → 1.0 (оптимальная)\n    15–30% → 1.2 (влажный)\n    30–50% → 1.5–2.0 (глинистый)\n    \"\"\"\n    if percent <= 5:\n        return 0.8\n    if percent <= 15:\n        return 1.25\n    if percent <= 30:\n        return 1.35\n    p = (percent - 30) / 20\n    return 1.5 + 0.5 * min(max(p, 0), 1)",
      "imports": [],
      "calls": [
        "min",
        "max"
      ]
    },
    {
      "id": "class:QSimEnvironment@app/sim_engine/core/environment.py",
      "name": "QSimEnvironment",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/environment.py",
      "docstring": "",
      "methods": [
        "__init__"
      ],
      "source_code": "class QSimEnvironment(simpy.Environment):\n    def __init__(self, sim_data: SimData, writer: IWriter, sim_conf: dict):\n        super().__init__()\n\n        self.sim_data = sim_data\n        self.sim_context: SimContext = SimContext()\n\n        ServiceLocator.unbind_all()\n\n        ServiceLocator.bind('sim_env', self)\n        ServiceLocator.bind('writer', writer)\n        ServiceLocator.bind('sim_conf', sim_conf)\n        ServiceLocator.bind('solver', GreedySolver())\n        ServiceLocator.bind('trip_service', TripService())\n        ServiceLocator.bind('idle_area_service', IdleAreaService(self.sim_data.idle_areas))",
      "imports": [],
      "calls": [
        "GreedySolver",
        "bind",
        "SimContext",
        "unbind_all",
        "super",
        "__init__",
        "IdleAreaService",
        "ServiceLocator",
        "TripService"
      ]
    },
    {
      "id": "class:Point@app/sim_engine/core/geometry.py",
      "name": "Point",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "",
      "methods": [],
      "source_code": "class Point:\n    lat: float\n    lon: float",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:Route@app/sim_engine/core/geometry.py",
      "name": "Route",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "",
      "methods": [
        "__init__",
        "start",
        "end"
      ],
      "source_code": "class Route:\n    def __init__(self, name: str, points: list[Point]):\n        self.name = name\n        self.points = points\n\n    @property\n    def start(self):\n        return self.points[0]\n\n    @property\n    def end(self):\n        return self.points[-1]",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:RouteEdge@app/sim_engine/core/geometry.py",
      "name": "RouteEdge",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "",
      "methods": [
        "_reverse",
        "__init__",
        "start_point",
        "end_point",
        "move_along_edges_gen",
        "move_along_edges_reversed_gen"
      ],
      "source_code": "class RouteEdge:\n\n    @staticmethod\n    def _reverse(edges):\n        reversed_edges = []\n        for edge in reversed(edges):\n            rev_edge = copy.deepcopy(edge)\n            rev_edge.start, rev_edge.stop = edge.stop, edge.start\n            reversed_edges.append(rev_edge)\n        return reversed_edges\n\n    def __init__(self, edges: list[Edge]):\n        self.edges = edges\n        self.reversed_edges = self._reverse(edges)\n\n    @property\n    def start_point(self) -> Vertex:\n        return self.edges[0].start\n\n    @property\n    def end_point(self) -> Vertex:\n        return self.edges[-1].stop\n\n    def move_along_edges_gen(self) -> Edge:\n        for edge in self.edges:\n            yield edge\n\n    def move_along_edges_reversed_gen(self) -> Edge:\n        for edge in self.reversed_edges:\n            yield edge",
      "imports": [],
      "calls": [
        "reversed",
        "self",
        "reversed_edges",
        "copy",
        "deepcopy",
        "append",
        "_reverse"
      ]
    },
    {
      "id": "function:cross_product@app/sim_engine/core/geometry.py",
      "name": "cross_product",
      "type": "function",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "Векторное произведение координат",
      "source_code": "def cross_product(\n        o: Tuple[float, float],\n        a: Tuple[float, float],\n        b: Tuple[float, float]\n):\n    \"\"\"Векторное произведение координат\"\"\"\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])",
      "imports": [],
      "calls": []
    },
    {
      "id": "function:segments_intersect@app/sim_engine/core/geometry.py",
      "name": "segments_intersect",
      "type": "function",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "Проверяет, пересекаются ли отрезки AB и CD",
      "source_code": "def segments_intersect(\n        a: Tuple[float, float],\n        b: Tuple[float, float],\n        c: Tuple[float, float],\n        d: Tuple[float, float]\n) -> bool:\n    \"\"\"Проверяет, пересекаются ли отрезки AB и CD\"\"\"\n\n    def on_segment(a, b, c):\n        \"\"\"Лежит ли точка C на отрезке AB\"\"\"\n        return (min(a[0], b[0]) <= c[0] <= max(a[0], b[0]) and\n                min(a[1], b[1]) <= c[1] <= max(a[1], b[1]))\n\n    # Вычисляем векторные произведения\n    d1 = cross_product(c, d, a)\n    d2 = cross_product(c, d, b)\n    d3 = cross_product(a, b, c)\n    d4 = cross_product(a, b, d)\n\n    # Основная проверка пересечения\n    if ((d1 > 0 and d2 < 0) or (d1 < 0 and d2 > 0)) and ((d3 > 0 and d4 < 0) or (d3 < 0 and d4 > 0)):\n        return True\n\n    # Особые случаи (коллинеарность)\n    if d1 == 0 and on_segment(c, d, a):\n        return True\n    if d2 == 0 and on_segment(c, d, b):\n        return True\n    if d3 == 0 and on_segment(a, b, c):\n        return True\n    if d4 == 0 and on_segment(a, b, d):\n        return True\n\n    return False",
      "imports": [],
      "calls": [
        "on_segment",
        "min",
        "cross_product",
        "max"
      ]
    },
    {
      "id": "function:path_intersects_polygons@app/sim_engine/core/geometry.py",
      "name": "path_intersects_polygons",
      "type": "function",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "Проверяет, попадает ли путь на графе хотя бы в один полигон.\n\nArgs:\n    path: объект RouteEdge, хранящий список рёбер пути на графе\n    polygons: список полигонов в виде списков координат\n\nReturns:\n    bool: True если путь пересекает или находится внутри хотя бы одного полигона",
      "source_code": "def path_intersects_polygons(path: RouteEdge, polygons: Tuple[Tuple[Tuple[float, float]]] | list[list[list[float]]]):\n    \"\"\"\n    Проверяет, попадает ли путь на графе хотя бы в один полигон.\n\n    Args:\n        path: объект RouteEdge, хранящий список рёбер пути на графе\n        polygons: список полигонов в виде списков координат\n\n    Returns:\n        bool: True если путь пересекает или находится внутри хотя бы одного полигона\n    \"\"\"\n    # Получаем координаты всех вершин пути\n    for edge in path.move_along_edges_gen():\n        # Координаты хранятся в атрибутах вершин, доступных через рёбра\n        start_coord = (edge.start.x, edge.start.y)\n        end_coord = (edge.stop.x, edge.stop.y)\n\n        # проверяем координаты отрезка на отрезках полигона, чтобы понять, пересекли ли мы полигон\n        for polygon in polygons:\n            for segment in list(zip(polygon, polygon[1:] + polygon[:1])):\n                segment_start_coord = segment[0]\n                segment_end_coord = segment[1]\n\n                if segments_intersect(start_coord, end_coord, segment_start_coord, segment_end_coord):\n                    return True\n    return False",
      "imports": [],
      "calls": [
        "zip",
        "segments_intersect",
        "path",
        "list",
        "move_along_edges_gen"
      ]
    },
    {
      "id": "function:build_route_sim@app/sim_engine/core/geometry.py",
      "name": "build_route_sim",
      "type": "function",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "Конвертирует наш dataclass Route (список сегментов)\nв RouteSim (список уникальных точек по порядку).",
      "source_code": "def build_route_sim(route_dc: SimRoute) -> Route:\n    \"\"\"\n    Конвертирует наш dataclass Route (список сегментов)\n    в RouteSim (список уникальных точек по порядку).\n    \"\"\"\n    points: list = []\n    seen = set()\n    for seg in route_dc.segments:\n        for pt in (seg.start, seg.end):\n            key = (pt.lat, pt.lon)\n            if key not in seen:\n                seen.add(key)\n                points.append(Point(pt.lat, pt.lon))  # если Point общий тип\n    return Route(route_dc.id, points)",
      "imports": [],
      "calls": [
        "seen",
        "Point",
        "points",
        "Route",
        "add",
        "append",
        "set"
      ]
    },
    {
      "id": "function:build_route_by_road_net@app/sim_engine/core/geometry.py",
      "name": "build_route_by_road_net",
      "type": "function",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "",
      "source_code": "def build_route_by_road_net(\n        shovel_id: int,\n        unload_id: int,\n        road_net: dict,\n) -> Route:\n    graph_logic = RoadNetFactory().create_from_geojson(\n        geojson_data=road_net,\n        is_trustful=True,\n    )\n\n    source = (shovel_id, ObjectType.SHOVEL.key())\n    target = (unload_id, ObjectType.UNLOAD.key())\n\n    result = graph_logic.search_path_dijkstra(\n        source=source,\n        target=target,\n        # source_edge_idx=0,\n    )\n    points: list = []\n    seen = set()\n    for edge in result.edges:\n        key = (edge.start.lat, edge.start.lon)\n        if key not in seen:\n            seen.add(key)\n            points.append(Point(*key))\n\n        key = (edge.stop.lat, edge.stop.lon)\n        if key not in seen:\n            seen.add(key)\n            points.append(Point(*key))\n\n    return Route(f\"shov_{source[0]} - unl_{target[0]}\", points)",
      "imports": [],
      "calls": [
        "key",
        "seen",
        "Point",
        "points",
        "create_from_geojson",
        "search_path_dijkstra",
        "graph_logic",
        "Route",
        "add",
        "append",
        "RoadNetFactory",
        "set"
      ]
    },
    {
      "id": "function:build_route_edges_by_road_net@app/sim_engine/core/geometry.py",
      "name": "build_route_edges_by_road_net",
      "type": "function",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "",
      "source_code": "def build_route_edges_by_road_net(\n        from_object_id: int,\n        from_object_type: ObjectType,\n        to_object_id: int,\n        to_object_type: ObjectType,\n        road_net: dict,\n) -> RouteEdge:\n    graph_logic = RoadNetFactory().create_from_geojson(\n        geojson_data=road_net,\n        is_trustful=True,\n    )\n\n    source = (from_object_id, from_object_type.key())\n    target = (to_object_id, to_object_type.key())\n\n    result = graph_logic.search_path_dijkstra(\n        source=source,\n        target=target,\n        # source_edge_idx=0,\n    )\n    return RouteEdge(result.edges)",
      "imports": [],
      "calls": [
        "RouteEdge",
        "key",
        "create_from_geojson",
        "search_path_dijkstra",
        "graph_logic",
        "RoadNetFactory",
        "from_object_type",
        "to_object_type"
      ]
    },
    {
      "id": "function:build_route_edges_by_road_net_from_position@app/sim_engine/core/geometry.py",
      "name": "build_route_edges_by_road_net_from_position",
      "type": "function",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "",
      "source_code": "def build_route_edges_by_road_net_from_position(\n        lon: int | float,\n        lat: int | float,\n        height: int | None,\n        edge_idx: int,\n        to_object_id: int,\n        to_object_type: ObjectType,\n        road_net: dict,\n) -> RouteEdge:\n    graph_logic = RoadNetFactory().create_from_geojson(\n        geojson_data=road_net,\n        is_trustful=True,\n    )\n\n    source = (lon, lat, height)\n    target = (to_object_id, to_object_type.key())\n\n    result = graph_logic.search_path_dijkstra(\n        source=source,\n        target=target,\n        source_edge_idx=edge_idx,\n    )\n    return RouteEdge(result.edges)",
      "imports": [],
      "calls": [
        "RouteEdge",
        "key",
        "create_from_geojson",
        "search_path_dijkstra",
        "graph_logic",
        "RoadNetFactory",
        "to_object_type"
      ]
    },
    {
      "id": "function:build_route_edges_by_road_net_from_position_to_position@app/sim_engine/core/geometry.py",
      "name": "build_route_edges_by_road_net_from_position_to_position",
      "type": "function",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "Строит кратчайший путь на графе от позиции до позиции",
      "source_code": "def build_route_edges_by_road_net_from_position_to_position(\n        lon: float,\n        lat: float,\n        height: float | None,\n        edge_idx: int,\n\n        end_lon: float,\n        end_lat: float,\n        end_height: float | None,\n        end_edge_idx: int | None,\n        road_net: dict\n) -> RouteEdge:\n    \"\"\"Строит кратчайший путь на графе от позиции до позиции\"\"\"\n    graph_logic = RoadNetFactory().create_from_geojson(\n        geojson_data=road_net,\n        is_trustful=True,\n    )\n\n    source = (lon, lat, height)\n    target = (end_lon, end_lat, end_height)\n\n    result = graph_logic.search_path_dijkstra(\n        source=source,\n        target=target,\n        source_edge_idx=edge_idx,\n        target_edge_idx=end_edge_idx,\n    )\n    return RouteEdge(result.edges)",
      "imports": [],
      "calls": [
        "RouteEdge",
        "create_from_geojson",
        "search_path_dijkstra",
        "graph_logic",
        "RoadNetFactory"
      ]
    },
    {
      "id": "function:find_all_route_edges_by_road_net_from_position_to_position@app/sim_engine/core/geometry.py",
      "name": "find_all_route_edges_by_road_net_from_position_to_position",
      "type": "function",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "Ищет все пути на графе от указанной позиции до указанной позиции",
      "source_code": "def find_all_route_edges_by_road_net_from_position_to_position(\n        lon: float,\n        lat: float,\n        height: float | None,\n        edge_idx: int | None,\n\n        end_lon: float,\n        end_lat: float,\n        end_height: float | None,\n        end_edge_idx: int | None,\n        road_net: dict\n):\n    \"\"\"Ищет все пути на графе от указанной позиции до указанной позиции\"\"\"\n    graph_logic = RoadNetFactory().create_from_geojson(\n        geojson_data=road_net,\n        is_trustful=True,\n    )\n\n    source = (lon, lat, height)\n    target = (end_lon, end_lat, end_height)\n\n    paths = graph_logic.search_all_paths(\n        source=source,\n        target=target,\n        source_edge_idx=edge_idx,\n        target_edge_idx=end_edge_idx,\n    )\n\n    result = [RouteEdge(path.edges) for path in paths]\n    result.sort(key=lambda route: sum([edge.length for edge in route.edges]))\n    return result",
      "imports": [],
      "calls": [
        "RouteEdge",
        "sort",
        "sum",
        "search_all_paths",
        "create_from_geojson",
        "graph_logic",
        "result",
        "RoadNetFactory"
      ]
    },
    {
      "id": "function:find_all_route_edges_by_road_net_from_position@app/sim_engine/core/geometry.py",
      "name": "find_all_route_edges_by_road_net_from_position",
      "type": "function",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "Ищет все пути на графе от указанной позиции до указанного объекта",
      "source_code": "def find_all_route_edges_by_road_net_from_position(\n        lon: float,\n        lat: float,\n        height: float | None,\n        edge_idx: int | None,\n\n        to_object_id: int,\n        to_object_type: ObjectType,\n        road_net: dict,\n):\n    \"\"\"Ищет все пути на графе от указанной позиции до указанного объекта\"\"\"\n    graph_logic = RoadNetFactory().create_from_geojson(\n        geojson_data=road_net,\n        is_trustful=True,\n    )\n\n    source = (lon, lat, height)\n    target = (to_object_id, to_object_type.key())\n\n    paths = graph_logic.search_all_paths(\n        source=source,\n        target=target,\n        source_edge_idx=edge_idx,\n    )\n\n    result = [RouteEdge(path.edges) for path in paths]\n    result.sort(key=lambda route: sum([edge.length for edge in route.edges]))\n    return result",
      "imports": [],
      "calls": [
        "RouteEdge",
        "sort",
        "key",
        "sum",
        "search_all_paths",
        "create_from_geojson",
        "graph_logic",
        "result",
        "RoadNetFactory",
        "to_object_type"
      ]
    },
    {
      "id": "function:find_all_route_edges_by_road_net_from_object_to_object@app/sim_engine/core/geometry.py",
      "name": "find_all_route_edges_by_road_net_from_object_to_object",
      "type": "function",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "Ищет все пути на графе от указанной позиции до указанного объекта",
      "source_code": "def find_all_route_edges_by_road_net_from_object_to_object(\n        from_object_id: int,\n        from_object_type: ObjectType,\n\n        to_object_id: int,\n        to_object_type: ObjectType,\n        road_net: dict,\n):\n    \"\"\"Ищет все пути на графе от указанной позиции до указанного объекта\"\"\"\n    graph_logic = RoadNetFactory().create_from_geojson(\n        geojson_data=road_net,\n        is_trustful=True,\n    )\n\n    source = (from_object_id, from_object_type.key())\n    target = (to_object_id, to_object_type.key())\n\n    paths = graph_logic.search_all_paths(\n        source=source,\n        target=target,\n    )\n\n    result = [RouteEdge(path.edges) for path in paths]\n    result.sort(key=lambda route: sum([edge.length for edge in route.edges]))\n    return result",
      "imports": [],
      "calls": [
        "RouteEdge",
        "sort",
        "key",
        "sum",
        "search_all_paths",
        "create_from_geojson",
        "graph_logic",
        "result",
        "RoadNetFactory",
        "from_object_type",
        "to_object_type"
      ]
    },
    {
      "id": "function:interpolate_position@app/sim_engine/core/geometry.py",
      "name": "interpolate_position",
      "type": "function",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "",
      "source_code": "def interpolate_position(p1: Point, p2: Point, ratio: float) -> Point:\n    lat = p1.lat + (p2.lat - p1.lat) * ratio\n    lon = p1.lon + (p2.lon - p1.lon) * ratio\n    return Point(lat, lon)",
      "imports": [],
      "calls": [
        "Point"
      ]
    },
    {
      "id": "function:haversine_km@app/sim_engine/core/geometry.py",
      "name": "haversine_km",
      "type": "function",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "",
      "source_code": "def haversine_km(p1: Point, p2: Point) -> float:\n    R = 6371\n    lat1, lon1 = math.radians(p1.lat), math.radians(p1.lon)\n    lat2, lon2 = math.radians(p2.lat), math.radians(p2.lon)\n    dlat, dlon = lat2 - lat1, lon2 - lon1\n    a = math.sin(dlat / 2)**2 + math.cos(lat1)*math.cos(lat2)*math.sin(dlon / 2)**2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    return R * c",
      "imports": [],
      "calls": [
        "cos",
        "atan2",
        "sqrt",
        "sin",
        "radians",
        "math"
      ]
    },
    {
      "id": "function:find_nearest_point@app/sim_engine/core/geometry.py",
      "name": "find_nearest_point",
      "type": "function",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "",
      "source_code": "def find_nearest_point(point: Point, point_list: list[Point]):\n    nearest_point = min(point_list, key=lambda p: haversine_km(point, p))\n    return nearest_point",
      "imports": [],
      "calls": [
        "min",
        "haversine_km"
      ]
    },
    {
      "id": "function:find_route_edges_around_restricted_zones_from_base_route@app/sim_engine/core/geometry.py",
      "name": "find_route_edges_around_restricted_zones_from_base_route",
      "type": "function",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "Поиск маршрута в объезд запрещённых зон (полигонов) на основе заданного маршрута",
      "source_code": "def find_route_edges_around_restricted_zones_from_base_route(\n        base_route: RouteEdge,\n        restricted_zones: Tuple[Tuple[Tuple[float, float]]] | list[list[list[float]]],\n        road_net: dict\n) -> RouteEdge | None:\n    \"\"\"\n        Поиск маршрута в объезд запрещённых зон (полигонов) на основе заданного маршрута\n    \"\"\"\n    all_routes = find_all_route_edges_by_road_net_from_position_to_position(\n        lon=base_route.start_point.x,\n        lat=base_route.start_point.y,\n        height=0,\n        edge_idx=base_route.edges[0].index,\n        end_lon=base_route.end_point.x,\n        end_lat=base_route.end_point.y,\n        end_height=0,\n        end_edge_idx=None,\n        road_net=road_net,\n    )\n\n    # Маршруты отсортированы по длине, выберем первый, не попадающий в запрещённые зоны\n    chosen_route = None\n    for route in all_routes:\n        if not path_intersects_polygons(route, restricted_zones):\n            chosen_route = route\n            break\n\n    return chosen_route",
      "imports": [],
      "calls": [
        "find_all_route_edges_by_road_net_from_position_to_position",
        "path_intersects_polygons"
      ]
    },
    {
      "id": "function:find_route_edges_around_restricted_zones_from_position_to_object@app/sim_engine/core/geometry.py",
      "name": "find_route_edges_around_restricted_zones_from_position_to_object",
      "type": "function",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/geometry.py",
      "docstring": "Поиск маршрута в объезд запрещённых зон (полигонов) от позиции до объекта",
      "source_code": "def find_route_edges_around_restricted_zones_from_position_to_object(\n        lon: float,\n        lat: float,\n        edge_idx: int | None,\n        to_object_id: int,\n        to_object_type: ObjectType,\n        restricted_zones: Tuple[Tuple[Tuple[float, float]]] | list[list[list[float]]],\n        road_net: dict\n) -> RouteEdge | None:\n    \"\"\"\n        Поиск маршрута в объезд запрещённых зон (полигонов) от позиции до объекта\n    \"\"\"\n    # Строим маршрут к зоне ожидания\n    all_routes = find_all_route_edges_by_road_net_from_position(\n        lon=lon,\n        lat=lat,\n        height=None,\n        edge_idx=edge_idx,\n        to_object_id=to_object_id,\n        to_object_type=to_object_type,\n        road_net=road_net,\n    )\n\n    # Маршруты отсортированы по длине, выберем первый, не попадающий в запрещённые зоны\n    chosen_route = None\n    for route in all_routes:\n        if not path_intersects_polygons(route, restricted_zones):\n            chosen_route = route\n            break\n\n    return chosen_route",
      "imports": [],
      "calls": [
        "find_all_route_edges_by_road_net_from_position",
        "path_intersects_polygons"
      ]
    },
    {
      "id": "class:Point@app/sim_engine/core/props.py",
      "name": "Point",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class Point:\n    lat: float\n    lon: float",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:Segment@app/sim_engine/core/props.py",
      "name": "Segment",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class Segment:\n    start: Point\n    end: Point",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:Route@app/sim_engine/core/props.py",
      "name": "Route",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class Route:\n    id: int\n    segments: list[Segment]\n    shovel_id: int\n    unload_id: int\n    truck_ids: list[int]",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ShovelProperties@app/sim_engine/core/props.py",
      "name": "ShovelProperties",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class ShovelProperties:\n    obem_kovsha_m3: float\n    skorost_podem_m_s: float\n    skorost_povorot_rad_s: float\n    skorost_vrezki_m_s: float\n    skorost_napolneniya_m_s: float\n    initial_operating_time: int\n    average_repair_duration: int\n    initial_failure_count: int\n    koef_zapolneniya: float = 0.8\n    koef_gidravliki: float = 1.1\n    koef_inertsii: float = 1.2\n    koef_vozvrata: float = 0.85\n    tip_porody: str = 'sand'\n    vlazhnost_percent: float = 10.0",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:Shovel@app/sim_engine/core/props.py",
      "name": "Shovel",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class Shovel:\n    id: int\n    name: str\n    initial_lat: float\n    initial_lon: float\n    properties: ShovelProperties",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:UnlProperties@app/sim_engine/core/props.py",
      "name": "UnlProperties",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class UnlProperties:\n    angle: float\n    material_type: str\n    type_unloading: str\n    initial_operating_time: int\n    average_repair_duration: int\n    initial_failure_count: int\n    trucks_at_once: int = 100",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:Unload@app/sim_engine/core/props.py",
      "name": "Unload",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class Unload:\n    id: int\n    name: str\n    properties: UnlProperties",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:FuelStationProperties@app/sim_engine/core/props.py",
      "name": "FuelStationProperties",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class FuelStationProperties:\n    num_pumps: int\n    flow_rate: float",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:FuelStation@app/sim_engine/core/props.py",
      "name": "FuelStation",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class FuelStation:\n    id: int\n    name: str\n    initial_lat: float\n    initial_lon: float\n    properties: FuelStationProperties",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ShiftChangeArea@app/sim_engine/core/props.py",
      "name": "ShiftChangeArea",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class ShiftChangeArea:\n    id: int\n    name: str\n    initial_lat: float\n    initial_lon: float",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:IdleArea@app/sim_engine/core/props.py",
      "name": "IdleArea",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class IdleArea:\n    id: int\n    name: str\n    initial_lon: float\n    initial_lat: float\n\n    is_shift_change_area: bool = False\n    is_planned_idle_area: bool = False\n    is_lunch_area: bool = False\n    is_blast_waiting_area: bool = False",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:IdleAreaStorage@app/sim_engine/core/props.py",
      "name": "IdleAreaStorage",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [
        "all",
        "lunch_areas",
        "shift_change_areas",
        "planned_idle_areas",
        "blast_waiting_areas"
      ],
      "source_code": "class IdleAreaStorage:\n    areas: list[IdleArea] = field(default_factory=list)\n\n    @property\n    def all(self):\n        return self.areas\n\n    @property\n    def lunch_areas(self):\n        return [area for area in self.areas if area.is_lunch_area]\n\n    @property\n    def shift_change_areas(self):\n        return [area for area in self.areas if area.is_shift_change_area]\n\n    @property\n    def planned_idle_areas(self):\n        return [area for area in self.areas if area.is_planned_idle_area]\n\n    @property\n    def blast_waiting_areas(self):\n        return [area for area in self.areas if area.is_blast_waiting_area]",
      "imports": [],
      "calls": [
        "field"
      ]
    },
    {
      "id": "class:TruckProperties@app/sim_engine/core/props.py",
      "name": "TruckProperties",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class TruckProperties:\n    body_capacity: float\n    speed_empty_kmh: float\n    speed_loaded_kmh: float\n    initial_operating_time: int\n    average_repair_duration: int\n    initial_failure_count: int\n\n    # топливо\n    fuel_capacity: float\n    fuel_threshold_critical: float\n    fuel_threshold_planned: float\n    fuel_level: float\n    fuel_idle_lph: float\n    fuel_specific_consumption: float\n    fuel_density: float\n    engine_power_kw: float\n\n    # default\n    acceleration_empty: float = 2.8\n    acceleration_loaded: float = 1.4\n    driver_skill: float = 1.0",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:Truck@app/sim_engine/core/props.py",
      "name": "Truck",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class Truck:\n    id: int\n    name: str\n    initial_lat: float\n    initial_lon: float\n    initial_edge_id: int\n    properties: TruckProperties",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:PlannedIdle@app/sim_engine/core/props.py",
      "name": "PlannedIdle",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class PlannedIdle:\n    id: int\n    vehicle_type: Literal[\"shovel\", \"truck\"]\n    start_time: datetime\n    end_time: datetime\n    quarry_id: int\n    vehicle_id: int",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:Blasting@app/sim_engine/core/props.py",
      "name": "Blasting",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class Blasting:\n    id: int\n    zones: list[list[list[float]]]\n    start_time: datetime\n    end_time: datetime",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:SimData@app/sim_engine/core/props.py",
      "name": "SimData",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class SimData:\n    start_time: datetime\n    end_time: datetime\n    duration: int\n\n    seed: int | None\n\n    trucks: dict[int, Truck]\n    shovels: dict[int, Shovel]\n    unloads: dict[int, Unload]\n    idle_areas: IdleAreaStorage\n    fuel_stations: dict[int, FuelStation]\n\n    routes: list[Route]\n    road_net: dict\n\n    lunch_times: list[tuple[datetime, datetime]] = field(default_factory=list)\n    planned_idles: dict[tuple[str, int], PlannedIdle] = field(default_factory=dict)\n    blasting_list: list[Blasting] = field(default_factory=list)",
      "imports": [],
      "calls": [
        "field"
      ]
    },
    {
      "id": "class:TripData@app/sim_engine/core/props.py",
      "name": "TripData",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class TripData:\n    truck_id: int\n    truck_weight: int | float\n    truck_volume: int | float\n    shovel_id: int | None\n    unload_id: int | None",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:PlannedTrip@app/sim_engine/core/props.py",
      "name": "PlannedTrip",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class PlannedTrip:\n    truck_id: int\n    shovel_id: int\n    unload_id: int\n    order: int",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:QuarryObject@app/sim_engine/core/props.py",
      "name": "QuarryObject",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [],
      "source_code": "class QuarryObject:\n    id: int\n    type: ObjectType",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:ActualTrip@app/sim_engine/core/props.py",
      "name": "ActualTrip",
      "type": "class",
      "layer": "Ядро симуляции",
      "file_path": "app/sim_engine/core/props.py",
      "docstring": "",
      "methods": [
        "is_finished",
        "to_telemetry"
      ],
      "source_code": "class ActualTrip:\n    start_trip_data: TripData\n    start_object: QuarryObject\n    start_time: datetime\n    end_trip_data: TripData | None = None\n    end_object: QuarryObject | None = None\n    end_time: datetime | None = None\n\n    def is_finished(self) -> bool:\n        return (\n                self.end_object is not None and\n                self.end_time is not None and\n                self.end_trip_data is not None\n        )\n\n    def to_telemetry(self) -> dict:\n        if not self.is_finished():\n            raise RuntimeError('Trip is not finished')\n\n        return {\n            'truck_id': self.end_trip_data.truck_id,\n            'shovel_id': self.end_trip_data.shovel_id,\n            'unload_id': self.end_trip_data.unload_id,\n            'volume': int(self.end_trip_data.truck_volume),  # m3\n            'weight': int(self.end_trip_data.truck_weight),\n            'time': self.end_time.isoformat(),  # TODO: убрать позже, оставил для обратной совместимости\n            'start_time': self.start_time.isoformat(),\n            'end_time': self.end_time.isoformat(),\n            'start_object': {\n                'id': self.start_object.id,\n                'type': self.start_object.type.key(),\n            },\n            'end_object': {\n                'id': self.end_object.id,\n                'type': self.end_object.type.key(),\n            },\n        }",
      "imports": [],
      "calls": [
        "self",
        "key",
        "isoformat",
        "RuntimeError",
        "int",
        "is_finished"
      ]
    },
    {
      "id": "class:RunSimulationError@app/sim_engine/infra/exception_traceback.py",
      "name": "RunSimulationError",
      "type": "class",
      "layer": "Инфраструктура",
      "file_path": "app/sim_engine/infra/exception_traceback.py",
      "docstring": "",
      "methods": [],
      "source_code": "class RunSimulationError(Exception):\n    pass",
      "imports": [],
      "calls": []
    },
    {
      "id": "function:catch_errors@app/sim_engine/infra/exception_traceback.py",
      "name": "catch_errors",
      "type": "function",
      "layer": "Инфраструктура",
      "file_path": "app/sim_engine/infra/exception_traceback.py",
      "docstring": "",
      "source_code": "def catch_errors(func):\n    @functools.wraps(func)\n    def wrapper(*args, **kwargs):\n        try:\n            result = func(*args, **kwargs)\n            return result\n        except Exception as e:\n            tb_str = traceback.format_exc()\n\n            logger = logging.getLogger('catch_errors_decorator')\n            logger.error(tb_str)\n\n            raise RunSimulationError(e)\n\n    return wrapper",
      "imports": [],
      "calls": [
        "logging",
        "logger",
        "error",
        "func",
        "functools",
        "getLogger",
        "traceback",
        "format_exc",
        "RunSimulationError",
        "wraps"
      ]
    },
    {
      "id": "class:JsonFormatter@app/sim_engine/infra/logger/json_formatter.py",
      "name": "JsonFormatter",
      "type": "class",
      "layer": "Инфраструктура",
      "file_path": "app/sim_engine/infra/logger/json_formatter.py",
      "docstring": "",
      "methods": [
        "format"
      ],
      "source_code": "class JsonFormatter(logging.Formatter):\n    def format(self, record: logging.LogRecord) -> str:\n        log_object = {\n            'timestamp': datetime.datetime.fromtimestamp(record.created, datetime.UTC).isoformat() + 'Z',\n            'level': record.levelname,\n            'name': record.name,\n            'message': record.getMessage(),\n            'filename': record.filename,\n            'lineno': record.lineno,\n        }\n\n        if record.args and isinstance(record.args, dict):\n            # log_object['data'] = json.dumps(record.args, ensure_ascii=False)\n            # log_object['data'] = record.args\n            log_object.update(record.args)\n\n        return json.dumps(log_object, ensure_ascii=False)",
      "imports": [],
      "calls": [
        "record",
        "isoformat",
        "getMessage",
        "json",
        "update",
        "fromtimestamp",
        "log_object",
        "isinstance",
        "dumps"
      ]
    },
    {
      "id": "class:Logger@app/sim_engine/infra/logger/logger.py",
      "name": "Logger",
      "type": "class",
      "layer": "Инфраструктура",
      "file_path": "app/sim_engine/infra/logger/logger.py",
      "docstring": "",
      "methods": [
        "init"
      ],
      "source_code": "class Logger:\n    @staticmethod\n    def init() -> None:\n        logging.config.dictConfig(LOGGING_CONFIG)",
      "imports": [],
      "calls": [
        "dictConfig"
      ]
    },
    {
      "id": "class:BreakdownCalc@app/sim_engine/core/calculations/base.py",
      "name": "BreakdownCalc",
      "type": "class",
      "layer": "Расчёты",
      "file_path": "app/sim_engine/core/calculations/base.py",
      "docstring": "Расчеты Поломок/Восстановлений",
      "methods": [
        "__init__",
        "_calculate_rates",
        "calculate_failure_time",
        "calculate_repair_time"
      ],
      "source_code": "class BreakdownCalc:\n    \"\"\"Расчеты Поломок/Восстановлений\"\"\"\n\n    def __init__(self, seeded_random: random.Random):\n        self.seeded_random = seeded_random\n\n    def _calculate_rates(\n            self, **kwargs\n    ):\n        T_A = kwargs[\"initial_operating_time\"]\n        MTTR = kwargs[\"average_repair_duration\"]\n        N_F = kwargs[\"initial_failure_count\"]\n\n        MTBF = T_A / N_F  # Среднее время между отказами\n        failure_rate = 1 / MTBF  # Интенсивность отказов λ\n        repair_rate = 1 / MTTR  # Параметр экспоненциального закона восстановления\n\n        return {\n            \"failure_rate\": failure_rate,\n            \"repair_rate\": repair_rate,\n        }\n\n    def calculate_failure_time(self, **kwargs):\n        \"\"\"\n        Время не секунд семуляции, а секунд работы актора\n        самосвал: работа - движение груженым, движение порожним, разгрузка\n        экскаватор: работа - погрузка\n        ПР: во время разгрузки\n        \"\"\"\n        rates = self._calculate_rates(**kwargs)\n        return self.seeded_random.expovariate(rates[\"failure_rate\"])\n\n    def calculate_repair_time(self, **kwargs):\n        rates = self._calculate_rates(**kwargs)\n        return self.seeded_random.expovariate(rates[\"repair_rate\"])",
      "imports": [],
      "calls": [
        "self",
        "expovariate",
        "_calculate_rates"
      ]
    },
    {
      "id": "class:FuelCalc@app/sim_engine/core/calculations/base.py",
      "name": "FuelCalc",
      "type": "class",
      "layer": "Расчёты",
      "file_path": "app/sim_engine/core/calculations/base.py",
      "docstring": "",
      "methods": [
        "calculate_fuel_level_while_moving",
        "calculate_fuel_level_while_idle"
      ],
      "source_code": "class FuelCalc:\n\n    @staticmethod\n    def calculate_fuel_level_while_moving(fuel_lvl, sfc, density, p_engine):\n        fuel_rate = ((sfc / (1000 * density)) * p_engine) / 3600\n        fuel_lvl -= fuel_rate\n        return fuel_lvl\n\n    @staticmethod\n    def calculate_fuel_level_while_idle(fuel_lvl, fuel_idle_lph):\n        fuel_rate = fuel_idle_lph / 3600\n        fuel_lvl -= fuel_rate\n        return fuel_lvl",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:LunchCalc@app/sim_engine/core/calculations/base.py",
      "name": "LunchCalc",
      "type": "class",
      "layer": "Расчёты",
      "file_path": "app/sim_engine/core/calculations/base.py",
      "docstring": "Расчёты времён обеденных перерывов",
      "methods": [
        "calculate_lunch_times"
      ],
      "source_code": "class LunchCalc:\n    \"\"\"Расчёты времён обеденных перерывов\"\"\"\n\n    @staticmethod\n    def calculate_lunch_times(\n            sim_start_time: datetime,\n            lunch_times: list[tuple[datetime, datetime]]\n    ) -> list[tuple[int, int]]:\n        \"\"\"Рассчитываем моменты начала и конца обеденных перерывов относительно времени симуляции\"\"\"\n        result = []\n\n        for lunch_start, lunch_end in lunch_times:\n            if lunch_start <= sim_start_time <= lunch_end:\n                end_time = (lunch_end-sim_start_time).total_seconds()\n                result.append(\n                    (0, end_time)\n                )\n            if sim_start_time <= lunch_start < lunch_end:\n                result.append(\n                    (\n                        (lunch_start - sim_start_time).total_seconds(),\n                        (lunch_end - sim_start_time).total_seconds(),\n                    )\n                )\n        return result",
      "imports": [],
      "calls": [
        "result",
        "total_seconds",
        "append"
      ]
    },
    {
      "id": "class:ShovelCalc@app/sim_engine/core/calculations/shovel.py",
      "name": "ShovelCalc",
      "type": "class",
      "layer": "Расчёты",
      "file_path": "app/sim_engine/core/calculations/shovel.py",
      "docstring": "",
      "methods": [
        "calculate_cycle",
        "_calculate_load_cycles_generator",
        "calculate_load_cycles",
        "calculate_load_cycles_cumulative_generator",
        "get_koef"
      ],
      "source_code": "class ShovelCalc:\n\n    @classmethod\n    def calculate_cycle(\n        cls,\n        props: ShovelProperties,\n        glubina_vrezki_m=0.3, dlina_drag_m=2.0,\n        visota_podem_m=3.0, ugol_swing_rad=np.pi/2,\n        ugol_dump_rad=np.pi/6, alpha_idle=0.3\n    ) -> dict:\n        \"\"\"\n        Расчёт времён всех стадий одного цикла работы Экскаватора\n        ждём самосвал, наполняем ковш, поворачиваемся, грузим и всё с самого начала\n        \"\"\"\n        k = cls.get_koef(props)\n        # ВРЕЗКА КОВША (Глубина * Коэф. сопротивления * Коэф. влажности) / Скорость * Коэф. температуры\n        t1 = (glubina_vrezki_m * k['K_r'] * k['K_w']) / props.skorost_vrezki_m_s * k['K_T']\n        # 2. НАПОЛНЕНИЕ КОВША  (Длина хода * Коэф. сопротивления * Коэф. влажности) / (Скорость * Коэф. наполнения) * Коэф. температуры\n        t2 = (dlina_drag_m * k['K_r'] * k['K_w']) / (props.skorost_napolneniya_m_s * k['K_f']) * k['K_T']\n        # 3. ПОДЪЁМ КОВША Высота / Скорость * Коэф. инерции * Коэф. гидравлики * Коэф. температуры\n        t3 = visota_podem_m / props.skorost_podem_m_s * k['K_i'] * k['K_h'] * k['K_T']\n        # 4. ПОВОРОТ СТРЕЛЫ Угол / Скорость * Коэф. инерции * Коэф. гидравлики * Коэф. температуры\n        t4 = ugol_swing_rad / props.skorost_povorot_rad_s * k['K_i'] * k['K_h'] * k['K_T']\n        # 5. РАЗГРУЗКА Угол выгрузки / Скорость * Коэф. гидравлики * Коэф. температуры\n        t5 = ugol_dump_rad / props.skorost_povorot_rad_s * k['K_h'] * k['K_T']\n        # 6. ВОЗВРАТ Угол / Скорость * Коэф. возврата * Коэф. гидравлики * Коэф. температуры\n        t6 = ugol_swing_rad / props.skorost_povorot_rad_s * k['K_ret'] * k['K_h'] * k['K_T']\n\n        Kw = 1\n        driver_rating = 1\n\n        t1 *= Kw\n        t2 *= Kw\n        # Ожидания (idle) на каждой стадии  alpha_idle * t / driver_rating\n        idle = lambda t: alpha_idle * t / driver_rating\n        idles = [idle(t) for t in [t1, t2, t3, t4, t5, t6]]\n        total_s = sum([t1, t2, t3, t4, t5, t6]) + sum(idles)\n        return {\n            'vrezka_s': t1, 'idle_vrezka_s': idles[0],\n            'napolnenie_s': t2, 'idle_napoln_s': idles[1],\n            'podem_s': t3, 'idle_podem_s': idles[2],\n            'povorot_s': t4, 'idle_povorot_s': idles[3],\n            'razgruzka_s': t5, 'idle_dump_s': idles[4],\n            'vozvrat_s': t6, 'idle_vozv_s': idles[5],\n            'K_wear': Kw, 'vsego_s': total_s\n        }\n\n    @classmethod\n    def _calculate_load_cycles_generator(\n            cls,\n            shovel_props: ShovelProperties,\n            truck_props: TruckProperties\n    ) -> Generator[Tuple[int, float, float], None, None]:\n        \"\"\"\n        Генератор циклов погрузки для заполнения самосвала.\n\n        Последовательно рассчитывает циклы погрузки экскаватора до полного заполнения\n        кузова самосвала, контролируя суммарный вес груза.\n\n        Parameters\n        ----------\n        shovel_props : ShovelProperties\n            Свойства экскаватора\n        truck_props : TruckProperties\n            Свойства самосвала\n\n        Yields\n        ------\n        Tuple[int, float, float]\n            Кортеж содержащий:\n            - int: продолжительность цикла в секундах\n            - float: вес груза в тоннах за текущий цикл\n            - float: объем груза в м³ за текущий цикл\n\n        Notes\n        -----\n        - Генератор останавливается, когда добавление следующего ковша превысит\n          грузоподъемность самосвала\n        - Используется плотность материала из глобального словаря density_by_material\n        - Вес рассчитывается с учетом коэффициента заполнения ковша\n        \"\"\"\n        density = density_by_material[shovel_props.tip_porody]\n        weight = 0\n\n        while True:\n            cycle = cls.calculate_cycle(props=shovel_props)\n            cycle_volume = shovel_props.obem_kovsha_m3 * shovel_props.koef_zapolneniya\n            cycle_weight = cycle_volume * density\n\n            # Проверяем, не приведёт ли добавление этого ковша к перевесу\n            if weight + cycle_weight > truck_props.body_capacity:\n                break\n\n            weight += cycle_weight\n            yield int(cycle[\"vsego_s\"]), cycle_weight, cycle_volume\n\n    @classmethod\n    def calculate_load_cycles(\n            cls,\n            shovel_props: ShovelProperties,\n            truck_props: TruckProperties\n    ) -> Tuple[int, float, float]:\n        \"\"\"\n            Рассчитывает суммарные показатели полного цикла погрузки самосвала.\n\n            Агрегирует данные всех циклов погрузки, сгенерированных методом\n            `_calculate_load_cycles_generator`, и возвращает общие итоги по времени,\n            весу и объему за всю операцию погрузки одного самосвала.\n\n            Parameters\n            ----------\n            shovel_props : ShovelProperties\n                Свойства экскаватора\n            truck_props : TruckProperties\n                Свойства самосвала\n\n            Returns\n            -------\n            Tuple[int, float, float]\n                Кортеж содержащий:\n                - int: общее время погрузки в секундах\n                - float: суммарный вес груза в тоннах\n                - float: суммарный объем груза в м³\n\n            Notes\n            -----\n            - Метод использует генератор `_calculate_load_cycles_generator` для получения\n              последовательности циклов погрузки\n            - Суммирование прекращается при достижении максимальной грузоподъемности самосвала\n            - Возвращаемые значения представляют полную загрузку одного самосвала\n        \"\"\"\n        total_weight = 0\n        total_volime = 0\n        total_time = 0\n        for time, weight, volume in cls._calculate_load_cycles_generator(shovel_props, truck_props):\n            total_time += time\n            total_volime += volume\n            total_weight += weight\n        return total_time, total_weight, total_volime\n\n    @classmethod\n    def calculate_load_cycles_cumulative_generator(\n            cls,\n            shovel_props: ShovelProperties,\n            truck_props: TruckProperties\n    ) -> Generator[Tuple[int, float, float], None, None]:\n        \"\"\"\n            Генератор циклов погрузки с накопленными итогами.\n\n            Последовательно выдает данные каждого цикла погрузки с кумулятивными\n            (накопленными) значениями веса и объема. Позволяет отслеживать прогресс\n            заполнения самосвала после каждого цикла.\n\n            Parameters\n            ----------\n            shovel_props : ShovelProperties\n                Свойства экскаватора для расчета циклов погрузки\n            truck_props : TruckProperties\n                Свойства самосвала, определяющие максимальную грузоподъемность\n\n            Yields\n            ------\n            Tuple[int, float, float]\n                Кортеж содержащий:\n                - int: продолжительность ТЕКУЩЕГО ЦИКЛА в секундах\n                - float: накопленный суммарный вес груза в тоннах (с учетом текущего цикла)\n                - float: накопленный суммарный объем груза в м³ (с учетом текущего цикла)\n\n            Notes\n            -----\n            - В отличие от `_calculate_load_cycles_generator`, возвращает накопленные значения\n            - Полезен для анализа прогресса погрузки и построения графиков заполнения\n            - ВРЕМЯ ВОЗВРАЩАЕТСЯ ДЛЯ ОТДЕЛЬНОГО ЦИКЛА, а вес и объем - кумулятивные\n        \"\"\"\n        total_weight = 0\n        total_volime = 0\n        for time, weight, volume in cls._calculate_load_cycles_generator(shovel_props, truck_props):\n            total_volime += volume\n            total_weight += weight\n            yield time, total_weight, total_volime\n\n\n\n    @staticmethod\n    def get_koef(props) -> dict:\n        return {\n            'K_f': props.koef_zapolneniya,\n            'K_r': koef_soprotivleniya[props.tip_porody],\n            'K_w': koef_vlazhnosti(props.vlazhnost_percent),\n            'K_T': 1.25,\n            'K_i': props.koef_inertsii,\n            'K_h': props.koef_gidravliki,\n            'K_ret': props.koef_vozvrata\n        }",
      "imports": [],
      "calls": [
        "get_koef",
        "koef_vlazhnosti",
        "sum",
        "_calculate_load_cycles_generator",
        "idle",
        "cls",
        "int",
        "calculate_cycle"
      ]
    },
    {
      "id": "class:TruckCalc@app/sim_engine/core/calculations/truck.py",
      "name": "TruckCalc",
      "type": "class",
      "layer": "Расчёты",
      "file_path": "app/sim_engine/core/calculations/truck.py",
      "docstring": "",
      "methods": [
        "calculate_segment_motion",
        "calculate_motion",
        "calculate_edge_motion",
        "calculate_motion_by_edges",
        "calculate_time_motion_by_edges",
        "time_empty",
        "time_loaded"
      ],
      "source_code": "class TruckCalc:\n    @classmethod\n    def calculate_segment_motion(\n            cls,\n            p1: Point,\n            p2: Point,\n            initial_speed: float,\n            speed_limit: float,\n            acceleration: float,\n            time_step_sec: int = 1\n    ) -> Generator[tuple[float, Point], None, None]:\n        \"\"\"\n        Расчет движения между двумя точками в маршруте\n        \"\"\"\n        distance_km = haversine_km(p1, p2)\n        travelled_km = 0.0\n        speed = initial_speed\n\n        while travelled_km < distance_km:\n            speed = min(speed + acceleration, speed_limit)\n            delta_km = speed * time_step_sec / 3600.0  # перевод в км\n            travelled_km = min(travelled_km + delta_km, distance_km)\n            ratio = travelled_km / distance_km\n            new_position = interpolate_position(p1, p2, ratio)\n            yield speed, new_position\n\n    @classmethod\n    def calculate_motion(cls, route, props, forward):\n        \"\"\"\n        Расчет движения по маршруту состоящего из списка точек\n        \"\"\"\n\n        points = route.points if forward else list(reversed(route.points))\n        speed_limit = props.speed_empty_kmh if not forward else props.speed_loaded_kmh\n        acceleration = props.acceleration_empty if not forward else props.acceleration_loaded\n\n        current_speed = 0.0  # начальная скорость\n\n        for i in range(len(points) - 1):\n            for speed, position in cls.calculate_segment_motion(points[i], points[i + 1], current_speed, speed_limit,\n                                                                 acceleration):\n                yield speed, position\n                current_speed = speed  # <--- обновляем накопленную скорость\n\n    @classmethod\n    def calculate_edge_motion(\n            cls,\n            edge: Edge,\n            initial_speed: float,\n            speed_limit: float,\n            acceleration: float,\n            time_step_sec: int = 1\n    ) -> Generator[tuple[float, Point], None, None]:\n        \"\"\"\n        Расчет движения по ребру графа\n        \"\"\"\n        distance_km = edge.length / 1000\n        # distance_km = haversine_km(edge.start, edge.stop)\n\n        travelled_km = 0.0\n        speed = initial_speed\n\n        while travelled_km < distance_km:\n            speed = min(speed + acceleration, speed_limit)\n            delta_km = speed * time_step_sec / 3600.0  # перевод в км\n            travelled_km = min(travelled_km + delta_km, distance_km)\n            ratio = travelled_km / distance_km\n            new_position = interpolate_position(edge.start, edge.stop, ratio)\n            yield speed, new_position\n\n    @classmethod\n    def calculate_motion_by_edges(cls, route: RouteEdge, props, forward, is_loaded):\n        \"\"\"\n        Расчет движения по списку ребер графа\n        \"\"\"\n\n        speed_limit = props.speed_empty_kmh if not is_loaded else props.speed_loaded_kmh\n        acceleration = props.acceleration_empty if not is_loaded else props.acceleration_loaded\n\n        current_speed = 0.0  # начальная скорость\n\n        if forward:\n            generator_path = route.move_along_edges_gen\n        else:\n            generator_path = route.move_along_edges_reversed_gen\n\n        for edge in generator_path():\n            for speed, position in cls.calculate_edge_motion(\n                    edge,\n                    current_speed,\n                    speed_limit,\n                    acceleration\n            ):\n                yield speed, position, edge\n                current_speed = speed  # <--- обновляем накопленную скорость\n\n    @classmethod\n    def calculate_time_motion_by_edges(cls, route: RouteEdge, props, forward):\n        is_loaded = forward\n        return sum([1 for _ in cls.calculate_motion_by_edges(route, props, forward, is_loaded)])\n\n    # ---- Новые методы расчета из core_sim, пока нигде не работают----\n    def time_empty(self) -> int:\n        \"\"\"\n        Время движения порожним к экскаватору (сек)\n        Формула: t = S / v * 3600 / driver_skill,\n        где S — длина пути (км), v — скорость порожним (км/ч)\n        \"\"\"\n        t = self.distance_km / self.speed_empty_kmh * 3600\n        return int(np.ceil(t / self.driver_skill))\n\n    def time_loaded(self) -> int:\n        \"\"\"\n        Время движения гружённым к разгрузке (сек)\n        Формула: t = S / v * 3600 / driver_skill,\n        где S — длина пути (км), v — скорость гружённым (км/ч)\n        \"\"\"\n        t = self.distance_km / self.speed_loaded_kmh * 3600\n        return int(np.ceil(t / self.driver_skill))",
      "imports": [],
      "calls": [
        "range",
        "reversed",
        "generator_path",
        "calculate_segment_motion",
        "np",
        "sum",
        "min",
        "len",
        "interpolate_position",
        "calculate_edge_motion",
        "cls",
        "int",
        "calculate_motion_by_edges",
        "list",
        "ceil",
        "haversine_km"
      ]
    },
    {
      "id": "class:UnloadCalc@app/sim_engine/core/calculations/unload.py",
      "name": "UnloadCalc",
      "type": "class",
      "layer": "Расчёты",
      "file_path": "app/sim_engine/core/calculations/unload.py",
      "docstring": "",
      "methods": [
        "unload_calculation",
        "unload_calculation_by_norm"
      ],
      "source_code": "class UnloadCalc:\n\n    @classmethod\n    def unload_calculation(\n            cls,\n            props: UnlProperties,\n            truck_volume\n    ):\n        \"\"\"\n        1. t_drive — подъезд (сек), фиксированно 30 сек\n        2. t_stop — остановка и установка (15 сек)\n        3. t_lift — подъем кузова (20 сек)\n        4. t_dump — высыпание груза:\n            t_dump = V / (speed * K_угол * K_мат * K_темп)\n        5. t_down — опускание кузова (15 сек)\n        6. t_leave — уход (30 сек)\n        потом исправлю CHANGE\n        длина участка для маневра\n        средняя скорость маневра\n        замедление\n        \"\"\"\n        driver_rating = 1\n        t_drive = 30 / driver_rating\n        t_stop = 0  # было 15 / driver_rating, заменили на 0\n        t_lift = 10\n        t_down = 10\n        t_leave = t_drive\n        K_ugl = 1 + 0.01 * max(props.angle - 25, 0)\n        K_temp = 1.25\n        K_mat = koef_soprotivleniya[props.material_type]\n        speed = unloading_speed[props.type_unloading]\n        t_dump = truck_volume / (speed * K_ugl * K_mat * K_temp)\n        total_time = t_drive + t_stop + t_lift + t_dump + t_down + t_leave\n        return {\n            't_drive': t_drive, 't_stop': t_stop, 't_lift': t_lift,\n            't_dump': t_dump, 't_down': t_down, 't_leave': t_leave,\n            't_total': total_time,\n            'params': dict(K_ugl=K_ugl, K_temp=K_temp, K_mat=K_mat, speed=speed)\n        }\n\n    @classmethod\n    def unload_calculation_by_norm(cls, unload_props: UnlProperties, truck_props: TruckProperties):\n        \"\"\"\n        1. t_drive — подъезд (сек), фиксированно 30 сек\n        2. t_stop — остановка и установка (15 сек)\n        3. t_lift — подъем кузова (20 сек)\n        4. t_dump — высыпание груза:\n            t_dump = V / (speed * K_угол * K_мат * K_темп)\n        5. t_down — опускание кузова (15 сек)\n        6. t_leave — уход (30 сек)\n        потом исправлю CHANGE\n        длина участка для маневра\n        средняя скорость маневра\n        замедление\n        \"\"\"\n        density = density_by_material[unload_props.material_type]\n        truck_volume = truck_props.body_capacity / density\n\n        driver_rating = 1\n        t_drive = 30 / driver_rating\n        t_stop = 15 / driver_rating\n        t_lift = 20\n        t_down = 15\n        t_leave = t_drive\n        K_ugl = 1 + 0.01 * max(unload_props.angle - 25, 0)\n        K_temp = 1\n        K_mat = koef_soprotivleniya[unload_props.material_type]\n        speed = unloading_speed[unload_props.type_unloading]\n        t_dump = truck_volume / (speed * K_ugl * K_mat * K_temp)\n        total_time = t_drive + t_stop + t_lift + t_dump + t_down + t_leave\n        return {\n            't_drive': t_drive, 't_stop': t_stop, 't_lift': t_lift,\n            't_dump': t_dump, 't_down': t_down, 't_leave': t_leave,\n            't_total': total_time,\n            'params': dict(K_ugl=K_ugl, K_temp=K_temp, K_mat=K_mat, speed=speed)\n        }",
      "imports": [],
      "calls": [
        "dict",
        "max"
      ]
    },
    {
      "id": "class:InputPlanningData@app/sim_engine/core/planner/entities.py",
      "name": "InputPlanningData",
      "type": "class",
      "layer": "Планировщик",
      "file_path": "app/sim_engine/core/planner/entities.py",
      "docstring": "",
      "methods": [
        "truck_ids",
        "shovel_ids",
        "unload_ids"
      ],
      "source_code": "class InputPlanningData:\n    N: int  # количество самосвалов\n    M: int  # количество экскаваторов\n    Z: int  # количество площадок разгрузки\n    D_work: int  # длительность смены (мин)\n\n    # Матрицы/словари времени:\n    T_haul: Dict[Tuple[int, int, int], int]  # ключ (i,j,z)\n    T_return: Dict[Tuple[int, int, int], int]  # ключ (i,j,z)\n    T_load: Dict[Tuple[int, int], int]  # ключ (i,j)\n    T_unload: Dict[Tuple[int, int], int]  # ключ (i,z)\n    T_start: Dict[Tuple[int, int], int]  # ключ (i,j)\n    T_end: Dict[Tuple[int, int], int]  # ключ (i,z)\n\n    # тоннаж на рейс\n    m_tons: Dict[Tuple[int, int], float]  # ключ (i,j)\n\n    # верхняя граница числа рейсов для каждого самосвала\n    Kmax_by_truck: Optional[Dict[int, int]] = None\n\n    # Удобные множества ID\n    @property\n    def truck_ids(self) -> List[int]:\n        return sorted({i for (i, _) in self.T_load.keys()})\n\n    @property\n    def shovel_ids(self) -> List[int]:\n        return sorted({j for (_, j) in self.T_load.keys()})\n\n    @property\n    def unload_ids(self) -> List[int]:\n        return sorted({z for (_, z) in self.T_unload.keys()})",
      "imports": [],
      "calls": [
        "sorted",
        "keys"
      ]
    },
    {
      "id": "class:Planner@app/sim_engine/core/planner/manage.py",
      "name": "Planner",
      "type": "class",
      "layer": "Планировщик",
      "file_path": "app/sim_engine/core/planner/manage.py",
      "docstring": "",
      "methods": [
        "__init__",
        "_init_solver",
        "get_planning_data",
        "run_with_exclude",
        "run"
      ],
      "source_code": "class Planner:\n    SOLVERS = {\n        \"CBC\": MILPSolver,\n        \"HIGHS\": MILPSolver,\n        \"CP\": CPSolver\n    }\n\n    def __init__(\n            self,\n            solver: str = None,\n            msg: bool = False,\n            workers: int = 4,\n            time_limit: int = 60\n    ):\n        self.msg = msg\n        self.workers = workers\n        self.time_limit = time_limit\n        self.solver = solver\n\n    def _init_solver(self):\n        if self.solver:\n            solver = self.SOLVERS[self.solver]\n        else:\n            solver = self.SOLVERS[\"CP\"]\n\n        if self.solver == \"HIGHS\":\n            solver.solver_type = \"HIGHS\"\n        elif self.solver == \"CBC\":\n            solver.solver_type = \"CBC\"\n\n        solver.time_limit = self.time_limit\n        solver.msg_out = self.msg\n        solver.workers = self.workers\n\n        return solver\n\n    @staticmethod\n    def get_planning_data(simdata: SimData) -> InputPlanningData:\n        \"\"\"\n        Метод набивающий матрицу данных\n        \"\"\"\n        truck_count = len(simdata.trucks)\n        shovel_count = len(simdata.shovels)\n        unl_count = len(simdata.unloads)\n        shift_change_area = simdata.idle_areas.shift_change_areas[0]\n\n        planning_data = InputPlanningData(\n            N=truck_count,\n            M=shovel_count,\n            Z=unl_count,\n            D_work=int(simdata.duration / 60),\n\n            T_haul=dict(),\n            T_return=dict(),\n            T_load=dict(),\n            T_unload=dict(),\n            T_start=dict(),\n            T_end=dict(),\n            m_tons=dict(),\n\n            Kmax_by_truck=None\n        )\n\n        # Идем по самосвалам\n        for truck in simdata.trucks.values():\n\n            # Идем по экскаваторам\n            for shovel in simdata.shovels.values():\n                time_load, weight, _ = ShovelCalc.calculate_load_cycles(shovel.properties, truck.properties)\n\n                planning_data.T_load[\n                    truck.id,\n                    shovel.id\n                ] = int(time_load / 60)\n\n                if truck.initial_edge_id and truck.initial_lat and truck.initial_lon:\n                    start_route = build_route_edges_by_road_net_from_position(\n                        lon=truck.initial_lon,\n                        lat=truck.initial_lat,\n                        edge_idx=truck.initial_edge_id,\n                        height=None,\n                        to_object_id=shovel.id,\n                        to_object_type=ObjectType.SHOVEL,\n                        road_net=simdata.road_net,\n                    )\n\n                else:\n                    start_route = build_route_edges_by_road_net(\n                        from_object_id=shift_change_area.id,\n                        from_object_type=ObjectType.IDLE_AREA,\n                        to_object_id=shovel.id,\n                        to_object_type=ObjectType.SHOVEL,\n                        road_net=simdata.road_net\n                    )\n\n                planning_data.T_start[\n                    truck.id,\n                    shovel.id\n                ] = int(TruckCalc.calculate_time_motion_by_edges(\n                    start_route,\n                    truck.properties,\n                    forward=True\n                ) / 60)\n\n                planning_data.m_tons[\n                    truck.id,\n                    shovel.id\n                ] = int(weight)\n\n                # Идем по пунктам разгрузки\n                for unload in simdata.unloads.values():\n                    route = build_route_edges_by_road_net(\n                        from_object_id=shovel.id,\n                        from_object_type=ObjectType.SHOVEL,\n                        to_object_id=unload.id,\n                        to_object_type=ObjectType.UNLOAD,\n                        road_net=simdata.road_net\n                    )\n                    planning_data.T_haul[\n                        truck.id,\n                        shovel.id,\n                        unload.id\n                    ] = int(TruckCalc.calculate_time_motion_by_edges(\n                        route,\n                        truck.properties,\n                        forward=True\n                    ) / 60)\n\n                    planning_data.T_return[\n                        truck.id,\n                        unload.id,\n                        shovel.id\n                    ] = int(TruckCalc.calculate_time_motion_by_edges(\n                        route,\n                        truck.properties,\n                        forward=False\n                    ) / 60)\n\n            # Идем по пунктам разгрузки\n            for unload in simdata.unloads.values():\n                planning_data.T_unload[\n                    truck.id,\n                    unload.id\n                ] = int(UnloadCalc.unload_calculation_by_norm(unload.properties, truck.properties)[\"t_total\"] / 60)\n\n                end_route = build_route_edges_by_road_net(\n                    from_object_id=unload.id,\n                    from_object_type=ObjectType.UNLOAD,\n                    to_object_id=shift_change_area.id,\n                    to_object_type=ObjectType.IDLE_AREA,\n                    road_net=simdata.road_net\n                )\n\n                planning_data.T_end[\n                    truck.id,\n                    unload.id\n                ] = int(TruckCalc.calculate_time_motion_by_edges(\n                    end_route,\n                    truck.properties,\n                    forward=True\n                ) / 60)\n\n        return planning_data\n\n    def run_with_exclude(\n            self,\n            sim_data: SimData,\n            exclude_objects: dict[str, list[int]],\n    ) -> dict:\n\n        if self.msg:\n            logger.info(f\"Planner run_with_exclude!\")\n\n        sim_data.duration = int((sim_data.end_time - sim_data.start_time).total_seconds())\n\n        exclude_trucks = exclude_objects[\"trucks\"]\n        exclude_shovels = exclude_objects[\"shovels\"]\n        exclude_unloads = exclude_objects[\"unloads\"]\n\n        for truck_id in exclude_trucks:\n            sim_data.trucks.pop(truck_id, None)\n\n        for shovel_id in exclude_shovels:\n            sim_data.shovels.pop(shovel_id, None)\n\n        for unload_id in exclude_unloads:\n            sim_data.unloads.pop(unload_id, None)\n\n        if not sim_data.shovels or not sim_data.unloads or not sim_data.trucks:\n            return {}\n\n        result = self.run(simdata=sim_data)\n        planned_trips = defaultdict(list)\n\n        for trip in result[\"trips\"]:\n            planned_trip = PlannedTrip(\n                truck_id=trip[\"truck_id\"],\n                shovel_id=trip[\"shovel_id\"],\n                unload_id=trip[\"unload_id\"],\n                order=trip[\"order\"]\n            )\n            planned_trips[planned_trip.truck_id].append(planned_trip)\n        return planned_trips\n\n    def run(self, simdata: SimData):\n        if self.msg:\n            logger.info(f\"Planner run!\")\n\n        planning_data = self.get_planning_data(simdata)\n\n        if self.msg:\n            logger.info(f\"Planning data: {planning_data}\")\n\n        solver = self._init_solver()\n        result = solver.run(planning_data)\n\n        if self.msg:\n            for trip in result[\"trips\"]:\n                if trip[\"order\"] == 1:\n                    logger.info(\"-------------------------\")\n                logger.info(\n                    f\"Самосвал: {trip[\"truck_id\"]}; Экскаватор: {trip[\"shovel_id\"]}; ПР: {trip[\"unload_id\"]}; Рейс № {trip[\"order\"]}\"\n                )\n        return result",
      "imports": [],
      "calls": [
        "logger",
        "UnloadCalc",
        "unload_calculation_by_norm",
        "TruckCalc",
        "run",
        "self",
        "get_planning_data",
        "calculate_load_cycles",
        "_init_solver",
        "build_route_edges_by_road_net_from_position",
        "calculate_time_motion_by_edges",
        "defaultdict",
        "info",
        "len",
        "append",
        "int",
        "dict",
        "PlannedTrip",
        "build_route_edges_by_road_net",
        "values",
        "total_seconds",
        "solver",
        "ShovelCalc",
        "InputPlanningData",
        "pop"
      ]
    },
    {
      "id": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py",
      "name": "get_planning_data",
      "type": "function",
      "layer": "Планировщик",
      "file_path": "app/sim_engine/core/planner/planning_matrix.py",
      "docstring": "Метод набивающий матрицу данных",
      "source_code": "def get_planning_data(simdata: SimData) -> InputPlanningData:\n    \"\"\"\n    Метод набивающий матрицу данных\n    \"\"\"\n    truck_count = len(simdata.trucks)\n    shovel_count = len(simdata.shovels)\n    unl_count = len(simdata.unloads)\n    shift_change_area = simdata.idle_areas.shift_change_areas[0]\n\n    planning_data = InputPlanningData(\n        N=truck_count,\n        M=shovel_count,\n        Z=unl_count,\n        D_work=int(simdata.duration / 60),\n\n        T_haul=dict(),\n        T_return=dict(),\n        T_load=dict(),\n        T_unload=dict(),\n        T_start=dict(),\n        T_end=dict(),\n        m_tons=dict(),\n\n        Kmax_by_truck=None\n    )\n\n    # Идем по самосвалам\n    for truck in simdata.trucks.values():\n\n        # Идем по экскаваторам\n        for shovel in simdata.shovels.values():\n            time_load, weight, _ = ShovelCalc.calculate_load_cycles(shovel.properties, truck.properties)\n\n            planning_data.T_load[\n                truck.id,\n                shovel.id\n            ] = int(time_load / 60)\n\n            if truck.initial_edge_id and truck.initial_lat and truck.initial_lon:\n                start_route = build_route_edges_by_road_net_from_position(\n                    lon=truck.initial_lon,\n                    lat=truck.initial_lat,\n                    edge_idx=truck.initial_edge_id,\n                    height=None,\n                    to_object_id=shovel.id,\n                    to_object_type=ObjectType.SHOVEL,\n                    road_net=simdata.road_net,\n                )\n\n            else:\n                start_route = build_route_edges_by_road_net(\n                    from_object_id=shift_change_area.id,\n                    from_object_type=ObjectType.IDLE_AREA,\n                    to_object_id=shovel.id,\n                    to_object_type=ObjectType.SHOVEL,\n                    road_net=simdata.road_net\n                )\n\n            planning_data.T_start[\n                truck.id,\n                shovel.id\n            ] = int(TruckCalc.calculate_time_motion_by_edges(\n                start_route,\n                truck.properties,\n                forward=True\n            ) / 60)\n\n            planning_data.m_tons[\n                truck.id,\n                shovel.id\n            ] = int(weight)\n\n            # Идем по пунктам разгрузки\n            for unload in simdata.unloads.values():\n                route = build_route_edges_by_road_net(\n                    from_object_id=shovel.id,\n                    from_object_type=ObjectType.SHOVEL,\n                    to_object_id=unload.id,\n                    to_object_type=ObjectType.UNLOAD,\n                    road_net=simdata.road_net\n                )\n                planning_data.T_haul[\n                    truck.id,\n                    shovel.id,\n                    unload.id\n                ] = int(TruckCalc.calculate_time_motion_by_edges(\n                    route,\n                    truck.properties,\n                    forward=True\n                ) / 60)\n\n                planning_data.T_return[\n                    truck.id,\n                    unload.id,\n                    shovel.id\n                ] = int(TruckCalc.calculate_time_motion_by_edges(\n                    route,\n                    truck.properties,\n                    forward=False\n                ) / 60)\n\n        # Идем по пунктам разгрузки\n        for unload in simdata.unloads.values():\n            planning_data.T_unload[\n                truck.id,\n                unload.id\n            ] = int(UnloadCalc.unload_calculation_by_norm(unload.properties, truck.properties)[\"t_total\"] / 60)\n\n            end_route = build_route_edges_by_road_net(\n                from_object_id=unload.id,\n                from_object_type=ObjectType.UNLOAD,\n                to_object_id=shift_change_area.id,\n                to_object_type=ObjectType.IDLE_AREA,\n                road_net=simdata.road_net\n            )\n\n            planning_data.T_end[\n                truck.id,\n                unload.id\n            ] = int(TruckCalc.calculate_time_motion_by_edges(\n                end_route,\n                truck.properties,\n                forward=True\n            ) / 60)\n\n    return planning_data",
      "imports": [],
      "calls": [
        "TruckCalc",
        "UnloadCalc",
        "values",
        "calculate_time_motion_by_edges",
        "len",
        "calculate_load_cycles",
        "dict",
        "int",
        "InputPlanningData",
        "ShovelCalc",
        "build_route_edges_by_road_net_from_position",
        "unload_calculation_by_norm",
        "build_route_edges_by_road_net"
      ]
    },
    {
      "id": "class:TelemetryEmitter@app/sim_engine/core/simulations/base.py",
      "name": "TelemetryEmitter",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/base.py",
      "docstring": "",
      "methods": [
        "__init__",
        "run"
      ],
      "source_code": "class TelemetryEmitter:\n    def __init__(self, tick, data_callback):\n        env = DR.env()\n        writer = DR.writer()\n\n        self.env = env\n        self.tick = tick\n        self.writer = writer\n        self.data_callback = data_callback\n        self.process = env.process(self.run())\n\n    def run(self):\n        while True:\n            self.writer.writerow(self.data_callback())\n            yield self.env.timeout(self.tick)",
      "imports": [],
      "calls": [
        "data_callback",
        "run",
        "self",
        "DR",
        "env",
        "writer",
        "timeout",
        "writerow",
        "process"
      ]
    },
    {
      "id": "class:SimContext@app/sim_engine/core/simulations/entities.py",
      "name": "SimContext",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/entities.py",
      "docstring": "Контекст(контейнер) содержащий в себе объекты симуляции",
      "methods": [
        "get_truck_by_id",
        "get_shovel_by_id",
        "get_unload_by_id"
      ],
      "source_code": "class SimContext:\n    \"\"\"\n    Контекст(контейнер) содержащий в себе объекты симуляции\n    \"\"\"\n    quarry: Quarry = None\n    trucks: dict[int, Truck] = None\n    shovels: dict[int, Shovel] = None\n    unloads: dict[int, Unload] = None\n\n    # writers: dict[str, Any]\n    # random_seed: int\n\n    def get_truck_by_id(self, truck_id: int):\n        return self.trucks[truck_id]\n\n    def get_shovel_by_id(self, shovel_id: int):\n        return self.shovels[shovel_id]\n\n    def get_unload_by_id(self, unload_id: int):\n        return self.unloads[unload_id]",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:FuelStation@app/sim_engine/core/simulations/fuel_station.py",
      "name": "FuelStation",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/fuel_station.py",
      "docstring": "",
      "methods": [
        "__init__",
        "current_time",
        "refuelling",
        "main_tic_process",
        "push_event",
        "telemetry_process"
      ],
      "source_code": "class FuelStation:\n    def __init__(self, properties: FuelStationProperties, unit_id, name, initial_position, tick=1):\n        env = DR.env()\n\n        self.env = env\n        self.resource = simpy.Resource(env, capacity=properties.num_pumps)\n        self.state = FuelStationState.WAITING\n        self.properties = properties\n        self.id = unit_id\n        self.name = name\n        self.position = initial_position\n        self.writer = DR.writer()\n        self.start_time = env.sim_data.start_time\n        self.tick = tick\n        self.trucks_queue = []\n\n        # Базовый логика процессов каждого тика.\n        self.tick_proc = BaseTickBehavior(self)\n\n    @property\n    def current_time(self):\n        current_time = self.start_time + timedelta(seconds=self.env.now)\n        timestamp = current_time.timestamp()\n        return timestamp\n\n    def refuelling(self, truck):\n        with self.resource.request() as req:\n            self.trucks_queue.append(truck.name)\n            yield req\n            self.push_event(event_type=EventType.REFUELING_BEGIN, truck=truck)\n            fuel_needed = truck.properties.fuel_capacity - truck.fuel\n            refuel_time = fuel_needed / self.properties.flow_rate\n            old_state = copy.copy(truck.state)\n            for _ in range(int(refuel_time)):\n                truck.state = TruckState.REFUELING\n                truck.fuel += self.properties.flow_rate\n                yield self.env.timeout(1)\n            self.push_event(event_type=EventType.REFUELING_END, truck=truck)\n            truck.fuel_empty = False\n            truck.fuel = truck.properties.fuel_capacity\n            truck.state = old_state\n            self.trucks_queue.remove(truck.name)\n\n    def main_tic_process(self):\n        if self.trucks_queue:\n            self.state = FuelStationState.REFUELING\n        else:\n            self.state = FuelStationState.WAITING\n\n    def push_event(self, event_type: EventType, truck):\n        event = FuelStationEvent(\n            event_code=event_type.code(),\n            event_name=event_type.ru(),\n            time=self.current_time,\n            object_id=f\"{self.id}_fuel_station\",\n            object_type=ObjectType.FUEL_STATION,\n            object_name=self.name,\n            truck_id=truck.id,\n            truck_name=truck.name,\n        )\n        self.writer.push_event(event)\n\n    def telemetry_process(self):\n        frame_data = {\n            \"object_id\": f\"{self.id}_fuel_station\",\n            \"object_type\": ObjectType.FUEL_STATION.key(),\n            \"timestamp\": self.current_time,\n            \"refuelling_trucks\": self.trucks_queue[:self.properties.num_pumps],\n            \"trucks_queue\": self.trucks_queue[self.properties.num_pumps:],\n            \"state\": self.state.ru()\n        }\n        self.writer.writerow(frame_data)",
      "imports": [],
      "calls": [
        "current_time",
        "range",
        "env",
        "BaseTickBehavior",
        "timedelta",
        "key",
        "timestamp",
        "copy",
        "request",
        "FuelStationEvent",
        "self",
        "writer",
        "code",
        "timeout",
        "event_type",
        "remove",
        "append",
        "int",
        "ru",
        "DR",
        "Resource",
        "push_event",
        "writerow",
        "simpy"
      ]
    },
    {
      "id": "class:TripStartTimeNotDefinedException@app/sim_engine/core/simulations/quarry.py",
      "name": "TripStartTimeNotDefinedException",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/quarry.py",
      "docstring": "",
      "methods": [],
      "source_code": "class TripStartTimeNotDefinedException(Exception):\n    pass",
      "imports": [],
      "calls": []
    },
    {
      "id": "class:Quarry@app/sim_engine/core/simulations/quarry.py",
      "name": "Quarry",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/quarry.py",
      "docstring": "",
      "methods": [
        "__init__",
        "current_time",
        "current_timestamp",
        "prepare_seeded_random",
        "update_planned_trips",
        "update_trucks_position",
        "rebuild_plan_by_add_exclude",
        "rebuild_plan_by_del_exclude",
        "get_summary",
        "push_event"
      ],
      "source_code": "class Quarry:\n    def __init__(self):\n        env = DR.env()\n\n        self.env = env\n        self.start_time = env.sim_data.start_time\n\n        self.trips_table = []\n\n        self.truck_map: dict = {}\n        self.shovel_map: dict = {}\n        self.unload_map: dict = {}\n        self.shift_change_area: IdleArea = None\n\n        self.writer = DR.writer()\n        self.trip_service = DR.trip_service()\n        self.solver = DR.solver()\n        self.sim_conf = DR.sim_conf()\n\n        # Данные для ребилда плановых рейсов во время симуляции\n        self.sim_data: SimData = None\n        self.planned_trips: dict = None\n        self.exclude_objects: dict = {\n            \"trucks\": [],\n            \"shovels\": [],\n            \"unloads\": []\n        }\n\n        self.seeded_random: random.Random = random._inst\n\n        # механизм учёта взрывных работ\n        self.active_blasting: list[Blasting] = []\n        self.active_blasting_polygons: Tuple[Tuple[Tuple[float, float]]] | list[list[list[float]]] = []\n        self.blasting_proc = QuarryBlastingWatcher(\n            target=self,\n        ) if self.sim_conf[\"blasting\"] else None\n\n    @property\n    def current_time(self) -> datetime:\n        return self.start_time + timedelta(seconds=self.env.now)\n\n    @property\n    def current_timestamp(self):\n        return self.current_time.timestamp()\n\n    def prepare_seeded_random(self) -> None:\n        \"\"\"\n        Generate seed if it doesn't exist in `self.sim_data.seed` and init `random.Random` instance with it\n\n        Needs to be called when we already have `self.sim_data`\n        \"\"\"\n        if self.sim_data.seed is None:\n            self.sim_data.seed = random.getrandbits(128)\n        self.seeded_random = random.Random(self.sim_data.seed)\n\n    def update_planned_trips(self):\n        for truck_id, sim_truck in self.truck_map.items():\n            sim_truck.planned_trips = self.planned_trips.get(truck_id, sim_truck.planned_trips)\n            if sim_truck.state in [\n                TruckState.MOVING_EMPTY,\n                TruckState.WAITING,\n            ]:\n                sim_truck.process.interrupt()\n\n    def update_trucks_position(self, sim_data):\n        for truck_id, sim_truck in self.truck_map.items():\n            truck = sim_data.trucks[truck_id]\n            truck.initial_lat = sim_truck.position.lat\n            truck.initial_lon = sim_truck.position.lon\n            truck.initial_edge_id = sim_truck.edge.index if sim_truck.edge else None\n\n    def rebuild_plan_by_add_exclude(\n            self,\n            start_time: datetime = None,\n            end_time: datetime = None,\n            exclude_object_id: int = None,\n            exclude_object_type: ObjectType = None\n    ) -> None:\n\n        sim_data_copy = deepcopy(self.sim_data)\n        if start_time:\n            sim_data_copy.start_time = start_time\n        if end_time:\n            sim_data_copy.end_time = end_time\n\n        self.update_trucks_position(sim_data_copy)\n\n        if exclude_object_type == ObjectType.TRUCK:\n            self.exclude_objects[\"trucks\"].append(exclude_object_id)\n        elif exclude_object_type == ObjectType.SHOVEL:\n            self.exclude_objects[\"shovels\"].append(exclude_object_id)\n        elif exclude_object_type == ObjectType.UNLOAD:\n            self.exclude_objects[\"unloads\"].append(exclude_object_id)\n\n        planner = Planner(\n            solver=self.sim_conf[\"solver\"],\n            msg=self.sim_conf[\"msg\"],\n            workers=self.sim_conf[\"workers\"],\n            time_limit=self.sim_conf[\"time_limit\"]\n        )\n\n        self.planned_trips = planner.run_with_exclude(sim_data_copy, self.exclude_objects)\n\n        if self.planned_trips:\n            self.update_planned_trips()\n\n    def rebuild_plan_by_del_exclude(\n            self,\n            start_time: datetime = None,\n            end_time: datetime = None,\n            exclude_object_id: int = None,\n            exclude_object_type: ObjectType = None\n    ) -> None:\n\n        sim_data_copy = deepcopy(self.sim_data)\n        if start_time:\n            sim_data_copy.start_time = start_time\n        if end_time:\n            sim_data_copy.end_time = end_time\n\n        self.update_trucks_position(sim_data_copy)\n\n        if exclude_object_type == ObjectType.TRUCK:\n            self.exclude_objects[\"trucks\"].remove(exclude_object_id)\n        elif exclude_object_type == ObjectType.SHOVEL:\n            self.exclude_objects[\"shovels\"].remove(exclude_object_id)\n        elif exclude_object_type == ObjectType.UNLOAD:\n            self.exclude_objects[\"unloads\"].remove(exclude_object_id)\n\n        planner = Planner(\n            solver=self.sim_conf[\"solver\"],\n            msg=self.sim_conf[\"msg\"],\n            workers=self.sim_conf[\"workers\"],\n            time_limit=self.sim_conf[\"time_limit\"]\n        )\n        self.planned_trips = planner.run_with_exclude(sim_data_copy, self.exclude_objects)\n\n        if self.planned_trips:\n            self.update_planned_trips()\n\n    def get_summary(self, end_time: datetime) -> dict:\n        return self.trip_service.get_summary(end_time)\n\n    def push_event(self, event_type: EventType, *args, **kwargs):\n        event = Event(\n            event_code=event_type.code(),\n            event_name=event_type.ru(),\n            time=self.current_timestamp,\n            object_id=ObjectType.QUARRY.key(),\n            object_type=ObjectType.QUARRY,\n            object_name='',\n        )\n\n        if event_type in [EventType.BLASTING_BEGIN, EventType.BLASTING_END]:\n            blasting_id: int = kwargs.get(\"blasting_id\")\n            blasting_start: datetime = kwargs.get(\"blasting_start\")\n            blasting_end: datetime = kwargs.get(\"blasting_end\")\n\n            event = Event(\n                event_code=event_type.code(),\n                event_name=event_type.ru(),\n                time=self.current_timestamp,\n                object_id=f\"{blasting_id}_blasting\",\n                object_type=ObjectType.BLASTING,\n                object_name=f'{blasting_start.strftime(\"%d-%m-%Y %H:%M:%S\")} - {blasting_end.strftime(\"%d-%m-%Y %H:%M:%S\")}',\n            )\n\n            if self.sim_conf[\"mode\"] == \"auto\" and self.sim_conf[\"solver\"] == \"GREEDY\":\n                # Собираем самосвалы для добавления в планирование и исключения из него\n                trucks_to_exclude, trucks_to_include = self.blasting_proc.check_trucks_state()\n                if trucks_to_exclude or trucks_to_include:\n                    self.solver.rebuild_planning_data_cascade(\n                        start_time=self.current_time,\n                        excluded_objects=[(truck_id, ObjectType.TRUCK) for truck_id in trucks_to_exclude],\n                        included_objects=[(truck_id, ObjectType.TRUCK) for truck_id in trucks_to_exclude]\n                    )\n\n        self.writer.push_event(event)",
      "imports": [],
      "calls": [
        "key",
        "timedelta",
        "check_trucks_state",
        "timestamp",
        "planner",
        "kwargs",
        "blasting_start",
        "self",
        "blasting_end",
        "update_planned_trips",
        "writer",
        "sim_conf",
        "run_with_exclude",
        "QuarryBlastingWatcher",
        "trip_service",
        "code",
        "strftime",
        "deepcopy",
        "get_summary",
        "Random",
        "event_type",
        "getrandbits",
        "rebuild_planning_data_cascade",
        "remove",
        "Event",
        "interrupt",
        "append",
        "random",
        "ru",
        "Planner",
        "DR",
        "items",
        "push_event",
        "update_trucks_position",
        "solver",
        "get",
        "env"
      ]
    },
    {
      "id": "class:Shovel@app/sim_engine/core/simulations/shovel.py",
      "name": "Shovel",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/shovel.py",
      "docstring": "",
      "methods": [
        "__init__",
        "current_time",
        "current_timestamp",
        "_load_truck",
        "load_truck",
        "main_tic_process",
        "push_event",
        "telemetry_process"
      ],
      "source_code": "class Shovel:\n    def __init__(\n            self,\n            unit_id,\n            name,\n            position:\n            Point,\n            quarry: Quarry,\n            properties: ShovelProperties,\n            tick=1\n    ):\n        env = DR.env()\n\n        self.env = env\n        self.id = unit_id\n        self.name = name\n        self.position = position\n        self.state = ExcState.WAITING\n        self.writer = DR.writer()\n        self.solver = DR.solver()\n        self.sim_conf = DR.sim_conf()\n        self.quarry = quarry\n        self.resource = simpy.Resource(env, capacity=1)\n        self.properties = properties\n        self.cycles = 0\n        self.start_time = env.sim_data.start_time\n        self.trucks_queue = []\n        self.tick = tick\n\n        # механизм Поломок/Восстановлений\n        self.broken = False\n        self.breakdown = BreakdownBehavior(self, properties) if self.sim_conf[\"breakdown\"] else None\n\n        # механизм отслеживания плановых простоев\n        self.at_planned_idle = False\n        self.planned_idle_proc = PlannedIdleBehavior(\n            target=self,\n            object_type=ObjectType.SHOVEL,\n        ) if self.sim_conf[\"planned_idle\"] and self.quarry.sim_data.planned_idles.get(('shovel', self.id)) else None\n\n        # механизм учёта взрывных работ\n        self.in_blasting_idle = False\n        self.blasting_proc = ShovelBlastingWatcher(\n            target=self,\n        ) if self.sim_conf[\"blasting\"] else None\n\n        # Базовый логика процессов каждого тика.\n        self.tick_proc = BaseTickBehavior(self)\n\n    @property\n    def current_time(self):\n        return self.start_time + timedelta(seconds=self.env.now)\n\n    @property\n    def current_timestamp(self):\n        return self.current_time.timestamp()\n\n    # TODO: старый метод, использовался до планировщика, кандидат на удаление\n    def _load_truck(self, truck):\n        with self.resource.request() as req:\n            self.trucks_queue.append(truck.name)\n            yield req\n            volume = 0\n            weight = 0\n            while True:\n                data = ShovelCalc.calculate_cycle(props=self.properties)\n                load_time = data[\"vsego_s\"]\n\n                for _ in range(int(load_time)):  # Округление снижает точность расчетов!!!\n\n                    while self.broken or truck.broken:\n                        truck.state = TruckState.REPAIR if truck.broken else TruckState.IDLE\n                        yield self.env.timeout(1)\n                    truck.state = TruckState.LOADING\n\n                    yield self.env.timeout(1)\n\n                density = density_by_material[self.properties.tip_porody]\n                cycle_volume = self.properties.obem_kovsha_m3 * self.properties.koef_zapolneniya\n                cycle_weight = cycle_volume * density\n\n                volume += cycle_volume\n                weight += cycle_weight\n\n                truck.weight = weight\n                truck.volume = volume\n\n                next_cycle_weight = weight + cycle_weight\n                over_norm_weight = next_cycle_weight > truck.properties.body_capacity\n\n                if over_norm_weight:\n                    break\n\n            self.trucks_queue.remove(truck.name)\n\n    def load_truck(self, truck):\n        truck.req = self.resource.request()\n        self.trucks_queue.append(truck.name)\n        yield truck.req\n\n        for time, weight, volume in ShovelCalc.calculate_load_cycles_cumulative_generator(\n            self.properties,\n            truck.properties\n        ):\n            while self.broken or truck.broken:\n                truck.state = TruckState.REPAIR if truck.broken else TruckState.IDLE\n                yield self.env.timeout(1)\n            truck.state = TruckState.LOADING\n            yield self.env.timeout(time)\n            truck.weight = weight\n            truck.volume = volume\n\n        self.resource.release(truck.req)\n        self.trucks_queue.remove(truck.name)\n\n    def main_tic_process(self):\n        if self.broken:\n            self.state = ExcState.REPAIR\n        elif self.in_blasting_idle:\n            self.state = ExcState.BLASTING_IDLE\n        elif not self.broken and self.trucks_queue:\n            self.state = ExcState.LOADING\n        elif not self.broken and self.at_planned_idle:\n            self.state = ExcState.PLANNED_IDLE\n        elif not self.broken and not self.trucks_queue:\n            self.state = ExcState.WAITING\n\n    def push_event(self, event_type: EventType, write_event: bool = True):\n        event = Event(\n            event_code=event_type.code(),\n            event_name=event_type.ru(),\n            time=self.current_timestamp,\n            object_id=f\"{self.id}_shovel\",\n            object_type=ObjectType.SHOVEL,\n            object_name=self.name,\n        )\n\n        if self.sim_conf[\"mode\"] == \"auto\":\n            if event_type in [EventType.BREAKDOWN_BEGIN, EventType.PLANNED_IDLE_BEGIN]:\n                if self.sim_conf[\"solver\"] == \"GREEDY\":\n                    self.solver.rebuild_planning_data(\n                        start_time=self.current_time,\n                        excluded_object=(self.id, ObjectType.SHOVEL)\n                    )\n                else:\n                    # TODO: Перевести ребилд MILP и CP солверов на env\n                    self.quarry.rebuild_plan_by_add_exclude(\n                        start_time=self.current_time,\n                        exclude_object_id=self.id,\n                        exclude_object_type=ObjectType.SHOVEL\n                    )\n\n            elif event_type in [EventType.BREAKDOWN_END, EventType.PLANNED_IDLE_END]:\n                if self.sim_conf[\"solver\"] == \"GREEDY\":\n                    self.solver.rebuild_planning_data(\n                        start_time=self.current_time,\n                        included_object=(self.id, ObjectType.SHOVEL)\n                    )\n                else:\n                    # TODO: Перевести ребилд MILP и CP солверов на env\n                    self.quarry.rebuild_plan_by_del_exclude(\n                        start_time=self.current_time,\n                        exclude_object_id=self.id,\n                        exclude_object_type=ObjectType.SHOVEL\n                    )\n\n        if write_event:\n            self.writer.push_event(event)\n\n    def telemetry_process(self):\n        frame_data = {\n            \"object_id\": f\"{self.id}_shovel\",\n            \"object_name\": self.name,\n            \"object_type\": ObjectType.SHOVEL.key(),\n            \"lat\": round(self.position.lat, 6),\n            \"lon\": round(self.position.lon, 6),\n            \"state\": self.state.ru(),\n            \"timestamp\": self.current_timestamp,\n            \"loading_truck\": self.trucks_queue[0] if self.trucks_queue else \"-\",\n            \"trucks_queue\": self.trucks_queue[1:]\n        }\n        self.writer.writerow(frame_data)",
      "imports": [],
      "calls": [
        "range",
        "PlannedIdleBehavior",
        "env",
        "BaseTickBehavior",
        "timedelta",
        "key",
        "rebuild_plan_by_del_exclude",
        "release",
        "timestamp",
        "request",
        "sim_conf",
        "writer",
        "code",
        "timeout",
        "calculate_load_cycles_cumulative_generator",
        "rebuild_planning_data",
        "BreakdownBehavior",
        "calculate_cycle",
        "event_type",
        "remove",
        "Event",
        "append",
        "int",
        "round",
        "rebuild_plan_by_add_exclude",
        "ShovelBlastingWatcher",
        "ru",
        "DR",
        "Resource",
        "push_event",
        "solver",
        "get",
        "ShovelCalc",
        "writerow",
        "simpy"
      ]
    },
    {
      "id": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "name": "Truck",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/truck.py",
      "docstring": "",
      "methods": [
        "__init__",
        "nearest_fuel_station",
        "current_time",
        "current_timestamp",
        "travel_segment",
        "broken_action",
        "refuel_action",
        "lunch_action",
        "planned_idle_action",
        "wait_blasting",
        "blasting_action",
        "move_to_area",
        "moving",
        "set_route",
        "set_start_route",
        "run",
        "push_event",
        "telemetry_process",
        "current_trip_data"
      ],
      "source_code": "class Truck:\n    def __init__(\n            self,\n            unit_id,\n            name,\n            initial_position: Point,\n            route: Route | None,\n            route_edge: RouteEdge | None,\n            start_route: RouteEdge | None,\n            planned_trips: list[PlannedTrip],\n            quarry: Quarry,\n            shovel: Shovel | None,\n            unload: Unload | None,\n            properties: TruckProperties,\n            fuel_stations: list[FuelStation],\n            tick=1\n    ):\n\n        env = DR.env()\n        self.writer = DR.writer()\n        self.trip_service = DR.trip_service()\n        self.idle_area_service = DR.idle_area_service()\n        self.solver = DR.solver()\n        self.sim_conf = DR.sim_conf()\n\n        self.env = env\n        self.id = unit_id\n        self.name = name\n        self.route = route\n        self.route_edge = route_edge\n        self.start_route = start_route\n\n        # Текущий актуальный маршрут\n        self.active_route_edge = None\n\n        self.planned_trips = planned_trips\n        self.quarry = quarry\n        self.shovel = shovel\n        self.unload = unload\n\n        self.position = initial_position\n        self.speed = 0\n        self.edge = None\n\n        self.weight = 0\n        self.volume = 0\n        self.fuel = properties.fuel_level\n        self.fuel_stations = fuel_stations\n\n        self.state = TruckState.IDLE\n        self.target_speed = 30\n        self.cycles_done = 0\n        self.max_cycles = 3\n        self.properties = properties\n        self.start_time = env.sim_data.start_time\n        self.process = env.process(self.run())\n        self.calculator = TruckCalc\n        self.tick = tick\n\n        # Переменная для управления очередью на погрузке, разгрузке\n        self.req = None\n\n        # механизм Поломок/Восстановлений\n        self.broken = False\n        self.breakdown_proc = BreakdownBehavior(self, properties) if self.sim_conf[\"breakdown\"] else None\n\n        # механизм отслеживания топлива\n        self.fuel_empty = False\n        self.fuel_proc = FuelBehavior(self, properties) if self.sim_conf[\"refuel\"] and self.fuel_stations else None\n\n        # механизм отслеживания Обеденных перерывов\n        self.at_lunch = False\n        self.lunch_proc = LunchBehavior(\n            target=self\n        ) if self.sim_conf[\"lunch\"] and self.quarry.sim_data.lunch_times else None\n\n        # механизм отслеживания плановых простоев\n        self.at_planned_idle = False\n        self.planned_idle_proc = PlannedIdleBehavior(\n            target=self,\n            object_type=ObjectType.TRUCK,\n        ) if self.sim_conf[\"planned_idle\"] and self.quarry.sim_data.planned_idles.get(\n            (ObjectType.TRUCK.key(), self.id)\n        ) else None\n\n        self.blasting_proc = TruckBlastingWatcher(\n            target=self\n        ) if self.sim_conf[\"blasting\"] else None\n\n        # Базовый логика процессов каждого тика.\n        self.tick_proc = BaseTickBehavior(self)\n\n    @property\n    def nearest_fuel_station(self) -> FuelStation:\n        if len(self.fuel_stations) > 2:\n            nearest_fs = min(self.fuel_stations, key=lambda fs: haversine_km(self.position, fs.position))\n        else:\n            nearest_fs = self.fuel_stations[0]\n        return nearest_fs\n\n    @property\n    def current_time(self):\n        return self.start_time + timedelta(seconds=self.env.now)\n\n    @property\n    def current_timestamp(self):\n        return self.current_time.timestamp()\n\n    def travel_segment(self, p1: Point, p2: Point, speed_limit, acceleration):\n        for speed, position in self.calculator.calculate_segment_motion(p1, p2, self.speed, speed_limit, acceleration):\n            yield self.env.timeout(1)\n            self.speed = speed\n            self.position = position\n\n    def broken_action(self):\n        # логика поломок\n        while self.broken:\n            self.state = TruckState.REPAIR\n            yield self.env.timeout(1)\n\n    def refuel_action(self):\n        \"\"\"Логика заправок\"\"\"\n        while self.fuel_empty:\n            route_to_refuel = build_route_edges_by_road_net_from_position(\n                lon=self.position.lon,\n                lat=self.position.lat,\n                height=None,\n                edge_idx=self.edge.index,\n                to_object_id=self.nearest_fuel_station.id,\n                to_object_type=ObjectType.FUEL_STATION,\n                road_net=self.quarry.sim_data.road_net\n            )\n            yield from self.moving(route_to_refuel, forward=True, actions=[self.broken_action, self.blasting_action])\n            yield self.env.process(self.nearest_fuel_station.refuelling(self))\n\n    def lunch_action(self):\n        \"\"\" Логика обеденных перерывов \"\"\"\n        if self.at_lunch:\n            self.state = TruckState.LUNCH\n\n            for _ in self.move_to_area(IdleAreaType.LUNCH, actions=[self.broken_action]):\n                yield _\n\n                if not self.at_lunch:\n                    # если обед кончился, а мы до него так и не доехали, больше не едем на обед\n                    break\n\n            # пережидаем обед\n            while self.at_lunch:\n                self.state = TruckState.LUNCH\n                yield self.env.timeout(1)\n\n    def planned_idle_action(self):\n        \"\"\"Логика плановых простоев\"\"\"\n        if self.at_planned_idle:\n            old_state = self.state\n\n            self.state = TruckState.PLANNED_IDLE\n\n            for _ in self.move_to_area(IdleAreaType.PLANNED_IDLE, actions=[self.broken_action]):\n                yield _\n\n                if not self.at_planned_idle:\n                    # если простой кончился, а мы до него так и не доехали, больше не едем туда\n                    break\n\n            # пережидаем плановый простой\n            while self.at_planned_idle:\n                self.state = TruckState.PLANNED_IDLE\n                yield self.env.timeout(1)\n\n            self.state = old_state\n\n    def wait_blasting(self, current_zones: Set[int]):\n        \"\"\"Логика ожидания изменений во взрывных работах\"\"\"\n        while self.quarry.active_blasting and current_zones == {blasting.id for blasting in self.quarry.active_blasting}:\n            self.state = TruckState.BLASTING_IDLE\n            yield self.env.timeout(1)\n\n    def blasting_action(self):\n        \"\"\"Логика поведения при активных взрывных работах\"\"\"\n        if self.quarry.active_blasting:\n            # Проверка на попадание маршрута в области взрывных работ\n            if path_intersects_polygons(self.active_route_edge, self.quarry.active_blasting_polygons):\n                # Сборка всех возможных маршрутов между пунктом отправления и пункт назнчения\n                chosen_path = find_route_edges_around_restricted_zones_from_base_route(\n                    base_route=self.active_route_edge,\n                    restricted_zones=self.quarry.active_blasting_polygons,\n                    road_net=self.quarry.sim_data.road_net,\n                )\n\n                # Если смогли найти маршрут в объезд зоны\n                if chosen_path:\n                    # TODO: Надо проложить путь до ближайшей точки на пути, и потом уже двигаться от неё\n                    #  Пока что едем до точки начала маршрута, а потом уже едем по маршруту\n\n                    # Если наше текущее положение не совпадает с началом построенного маршрута\n                    if (self.position.lon, self.position.lat) != (chosen_path.start_point.lon,\n                                                                  chosen_path.start_point.lat):\n                        route_moving_to = build_route_edges_by_road_net_from_position_to_position(\n                            lon=self.position.lon,\n                            lat=self.position.lat,\n                            height=0,\n                            edge_idx=self.edge.index,\n                            end_lon=chosen_path.start_point.x,\n                            end_lat=chosen_path.start_point.y,\n                            end_height=0,\n                            end_edge_idx=chosen_path.edges[0].index,\n                            road_net=self.quarry.sim_data.road_net\n                        )\n                        # проследуем к началу этого маршрута\n                        yield from self.moving(route_moving_to, forward=True, actions=[self.broken_action])\n                    # проедем основной маршрут\n                    yield from self.moving(chosen_path, forward=True, actions=[self.broken_action])\n                else:\n                    old_state = self.state\n                    self.state = TruckState.BLASTING_IDLE\n\n                    # запоминаем активные зоны\n                    remember_zones = {blasting.id for blasting in self.quarry.active_blasting}\n\n                    # Едем в зону ожидания\n                    for _ in self.move_to_area(IdleAreaType.BLAST_WAITING, actions=[self.broken_action]):\n                        yield _\n                        if remember_zones != {blasting.id for blasting in self.quarry.active_blasting}:\n                            break\n\n                    # Если за время движения в зону ожидания список взрывных работ не изменился, то стоим и ждём\n                    yield from self.wait_blasting(remember_zones)\n                    self.state = old_state\n\n    def move_to_area(\n            self,\n            area_type: IdleAreaType,\n            actions: Optional[List[Callable]] = None\n    ):\n        \"\"\"Логика поиска ближайшей площадки выбранного типа и следование на эту площадку\"\"\"\n        if not self.idle_area_service.get_areas(area_type=area_type):\n            # зон указанного типа не существует, никуда не двигаемся\n            return\n\n        while True:\n            # 1. Ищем ближайшую зону подходящего типа\n            area, route = self.idle_area_service.find_nearest(\n                area_type=area_type,\n                lon=self.position.lon,\n                lat=self.position.lat,\n                edge_idx=self.edge.index,\n                restricted_zones=self.quarry.active_blasting_polygons,\n                road_net=self.quarry.sim_data.road_net,\n            )\n\n            # 2. Если нашли зону подходящего типа, отправляем двигаться по маршруту\n            if area and route:\n                for _ in self.moving(route, forward=True, actions=actions):\n                    # даём возможность прекратить этот метод там, где он вызывался\n                    yield _\n\n                    if path_intersects_polygons(route, self.quarry.active_blasting_polygons):\n                        break\n\n            # 3. Если подходящая зона не нашлась\n            elif not area or not route:\n                # Ищем зону ожидания взрыва и едем туда ждать\n                blast_waiting_area, route = self.idle_area_service.find_nearest(\n                    area_type=IdleAreaType.BLAST_WAITING,\n                    lon=self.position.lon,\n                    lat=self.position.lat,\n                    edge_idx=self.edge.index,\n                    restricted_zones=self.quarry.active_blasting_polygons,\n                    road_net=self.quarry.sim_data.road_net,\n                )\n\n                # запоминаем активные зоны взрывов\n                remember_blasting_zones = {blasting.id for blasting in self.quarry.active_blasting}\n\n                if blast_waiting_area and route:\n                    for _ in self.moving(route, forward=True, actions=[self.broken_action]):\n                        # даём возможность прервать метод там, где он вызывался\n                        yield _\n\n                        area, route = self.idle_area_service.find_nearest(\n                            area_type=area_type,\n                            lon=self.position.lon,\n                            lat=self.position.lat,\n                            edge_idx=self.edge.index,\n                            restricted_zones=self.quarry.active_blasting_polygons,\n                            road_net=self.quarry.sim_data.road_net,\n                        )\n                        if area and route:\n                            break\n\n                # Доехали, ждём взрывы\n                for _ in self.wait_blasting(remember_blasting_zones):\n                    yield _\n\n            # 4. если доехали до нужной зоны\n            if area and (area.initial_lon, area.initial_lat) == (self.position.lon, self.position.lat):\n                return\n\n    def moving(self, route: RouteEdge, forward: bool, actions: Optional[List[Callable]] = None):\n        \"\"\"\n            Метод, производящий перемещение самосвала по заданному маршруту с возможностью отклонения от маршрута при необходимости\n        \"\"\"\n        if actions is None:\n            actions = []\n\n        # Определяем текущий маршрут движения\n        self.active_route_edge = route\n\n        # запоминаем, куда изначально хотели двигаться\n        destination_point = route.end_point if forward else route.start_point\n        # Определяем гружёность самосвала\n        is_loaded = self.state == TruckState.MOVING_LOADED\n\n        # Выполняем, пока не достигнем задуманного пункта назначения\n        destination_reached = False\n        while not destination_reached:\n            position_changed = False\n\n            # Ведём самосвал по текущему маршруту\n            for speed, position, edge in self.calculator.calculate_motion_by_edges(\n                    self.active_route_edge,\n                    self.properties,\n                    forward=forward,\n                    is_loaded=is_loaded):\n\n                # Action'ы могут влиять на местоположение самосвала, поэтому запоминаем позицию\n                position_before = (self.position.lon, self.position.lat)\n                for action in actions:\n                    yield from action()\n                if position_before != (self.position.lon, self.position.lat):\n                    # если по итогам отработки action'ов позиция самосвала изменилась,\n                    # то нет смысла больше отслеживать текущее перемещение\n                    position_changed = True\n                    break\n\n                yield self.env.timeout(1)\n                self.speed = speed\n                self.position = position\n                self.edge = edge\n\n            if position_changed:\n                # Позиция поменялась, поэтому нужно построить новый маршрут от текущей позиции,\n                # если текущая позиция не совпадает с изначальным пунктом назначения\n                if (self.position.lon, self.position.lat) != (destination_point.x, destination_point.y):\n                    self.active_route_edge = build_route_edges_by_road_net_from_position_to_position(\n                        lon=self.position.lon,\n                        lat=self.position.lat,\n                        height=0,\n                        edge_idx=self.edge.index,\n                        end_lon=destination_point.lon,\n                        end_lat=destination_point.lat,\n                        end_height=0,\n                        end_edge_idx=None,\n                        road_net=self.quarry.sim_data.road_net\n                    )\n                    forward = True\n                else:\n                    # Мы достигли задуманного пункта назначения\n                    destination_reached = True\n            else:\n                # если ничего не заставило изменить наш маршрут в процессе движения, значит мы достигли пункта назначения\n                destination_reached = True\n\n    def set_route(self) -> None:\n        plan_trip = self.planned_trips.pop(0)\n        self.shovel = self.quarry.shovel_map[plan_trip.shovel_id]\n        self.unload = self.quarry.unload_map[plan_trip.unload_id]\n        self.route_edge = build_route_edges_by_road_net(\n            from_object_id=plan_trip.shovel_id,\n            from_object_type=ObjectType.SHOVEL,\n            to_object_id=plan_trip.unload_id,\n            to_object_type=ObjectType.UNLOAD,\n            road_net=self.quarry.sim_data.road_net\n        )\n\n    def set_start_route(self) -> None:\n        if self.edge:\n            self.start_route = build_route_edges_by_road_net_from_position(\n                lon=self.position.lon,\n                lat=self.position.lat,\n                height=None,\n                edge_idx=self.edge.index,\n                to_object_id=self.shovel.id,\n                to_object_type=ObjectType.SHOVEL,\n                road_net=self.quarry.sim_data.road_net\n            )\n        else:\n            self.start_route = build_route_edges_by_road_net(\n                from_object_id=self.quarry.shift_change_area.id,\n                from_object_type=ObjectType.IDLE_AREA,\n                to_object_id=self.shovel.id,\n                to_object_type=ObjectType.SHOVEL,\n                road_net=self.quarry.sim_data.road_net\n            )\n            self.edge = self.start_route.edges[0]\n\n    def run(self):\n        default_actions = [\n            self.broken_action,\n            self.refuel_action,\n            self.planned_idle_action,\n            self.lunch_action,\n            self.blasting_action,\n        ]\n\n        self.trip_service.set_shift_change_area(self.quarry.shift_change_area)\n\n        while True:\n            try:\n                if not self.planned_trips and self.sim_conf[\"solver\"] == \"GREEDY\" and self.sim_conf[\"mode\"] == \"auto\":\n                    trip = self.solver.assign_trip(self, self.env.now)\n                    if trip:\n                        self.planned_trips.append(trip)\n\n                self.state = TruckState.MOVING_EMPTY\n                self.trip_service.begin(self.current_trip_data())\n\n                if self.planned_trips:\n                    # Успешно произошло распределение и есть в плане рейс, строим новый маршрут\n                    self.set_route()\n                    self.set_start_route()\n                    yield from self.moving(self.start_route, forward=True, actions=default_actions)\n\n                elif not self.start_route:\n                    # Распределение не произошло, но цикл прервался, нужно вывести на предыдущий маршрут\n                    self.set_start_route()\n                    yield from self.moving(self.start_route, forward=True, actions=default_actions)\n\n                else:\n                    # Просто продолжаем двигатся по предыдущему маршруту, без изменений\n                    yield from self.moving(self.route_edge, forward=False, actions=default_actions)\n\n                self.state = TruckState.WAITING\n                self.speed = 0\n                self.weight = 0\n                self.volume = 0\n                yield self.env.process(self.shovel.load_truck(self))\n\n                self.state = TruckState.MOVING_LOADED\n                self.speed = 0\n                yield from self.moving(self.route_edge, forward=True, actions=default_actions)\n\n                self.state = TruckState.UNLOADING\n                self.speed = 0\n                yield self.env.process(self.unload.unload_truck(self))\n\n                self.trip_service.finish(self.current_trip_data())\n\n                if self.planned_trips:\n                    self.set_route()\n\n                self.weight = 0\n                self.volume = 0\n                self.speed = 0\n                self.state = TruckState.IDLE\n                self.cycles_done += 1\n\n                yield self.env.timeout(5)\n\n            except simpy.Interrupt as e:\n\n                # Сбрасываем начало маршрута, так как его потребуется перестроить\n                self.start_route = None\n\n                if self.req and self.req in self.shovel.resource.queue:\n                    self.req.cancel()\n                    self.shovel.trucks_queue.remove(self.name)\n                if len(self.planned_trips) > 0:\n                    self.set_route()\n                    self.set_start_route()\n\n    def push_event(self, event_type: EventType, write_event: bool = True) -> None:\n        if write_event:\n            event = Event(\n                event_code=event_type.code(),\n                event_name=event_type.ru(),\n                time=self.current_timestamp,\n                object_id=f\"{self.id}_truck\",\n                object_type=ObjectType.TRUCK,\n                object_name=self.name,\n            )\n            self.writer.push_event(event)\n\n        if self.sim_conf[\"mode\"] == \"auto\":\n            if event_type in [EventType.BREAKDOWN_BEGIN, EventType.REFUELING_BEGIN, EventType.LUNCH_BEGIN,\n                              EventType.PLANNED_IDLE_BEGIN]:\n                if self.sim_conf[\"solver\"] == \"GREEDY\":\n                    self.solver.rebuild_planning_data(\n                        start_time=self.current_time,\n                        excluded_object=(self.id, ObjectType.TRUCK)\n                    )\n                else:\n                    # TODO: Перевести ребилд MILP и CP солверов на env\n                    self.quarry.rebuild_plan_by_add_exclude(\n                        start_time=self.current_time,\n                        exclude_object_id=self.id,\n                        exclude_object_type=ObjectType.TRUCK\n                    )\n\n            elif event_type in [EventType.BREAKDOWN_END, EventType.REFUELING_END, EventType.LUNCH_END,\n                                EventType.PLANNED_IDLE_END]:\n                if self.sim_conf[\"solver\"] == \"GREEDY\":\n                    self.solver.rebuild_planning_data(\n                        start_time=self.current_time,\n                        included_object=(self.id, ObjectType.TRUCK)\n                    )\n                else:\n                    # TODO: Перевести ребилд MILP и CP солверов на env\n                    self.quarry.rebuild_plan_by_del_exclude(\n                        start_time=self.current_time,\n                        exclude_object_id=self.id,\n                        exclude_object_type=ObjectType.TRUCK\n                    )\n\n    def telemetry_process(self):\n        frame_data = {\n            \"object_id\": f\"{self.id}_truck\",\n            \"object_name\": self.name,\n            \"object_type\": ObjectType.TRUCK.key(),\n            \"lat\": round(self.position.lat, 6),\n            \"lon\": round(self.position.lon, 6),\n            \"speed\": round(self.speed, 1),\n            \"weight\": round(self.weight, 1),\n            \"fuel\": self.fuel,\n            \"state\": self.state.ru(),\n            \"timestamp\": self.current_timestamp\n        }\n\n        self.writer.writerow(frame_data)\n\n    def current_trip_data(self) -> TripData:\n        shovel_id = self.shovel.id if self.shovel else None\n        unload_id = self.unload.id if self.unload else None\n\n        return TripData(\n            truck_id=self.id,\n            shovel_id=shovel_id,\n            unload_id=unload_id,\n            truck_weight=self.weight,\n            truck_volume=self.volume,\n        )",
      "imports": [],
      "calls": [
        "PlannedIdleBehavior",
        "calculate_segment_motion",
        "env",
        "BaseTickBehavior",
        "timedelta",
        "key",
        "finish",
        "rebuild_plan_by_del_exclude",
        "timestamp",
        "refuelling",
        "set_shift_change_area",
        "set_route",
        "TruckBlastingWatcher",
        "begin",
        "run",
        "self",
        "moving",
        "LunchBehavior",
        "writer",
        "sim_conf",
        "pop",
        "trip_service",
        "min",
        "code",
        "timeout",
        "rebuild_planning_data",
        "cancel",
        "build_route_edges_by_road_net_from_position",
        "process",
        "BreakdownBehavior",
        "find_nearest",
        "wait_blasting",
        "load_truck",
        "current_trip_data",
        "event_type",
        "move_to_area",
        "len",
        "remove",
        "Event",
        "append",
        "calculate_motion_by_edges",
        "round",
        "unload_truck",
        "rebuild_plan_by_add_exclude",
        "assign_trip",
        "get_areas",
        "action",
        "build_route_edges_by_road_net",
        "ru",
        "find_route_edges_around_restricted_zones_from_base_route",
        "haversine_km",
        "DR",
        "set_start_route",
        "path_intersects_polygons",
        "push_event",
        "build_route_edges_by_road_net_from_position_to_position",
        "solver",
        "get",
        "idle_area_service",
        "writerow",
        "FuelBehavior",
        "TripData"
      ]
    },
    {
      "id": "class:Unload@app/sim_engine/core/simulations/unload.py",
      "name": "Unload",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/unload.py",
      "docstring": "",
      "methods": [
        "__init__",
        "current_time",
        "current_timestamp",
        "unload_truck",
        "push_event",
        "main_tic_process",
        "telemetry_process"
      ],
      "source_code": "class Unload:\n    def __init__(\n            self,\n            properties,\n            unit_id,\n            name,\n            quarry: Quarry,\n            tick=1\n    ):\n        env = DR.env()\n\n        self.env = env\n        self.resource = simpy.Resource(env, capacity=properties.trucks_at_once)\n        self.state = UnloadState.OPEN\n        self.properties = properties\n        self.id = unit_id\n        self.name = name\n        self.writer = DR.writer()\n        self.solver = DR.solver()\n        self.sim_conf = DR.sim_conf()\n        self.quarry = quarry\n        self.start_time = env.sim_data.start_time\n        self.tick = tick\n        self.trucks_queue = []\n\n        # механизм Поломок/Восстановлений\n        self.broken = False\n        self.breakdown_proc = BreakdownBehavior(self, properties) if self.sim_conf[\"breakdown\"] else None\n\n        # механизм учёта взрывных работ\n        self.in_blasting_idle = False\n        self.blasting_proc = UnloadBlastingWatcher(\n            self,\n        ) if self.sim_conf[\"blasting\"] else None\n\n        # Базовый логика процессов каждого тика.\n        self.tick_proc = BaseTickBehavior(self)\n\n    @property\n    def current_time(self):\n        return self.start_time + timedelta(seconds=self.env.now)\n\n    @property\n    def current_timestamp(self):\n        return self.current_time.timestamp()\n\n    def unload_truck(self, truck):\n        with self.resource.request() as req:\n            self.trucks_queue.append(truck.name)\n            yield req\n            data = UnloadCalc.unload_calculation(props=self.properties, truck_volume=truck.volume)\n            time_unload = data[\"t_total\"]\n            for _ in range(int(time_unload)):\n\n                while self.broken or truck.broken:\n                    truck.state = TruckState.REPAIR if truck.broken else TruckState.IDLE\n                    yield self.env.timeout(1)\n                truck.state = TruckState.UNLOADING\n\n                yield self.env.timeout(1)\n            self.trucks_queue.remove(truck.name)\n\n    def push_event(self, event_type: EventType, write_event: bool = True):\n        event = Event(\n            event_code=event_type.code(),\n            event_name=event_type.ru(),\n            time=self.current_timestamp,\n            object_id=f\"{self.id}_unload\",\n            object_type=ObjectType.UNLOAD,\n            object_name=self.name,\n        )\n        if self.sim_conf[\"mode\"] == \"auto\":\n            if event_type in (EventType.BREAKDOWN_BEGIN, EventType.REFUELING_BEGIN):\n                if self.sim_conf[\"solver\"] == \"GREEDY\":\n                    self.solver.rebuild_planning_data(\n                        start_time=self.current_time,\n                        excluded_object=(self.id, ObjectType.UNLOAD)\n                    )\n                else:\n                    # TODO: Перевести ребилд MILP и CP солверов на env\n                    self.quarry.rebuild_plan_by_add_exclude(\n                        start_time=self.current_time,\n                        exclude_object_id=self.id,\n                        exclude_object_type=ObjectType.UNLOAD\n                    )\n            elif event_type in (EventType.BREAKDOWN_BEGIN, EventType.REFUELING_BEGIN):\n                if self.sim_conf[\"solver\"] == \"GREEDY\":\n                    self.solver.rebuild_planning_data(\n                        start_time=self.current_time,\n                        included_object=(self.id, ObjectType.UNLOAD)\n                    )\n                else:\n                    # TODO: Перевести ребилд MILP и CP солверов на env\n                    self.quarry.rebuild_plan_by_del_exclude(\n                        start_time=self.current_time,\n                        exclude_object_id=self.id,\n                        exclude_object_type=ObjectType.UNLOAD\n                    )\n\n        if write_event:\n            self.writer.push_event(event)\n\n    def main_tic_process(self):\n        if self.broken:\n            self.state = UnloadState.REPAIR\n        elif self.in_blasting_idle:\n            self.state = UnloadState.BLASTING_IDLE\n        else:\n            self.state = UnloadState.OPEN\n\n    def telemetry_process(self):\n        frame_data = {\n            \"object_id\": f\"{self.id}_unload\",\n            \"object_type\": ObjectType.UNLOAD.key(),\n            \"timestamp\": self.current_timestamp,\n            \"unloading_trucks\": self.trucks_queue[:self.properties.trucks_at_once],\n            \"trucks_queue\": self.trucks_queue[self.properties.trucks_at_once:],\n            \"state\": self.state.ru()\n        }\n        self.writer.writerow(frame_data)",
      "imports": [],
      "calls": [
        "range",
        "env",
        "UnloadCalc",
        "BaseTickBehavior",
        "timedelta",
        "key",
        "rebuild_plan_by_del_exclude",
        "timestamp",
        "UnloadBlastingWatcher",
        "request",
        "writer",
        "sim_conf",
        "code",
        "timeout",
        "unload_calculation",
        "rebuild_planning_data",
        "BreakdownBehavior",
        "event_type",
        "remove",
        "Event",
        "append",
        "int",
        "rebuild_plan_by_add_exclude",
        "ru",
        "DR",
        "Resource",
        "push_event",
        "solver",
        "writerow",
        "simpy"
      ]
    },
    {
      "id": "class:BaseBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "name": "BaseBehavior",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/behaviors/base.py",
      "docstring": "Абстрактный базовый класс для всех поведений в симуляции.\nОпределяет общий интерфейс и шаблоны выполнения.",
      "methods": [
        "__init__",
        "run"
      ],
      "source_code": "class BaseBehavior(ABC):\n    \"\"\"\n    Абстрактный базовый класс для всех поведений в симуляции.\n    Определяет общий интерфейс и шаблоны выполнения.\n    \"\"\"\n\n    def __init__(self, target: Any, props: Any = None):\n        env = DR.env()\n        self.env = env\n        self.target = target\n        self.props = props\n        self.process = env.process(self.run())\n\n    def run(self):\n        \"\"\"Основной цикл выполнения поведения\"\"\"\n        yield self.env.timeout(0)",
      "imports": [],
      "calls": [
        "self",
        "run",
        "DR",
        "env",
        "timeout",
        "process"
      ]
    },
    {
      "id": "class:BaseTickBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "name": "BaseTickBehavior",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/behaviors/base.py",
      "docstring": "Класс определяющий базовую последовательность в логике расчетов каждый тик(фрейм)\nЭтапы:\n1. Расчеты для состояния актора. Метод state_process\n2. Упаковка телеметрии. Метод telemetry_process",
      "methods": [
        "__init__",
        "run"
      ],
      "source_code": "class BaseTickBehavior:\n    \"\"\"\n    Класс определяющий базовую последовательность в логике расчетов каждый тик(фрейм)\n    Этапы:\n    1. Расчеты для состояния актора. Метод state_process\n    2. Упаковка телеметрии. Метод telemetry_process\n    \"\"\"\n\n    def __init__(self, target):\n        env = DR.env()\n        self.env = env\n        self.target = target\n        self.process = env.process(self.run())\n\n    def run(self):\n        while True:\n            if hasattr(self.target, \"main_tic_process\"):\n                self.target.main_tic_process()\n            if hasattr(self.target, \"telemetry_process\"):\n                self.target.telemetry_process()\n            yield self.env.timeout(self.target.tick)",
      "imports": [],
      "calls": [
        "self",
        "run",
        "DR",
        "env",
        "telemetry_process",
        "timeout",
        "hasattr",
        "main_tic_process",
        "process"
      ]
    },
    {
      "id": "class:BreakdownBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "name": "BreakdownBehavior",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/behaviors/base.py",
      "docstring": "Класс вычисляющий Поломки/Восстановления",
      "methods": [
        "__init__",
        "run"
      ],
      "source_code": "class BreakdownBehavior(BaseBehavior):\n    \"\"\"\n    Класс вычисляющий Поломки/Восстановления\n    \"\"\"\n\n    def __init__(self, target, props):\n        self.calc = BreakdownCalc(target.quarry.seeded_random)\n        super().__init__(target, props)\n\n    def run(self):\n\n        input_data = {\n            \"initial_operating_time\": self.props.initial_operating_time * 60 * 60,\n            \"average_repair_duration\": self.props.average_repair_duration * 60,\n            \"initial_failure_count\": self.props.initial_failure_count\n        }\n\n        while True:\n            # Вычисляем время поломки, ждем, переходим в поломку\n            time_to_failure = self.calc.calculate_failure_time(**input_data)\n            time_to_failure = int(time_to_failure)\n\n            while time_to_failure != 0:\n                if self.target.state.is_work:\n                    time_to_failure -= 1\n                yield self.env.timeout(1)\n\n            self.target.broken = True\n            self.target.push_event(event_type=EventType.BREAKDOWN_BEGIN)\n            input_data[\"initial_failure_count\"] += 1\n            input_data[\"initial_operating_time\"] += time_to_failure\n\n            # Вычисляем время починки, ждем, переходим в починку\n            time_to_repair = self.calc.calculate_repair_time(**input_data)\n            yield self.env.timeout(time_to_repair)\n            self.target.broken = False\n            self.target.push_event(event_type=EventType.BREAKDOWN_END)",
      "imports": [],
      "calls": [
        "push_event",
        "timeout",
        "super",
        "int",
        "__init__",
        "BreakdownCalc",
        "calculate_repair_time",
        "calculate_failure_time"
      ]
    },
    {
      "id": "class:FuelBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "name": "FuelBehavior",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/behaviors/base.py",
      "docstring": "Класс Управляющий топливом",
      "methods": [
        "__init__",
        "run"
      ],
      "source_code": "class FuelBehavior(BaseBehavior):\n    \"\"\"\n    Класс Управляющий топливом\n    \"\"\"\n\n    def __init__(self, target, props):\n        self.calc = FuelCalc()\n        super().__init__(target, props)\n\n    def run(self):\n\n        while True:\n            if self.target.state.is_moving:\n                self.target.fuel = self.calc.calculate_fuel_level_while_moving(\n                    fuel_lvl=self.target.fuel,\n                    sfc=self.target.properties.fuel_specific_consumption,\n                    density=self.target.properties.fuel_density,\n                    p_engine=self.target.properties.engine_power_kw,\n                )\n            else:\n                self.target.fuel = self.calc.calculate_fuel_level_while_idle(\n                    fuel_lvl=self.target.fuel,\n                    fuel_idle_lph=self.target.properties.fuel_idle_lph\n                )\n\n            if self.target.fuel < self.target.properties.fuel_threshold_planned:\n                self.target.fuel_empty = True\n\n            yield self.env.timeout(1)",
      "imports": [],
      "calls": [
        "calculate_fuel_level_while_idle",
        "FuelCalc",
        "timeout",
        "super",
        "__init__",
        "calculate_fuel_level_while_moving"
      ]
    },
    {
      "id": "class:LunchBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "name": "LunchBehavior",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/behaviors/base.py",
      "docstring": "Класс для техники, управляющий отслеживанием обедов и запуском обеденного простоя",
      "methods": [
        "__init__",
        "run"
      ],
      "source_code": "class LunchBehavior(BaseBehavior):\n    \"\"\" Класс для техники, управляющий отслеживанием обедов и запуском обеденного простоя\"\"\"\n\n    def __init__(self, target):\n        self.calc = LunchCalc()\n        super().__init__(target)\n\n    def run(self):\n        lunch_start_times: List[tuple[int, int]] = self.calc.calculate_lunch_times(\n            sim_start_time=self.target.start_time,\n            lunch_times=self.target.quarry.sim_data.lunch_times\n        )\n\n        while lunch_start_times:\n            # Ждём ближайшего обеда\n            nearest_lunch_start, nearest_lunch_end = lunch_start_times.pop(0)\n            time_to_lunch: int = nearest_lunch_start - self.env.now\n            yield self.env.timeout(time_to_lunch)\n\n            # Обед начался, отслеживаем его до конца\n            while self.env.now < nearest_lunch_end:\n                # если объект в рабочем состоянии - отправляем на обед\n                if self.target.state.is_work and not self.target.at_lunch:\n                    self.target.at_lunch = True\n                    self.target.push_event(event_type=EventType.LUNCH_BEGIN)\n                    lunch_time_remaining: int = nearest_lunch_end - self.env.now\n                    yield self.env.timeout(lunch_time_remaining)\n                else:\n                    # если не в рабочем, просто ждём\n                    yield self.env.timeout(1)\n\n            # Обед закончился\n            if self.target.at_lunch:\n                # Если объект находился в обеде - заканчиваем обед\n                self.target.at_lunch = False\n                self.target.push_event(event_type=EventType.LUNCH_END)",
      "imports": [],
      "calls": [
        "push_event",
        "timeout",
        "lunch_start_times",
        "calculate_lunch_times",
        "__init__",
        "super",
        "LunchCalc",
        "pop"
      ]
    },
    {
      "id": "class:PlannedIdleBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "name": "PlannedIdleBehavior",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/behaviors/base.py",
      "docstring": "Класс для техники, управляющий отслеживанием и запуском запланированных простоев",
      "methods": [
        "__init__",
        "_calculate_idles_times",
        "_should_start_planned_idle",
        "run"
      ],
      "source_code": "class PlannedIdleBehavior(BaseBehavior):\n    \"\"\" Класс для техники, управляющий отслеживанием и запуском запланированных простоев\"\"\"\n\n    def __init__(self, target, object_type: ObjectType):\n        self.object_type = object_type\n        super().__init__(target)\n\n    def _calculate_idles_times(self, target) -> list[tuple[int, int]]:\n        \"\"\"Собирает из данных о плановых простоях список периодов простоев\"\"\"\n\n        # поиск происходит в словаре, где ключи вида ('shovel', 3) - нам нужен строковый ключ\n        key = (self.object_type.key(), target.id)\n\n        idles_times = []\n        for idle in target.quarry.sim_data.planned_idles.get(key, []):\n            start_time = (idle.start_time - target.start_time).total_seconds()\n            end_time = (idle.end_time - target.start_time).total_seconds()\n            idles_times.append(\n                (start_time, end_time)\n            )\n        return idles_times\n\n    def _should_start_planned_idle(self) -> bool:\n        \"\"\"Проверка возможности начать плановый простой\"\"\"\n        if not self.target.at_planned_idle:\n            if self.object_type == ObjectType.TRUCK and self.target.state in [TruckState.MOVING_EMPTY,\n                                                                              TruckState.WAITING]:\n                return True\n            if self.object_type == ObjectType.SHOVEL and self.target.state in [ExcState.WAITING]:\n                return True\n        return False\n\n    def run(self):\n        planned_idles: list[tuple[int, int]] = self._calculate_idles_times(self.target)\n\n        while planned_idles:\n            nearest_idle_start, nearest_idle_end = planned_idles.pop(0)\n\n            wait_time = nearest_idle_start - self.env.now\n            yield self.env.timeout(wait_time)\n\n            while self.env.now < nearest_idle_end:\n                # Если можем отправить в простой - отправляем\n                if self._should_start_planned_idle():\n                    self.target.at_planned_idle = True\n                    self.target.push_event(event_type=EventType.PLANNED_IDLE_BEGIN)\n\n                    idle_time_remaining: int = nearest_idle_end - self.env.now\n                    yield self.env.timeout(idle_time_remaining)\n                else:\n                    # если не в рабочем, просто ждём\n                    yield self.env.timeout(1)\n\n            # Простой закончился\n            if self.target.at_planned_idle:\n                # Если объект находился в простое - заканчиваем простой\n                self.target.at_planned_idle = False\n                self.target.push_event(event_type=EventType.PLANNED_IDLE_END)",
      "imports": [],
      "calls": [
        "self",
        "key",
        "planned_idles",
        "push_event",
        "total_seconds",
        "_calculate_idles_times",
        "get",
        "timeout",
        "idles_times",
        "append",
        "super",
        "_should_start_planned_idle",
        "__init__",
        "pop"
      ]
    },
    {
      "id": "class:QuarryBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py",
      "name": "QuarryBlastingWatcher",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/behaviors/blasting.py",
      "docstring": "Класс для карьера (Quarry), отслеживающий периоды взрывных работ и формирующий активные зоны",
      "methods": [
        "__init__",
        "generate_blasting_list",
        "check_trucks_state",
        "run"
      ],
      "source_code": "class QuarryBlastingWatcher(BaseBehavior):\n    \"\"\"\n    Класс для карьера (Quarry), отслеживающий периоды взрывных работ и формирующий активные зоны\n    \"\"\"\n\n    def __init__(self, target):\n        self.active_blasting_dict = {}\n        self.trucks_in_idle: List[int] = []\n        super().__init__(target)\n\n    def generate_blasting_list(self) -> list[Blasting]:\n        \"\"\"Создаёт список взрывных работ временами относительно времени симуляции\"\"\"\n        blasting_list = deepcopy(self.target.sim_data.blasting_list)\n        for blasting in blasting_list:\n            blasting.start_time = (blasting.start_time - self.target.start_time).total_seconds()\n            blasting.end_time = (blasting.end_time - self.target.start_time).total_seconds()\n        return blasting_list\n\n    def check_trucks_state(self):\n        \"\"\"\n            Проверяет состояние самосвалов карьера.\n            Если попал в состояние ожидания проведения взрывных работ, перепланируем рейсы, исключив этот самосвал.\n            Если вышел из состояния ожидания проведения взрывных работ, перепланируем рейсы, включив этот самосвал.\n        \"\"\"\n        trucks_to_exclude = []\n        trucks_to_include = []\n\n        # Проверим, кого нужно добавить в перепланирование рейсов, а кого исключить\n        for truck in self.target.truck_map.values():\n            state = truck.state\n            if state == TruckState.BLASTING_IDLE and truck.id not in self.trucks_in_idle:\n                self.trucks_in_idle.append(truck.id)\n                trucks_to_exclude.append(truck.id)\n            elif state != TruckState.BLASTING_IDLE and truck.id in self.trucks_in_idle:\n                self.trucks_in_idle.remove(truck.id)\n                trucks_to_include.append(truck.id)\n        return trucks_to_exclude, trucks_to_include\n\n    def run(self):\n        blasting_list = self.generate_blasting_list()\n\n        while blasting_list:\n            # Фильтруем актуальные и активные взрывные работы\n            blasting_list = [b for b in blasting_list if self.env.now < b.end_time]\n            active_blasting = [b for b in blasting_list if b.start_time <= self.env.now < b.end_time]\n\n            self.target.active_blasting = active_blasting\n            self.target.active_blasting_polygons = [zone for blasting in active_blasting for zone in blasting.zones]\n\n            # Пауза, чтобы дать технике возможность изменить состояние перед генерацией событий\n            yield self.env.timeout(1)\n\n            # активные взрывные работы\n            active_ids = {b.id for b in active_blasting}\n            # завершившиеся взрывные работы\n            completed_ids = set(self.active_blasting_dict.keys()) - active_ids\n\n            # Обрабатываем завершение взрывных работ\n            for blasting_id in completed_ids:\n                blasting = self.active_blasting_dict.pop(blasting_id)\n                self.target.push_event(\n                    EventType.BLASTING_END,\n                    **dict(\n                        blasting_id=blasting.id,\n                        blasting_start=self.target.start_time + timedelta(seconds=blasting.start_time),\n                        blasting_end=self.target.start_time + timedelta(seconds=blasting.end_time),\n                    )\n                )\n\n            # Обрабатываем начало новых взрывных работ\n            for blasting in active_blasting:\n                if blasting.id not in self.active_blasting_dict:\n                    self.target.push_event(\n                        EventType.BLASTING_BEGIN,\n                        **dict(\n                            blasting_id=blasting.id,\n                            blasting_start=self.target.start_time + timedelta(seconds=blasting.start_time),\n                            blasting_end=self.target.start_time + timedelta(seconds=blasting.end_time),\n                        )\n                    )\n                    self.active_blasting_dict[blasting.id] = blasting",
      "imports": [],
      "calls": [
        "generate_blasting_list",
        "self",
        "trucks_to_exclude",
        "push_event",
        "values",
        "timedelta",
        "total_seconds",
        "remove",
        "timeout",
        "keys",
        "super",
        "deepcopy",
        "append",
        "trucks_to_include",
        "dict",
        "__init__",
        "pop",
        "set"
      ]
    },
    {
      "id": "class:TruckBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py",
      "name": "TruckBlastingWatcher",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/behaviors/blasting.py",
      "docstring": "Класс для самосвала (Truck)\nОтслеживает ожидание проведения взрывных работ для самосвала.\nЕсли самосвал встал в ожидание - исключим его из планировщика.\nЕсли самосвал вышел из ожидания - добавим его в планировщик.",
      "methods": [
        "__init__",
        "run"
      ],
      "source_code": "class TruckBlastingWatcher(BaseBehavior):\n    \"\"\"\n        Класс для самосвала (Truck)\n        Отслеживает ожидание проведения взрывных работ для самосвала.\n        Если самосвал встал в ожидание - исключим его из планировщика.\n        Если самосвал вышел из ожидания - добавим его в планировщик.\n    \"\"\"\n\n    def __init__(self, target):\n        super().__init__(target)\n\n    def run(self):\n        in_blasting_idle = False\n        while True:\n            if self.target.state == TruckState.BLASTING_IDLE and not in_blasting_idle:\n                in_blasting_idle = True\n                self.target.push_event(EventType.BLASTING_IDLE_BEGIN, write_event=False)\n            elif self.target.state != TruckState.BLASTING_IDLE and in_blasting_idle:\n                in_blasting_idle = False\n                self.target.push_event(EventType.BLASTING_IDLE_END, write_event=False)\n\n            yield self.env.timeout(1)",
      "imports": [],
      "calls": [
        "timeout",
        "super",
        "push_event",
        "__init__"
      ]
    },
    {
      "id": "class:ShovelBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py",
      "name": "ShovelBlastingWatcher",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/behaviors/blasting.py",
      "docstring": "Класс для экскаватора (Shovel).\nОтслеживает наличие хотя бы одного возможного маршрута хотя бы до одного ПРа.\nЕсли ни одного маршрута нет - исключаем экскаватора из планировщика.\nКак только появится хотя бы один маршрут - добавим экскаватор в планировщик.",
      "methods": [
        "__init__",
        "wait_blasting_changing",
        "run"
      ],
      "source_code": "class ShovelBlastingWatcher(BaseBehavior):\n    \"\"\"\n        Класс для экскаватора (Shovel).\n        Отслеживает наличие хотя бы одного возможного маршрута хотя бы до одного ПРа.\n        Если ни одного маршрута нет - исключаем экскаватора из планировщика.\n        Как только появится хотя бы один маршрут - добавим экскаватор в планировщик.\n    \"\"\"\n\n    def __init__(self, target):\n        super().__init__(target)\n\n    def wait_blasting_changing(self):\n        # запоминаем активные зоны\n        remember_zones = {blasting.id for blasting in self.target.quarry.active_blasting}\n\n        # Если активные зоны взрывных работ не изменились,\n        # тогда стоим и ждём, пока зоны поменяются, чтобы заново проверять возможность проезда\n        while remember_zones == {blasting.id for blasting in self.target.quarry.active_blasting}:\n            yield self.env.timeout(1)\n\n    def run(self):\n        while True:\n            safe_path_exist = False  # существуют ли пути в объезд взрывных зон\n            for unload in self.target.quarry.unload_map.values():\n                polygons = [zone for blasting in self.target.quarry.active_blasting for zone in blasting.zones]\n\n                # Сборка всех возможных маршрутов между пунктом отправления и пункт назначения\n                paths = find_all_route_edges_by_road_net_from_object_to_object(\n                    from_object_id=self.target.id,\n                    from_object_type=ObjectType.SHOVEL,\n                    to_object_id=unload.id,\n                    to_object_type=ObjectType.UNLOAD,\n                    road_net=self.target.quarry.sim_data.road_net,\n                )\n\n                # Маршруты отсортированы по длине, выберем первый, не попадающий в полигоны взрывных работ\n                for path in paths:\n                    if not path_intersects_polygons(path, polygons):\n                        safe_path_exist = True\n                        break\n\n                if safe_path_exist:\n                    break\n\n            # Проверяем наличие безопасных маршрутов и факт нахождения в ожидании взрывных работ\n            if not safe_path_exist and not self.target.in_blasting_idle:\n                self.target.in_blasting_idle = True\n                self.target.push_event(EventType.BLASTING_IDLE_BEGIN, write_event=False)\n            elif safe_path_exist and self.target.in_blasting_idle:\n                self.target.in_blasting_idle = False\n                self.target.push_event(EventType.BLASTING_IDLE_END, write_event=False)\n\n            yield from self.wait_blasting_changing()\n\n            yield self.env.timeout(1)",
      "imports": [],
      "calls": [
        "wait_blasting_changing",
        "self",
        "find_all_route_edges_by_road_net_from_object_to_object",
        "values",
        "push_event",
        "path_intersects_polygons",
        "timeout",
        "super",
        "__init__"
      ]
    },
    {
      "id": "class:UnloadBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py",
      "name": "UnloadBlastingWatcher",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/behaviors/blasting.py",
      "docstring": "Класс для пункта разгрузки (Unload).\nОтслеживает наличие хотя бы одного возможного маршрута хотя бы до одного экскаватора.\nЕсли ни одного маршрута нет - исключаем пункт разгрузки из планировщика.\nКак только появится хотя бы один маршрут - добавим пункт разгрузки в планировщик.",
      "methods": [
        "__init__",
        "wait_blasting_changing",
        "run"
      ],
      "source_code": "class UnloadBlastingWatcher(BaseBehavior):\n    \"\"\"\n        Класс для пункта разгрузки (Unload).\n        Отслеживает наличие хотя бы одного возможного маршрута хотя бы до одного экскаватора.\n        Если ни одного маршрута нет - исключаем пункт разгрузки из планировщика.\n        Как только появится хотя бы один маршрут - добавим пункт разгрузки в планировщик.\n    \"\"\"\n\n    def __init__(self, target):\n        super().__init__(target)\n\n    def wait_blasting_changing(self):\n        # запоминаем активные зоны\n        remember_zones = {blasting.id for blasting in self.target.quarry.active_blasting}\n\n        # Если активные зоны взрывных работ не изменились,\n        # тогда стоим и ждём, пока зоны поменяются, чтобы заново проверять возможность проезда\n        while remember_zones == {blasting.id for blasting in self.target.quarry.active_blasting}:\n            yield self.env.timeout(1)\n\n    def run(self):\n        while True:\n            safe_path_exist = False  # существуют ли пути в объезд взрывных зон\n            for shovel in self.target.quarry.shovel_map.values():\n                polygons = [zone for blasting in self.target.quarry.active_blasting for zone in blasting.zones]\n\n                # Сборка всех возможных маршрутов между пунктом отправления и пункт назнчения\n                paths = find_all_route_edges_by_road_net_from_object_to_object(\n                    from_object_id=self.target.id,\n                    from_object_type=ObjectType.UNLOAD,\n                    to_object_id=shovel.id,\n                    to_object_type=ObjectType.SHOVEL,\n                    road_net=self.target.quarry.sim_data.road_net,\n                )\n\n                # Маршруты отсортированы по длине, выберем первый, не попадающий в полигоны взрывных работ\n                for path in paths:\n                    if not path_intersects_polygons(path, polygons):\n                        safe_path_exist = True\n                        break\n\n                if safe_path_exist:\n                    break\n\n            # Проверяем наличие безопасных маршрутов и факт нахождения в ожидании взрывных работ\n            if not safe_path_exist and not self.target.in_blasting_idle:\n                self.target.in_blasting_idle = True\n                self.target.push_event(EventType.BLASTING_IDLE_BEGIN, write_event=False)\n            elif safe_path_exist and self.target.in_blasting_idle:\n                self.target.in_blasting_idle = False\n                self.target.push_event(EventType.BLASTING_IDLE_END, write_event=False)\n\n            yield from self.wait_blasting_changing()\n\n            yield self.env.timeout(1)",
      "imports": [],
      "calls": [
        "wait_blasting_changing",
        "self",
        "find_all_route_edges_by_road_net_from_object_to_object",
        "values",
        "push_event",
        "path_intersects_polygons",
        "timeout",
        "super",
        "__init__"
      ]
    },
    {
      "id": "class:DependencyResolver@app/sim_engine/core/simulations/utils/dependency_resolver.py",
      "name": "DependencyResolver",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/utils/dependency_resolver.py",
      "docstring": "",
      "methods": [
        "sim_conf",
        "writer",
        "solver",
        "trip_service",
        "idle_area_service",
        "env",
        "__resolve"
      ],
      "source_code": "class DependencyResolver:\n    @classmethod\n    def sim_conf(cls) -> dict:\n        return cls.__resolve('sim_conf')\n\n    @classmethod\n    def writer(cls) -> 'IWriter':\n        return cls.__resolve('writer')\n\n    @classmethod\n    def solver(cls) -> 'GreedySolver':\n        return cls.__resolve('solver')\n\n    @classmethod\n    def trip_service(cls) -> 'TripService':\n        return cls.__resolve('trip_service')\n\n    @classmethod\n    def idle_area_service(cls) -> 'IdleAreaService':\n        return cls.__resolve('idle_area_service')\n\n    @classmethod\n    def env(cls) -> 'QSimEnvironment':\n        return cls.__resolve('sim_env')\n\n    @staticmethod\n    def __resolve(alias: str) -> Any:\n        return ServiceLocator.get_or_fail(alias)",
      "imports": [],
      "calls": [
        "__resolve",
        "ServiceLocator",
        "cls",
        "get_or_fail"
      ]
    },
    {
      "id": "function:sim_current_timestamp@app/sim_engine/core/simulations/utils/helpers.py",
      "name": "sim_current_timestamp",
      "type": "function",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/utils/helpers.py",
      "docstring": "",
      "source_code": "def sim_current_timestamp() -> float:\n    return sim_current_time().timestamp()",
      "imports": [],
      "calls": [
        "sim_current_time",
        "timestamp"
      ]
    },
    {
      "id": "function:sim_current_time@app/sim_engine/core/simulations/utils/helpers.py",
      "name": "sim_current_time",
      "type": "function",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/utils/helpers.py",
      "docstring": "",
      "source_code": "def sim_current_time() -> datetime:\n    env = DR.env()\n    return env.sim_data.start_time + timedelta(seconds=env.now)",
      "imports": [],
      "calls": [
        "DR",
        "env",
        "timedelta"
      ]
    },
    {
      "id": "function:sim_end_time@app/sim_engine/core/simulations/utils/helpers.py",
      "name": "sim_end_time",
      "type": "function",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/utils/helpers.py",
      "docstring": "",
      "source_code": "def sim_end_time() -> datetime:\n    env = DR.env()\n    return env.sim_data.end_time",
      "imports": [],
      "calls": [
        "DR",
        "env"
      ]
    },
    {
      "id": "function:sim_start_time@app/sim_engine/core/simulations/utils/helpers.py",
      "name": "sim_start_time",
      "type": "function",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/utils/helpers.py",
      "docstring": "",
      "source_code": "def sim_start_time() -> datetime:\n    env = DR.env()\n    return env.sim_data.start_time",
      "imports": [],
      "calls": [
        "DR",
        "env"
      ]
    },
    {
      "id": "class:IdleAreaService@app/sim_engine/core/simulations/utils/idle_area_service.py",
      "name": "IdleAreaService",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/utils/idle_area_service.py",
      "docstring": "Сервис, предоставляющий операции для работы с площадками простоев",
      "methods": [
        "__init__",
        "get_areas",
        "find_nearest"
      ],
      "source_code": "class IdleAreaService:\n    \"\"\"Сервис, предоставляющий операции для работы с площадками простоев\"\"\"\n\n    def __init__(self, idle_area_storage: IdleAreaStorage):\n        self.storage = idle_area_storage\n\n    def get_areas(\n            self,\n            area_type: IdleAreaType | None = None\n    ) -> list[IdleArea]:\n        \"\"\"Сбор площадок соответствующего типа\"\"\"\n        if area_type is None:\n            return self.storage.all\n        elif area_type == IdleAreaType.LUNCH:\n            return self.storage.lunch_areas\n        elif area_type == IdleAreaType.BLAST_WAITING:\n            return self.storage.blast_waiting_areas\n        elif area_type == IdleAreaType.PLANNED_IDLE:\n            return self.storage.planned_idle_areas\n        elif area_type == IdleAreaType.SHIFT_CHANGE:\n            return self.storage.shift_change_areas\n        return []\n\n    def find_nearest(\n            self,\n            area_type: IdleAreaType,\n            lon: float,\n            lat: float,\n            edge_idx: int | None,\n            restricted_zones: Tuple[Tuple[Tuple[float, float]]] | list[list[list[float]]] | None,\n            road_net: dict,\n    ) -> Tuple[IdleArea, RouteEdge] | Tuple[None, None]:\n        \"\"\"\n            Поиск ближайшей площадки, соответствующей указанному типу.\n            Поиск происходит по графу относительно переданной позиции.\n            При наличии запрещённых зон для проезда поиск будет вестись с учётом этих зон.\n\n            При отсутствии проезда к площадке из-за запретных зон будет выбрана другая ближайшая площадка при наличии\n            к ней проезда.\n\n            Возвращает кортеж: площадка, маршрут на графе к площадке\n        \"\"\"\n        areas = self.get_areas(area_type=area_type)\n\n        best_area = None\n        best_route = None\n        if areas:\n            best_length = None\n\n            # Определяем ближайшую площадку по длине пути на графе\n            for area in areas:\n                # ищем кратчайший маршрут в объезд запретных зон\n                route = find_route_edges_around_restricted_zones_from_position_to_object(\n                    lon=lon,\n                    lat=lat,\n                    edge_idx=edge_idx,\n                    to_object_id=area.id,\n                    to_object_type=ObjectType.IDLE_AREA,\n                    restricted_zones=restricted_zones or [],\n                    road_net=road_net,\n                )\n                if route:\n                    length = sum([edge.length for edge in route.edges])\n\n                    if best_length is None or length < best_length:\n                        best_area = area\n                        best_route = route\n                        best_length = length\n\n        return best_area, best_route",
      "imports": [],
      "calls": [
        "self",
        "get_areas",
        "find_route_edges_around_restricted_zones_from_position_to_object",
        "sum"
      ]
    },
    {
      "id": "class:DataclassEnumSerializerMixin@app/sim_engine/core/simulations/utils/mixins.py",
      "name": "DataclassEnumSerializerMixin",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/utils/mixins.py",
      "docstring": "",
      "methods": [
        "to_dict"
      ],
      "source_code": "class DataclassEnumSerializerMixin:\n    def to_dict(self) -> dict:\n        def serialize(field_value: Any):\n            if isinstance(field_value, enum.Enum):\n                return str(field_value)\n            return field_value\n\n        result = {}\n        for field in fields(self):\n            value = getattr(self, field.name)\n            result[field.name] = serialize(value)\n\n        return result",
      "imports": [],
      "calls": [
        "fields",
        "str",
        "isinstance",
        "serialize",
        "getattr"
      ]
    },
    {
      "id": "class:ServiceLocator@app/sim_engine/core/simulations/utils/service_locator.py",
      "name": "ServiceLocator",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/utils/service_locator.py",
      "docstring": "",
      "methods": [
        "bind",
        "get_or_fail",
        "get",
        "has",
        "unbind",
        "unbind_all"
      ],
      "source_code": "class ServiceLocator:\n    __services: dict[str, Any] = {}\n\n    @classmethod\n    def bind(cls, alias: str, instance: Any) -> None:\n        if cls.has(alias):\n            raise RuntimeError(f\"ServiceLocator: service '{alias}' already registered\")\n        cls.__services[alias] = instance\n\n    @classmethod\n    def get_or_fail(cls, alias: str, fail_message: str | None = None) -> Any:\n        service = cls.get(alias)\n\n        if service is None:\n            fail_message = fail_message or f\"ServiceLocator: service '{alias}' not registered\"\n            raise RuntimeError(fail_message)\n\n        return service\n\n    @classmethod\n    def get(cls, alias: str) -> Any:\n        if cls.has(alias):\n            return cls.__services[alias]\n        return None\n\n    @classmethod\n    def has(cls, alias: str) -> bool:\n        return alias in cls.__services\n\n    @classmethod\n    def unbind(cls, alias: str) -> None:\n        del cls.__services[alias]\n\n    @classmethod\n    def unbind_all(cls) -> None:\n        cls.__services = {}",
      "imports": [],
      "calls": [
        "has",
        "RuntimeError",
        "cls",
        "get"
      ]
    },
    {
      "id": "class:TripService@app/sim_engine/core/simulations/utils/trip_service.py",
      "name": "TripService",
      "type": "class",
      "layer": "Симуляции",
      "file_path": "app/sim_engine/core/simulations/utils/trip_service.py",
      "docstring": "",
      "methods": [
        "__init__",
        "set_shift_change_area",
        "begin",
        "finish",
        "get_summary",
        "print_summary",
        "__finish_actual_trip",
        "__update_summary_metrics"
      ],
      "source_code": "class TripService:\n    def __init__(self) -> None:\n        self.__actual_trips: dict[int, ActualTrip] = {}\n        self.__finished_trips: defaultdict[int, list[ActualTrip]] = defaultdict(list)\n\n        self.total_trips = 0\n        self.total_volume = 0\n        self.total_weight = 0\n        self.total_volume_round = 0\n        self.total_weight_round = 0\n        self.unique_truck_ids = set()\n        self.unique_shovel_ids = set()\n        self.hourly_volume = defaultdict(int)\n        self.hourly_weight = defaultdict(int)\n        self.hourly_trip = defaultdict(int)\n        self.trips_table: list[dict] = []\n\n        self.shift_change_area: IdleArea | None = None\n\n    def set_shift_change_area(self, shift_change_area: IdleArea) -> None:\n        self.shift_change_area = shift_change_area\n\n    def begin(self, trip_data: TripData) -> None:\n        truck_id = trip_data.truck_id\n\n        if truck_id in self.__actual_trips:\n            logger.debug(f\"Trip для {truck_id} уже начат\")\n            return\n\n        if truck_id in self.__finished_trips:\n            object_id = trip_data.unload_id\n            object_type = ObjectType.UNLOAD\n        else:\n            if self.shift_change_area is None:\n                raise RuntimeError('Shift area is not set')\n\n            object_id = self.shift_change_area.id\n            object_type = ObjectType.IDLE_AREA\n\n        current_time = sim_current_time()\n\n        actual_trip = ActualTrip(\n            start_trip_data=trip_data,\n            start_object=QuarryObject(\n                id=object_id,\n                type=object_type,\n            ),\n            start_time=current_time,\n        )\n\n        self.__actual_trips[truck_id] = actual_trip\n\n    def finish(self, trip_data: TripData) -> None:\n        actual_trip = self.__finish_actual_trip(trip_data)\n\n        self.__update_summary_metrics(actual_trip)\n\n        self.trips_table.append(actual_trip.to_telemetry())\n\n    def get_summary(self, end_time: datetime.datetime) -> dict:\n        start_hour = sim_start_time().hour\n        end_hour = end_time.hour\n\n        if end_hour >= start_hour:\n            hours = list(range(start_hour, end_hour + 1))\n        else:\n            hours = list(range(start_hour, 24)) + list(range(0, end_hour + 1))\n\n        chart_volume_data = []\n        chart_weight_data = []\n        chart_trip_data = []\n        for hour in hours:\n            time_str = f\"{hour}:00\"\n            volume_value = self.hourly_volume.get(hour, 0)\n            if volume_value:\n                chart_volume_data.append({'time': time_str, 'value': volume_value})\n\n            weight_value = self.hourly_weight.get(hour, 0)\n            if weight_value:\n                chart_weight_data.append({'time': time_str, 'value': weight_value})\n\n            trip_value = self.hourly_trip.get(hour, 0)\n            if trip_value:\n                chart_trip_data.append({'time': time_str, 'value': trip_value})\n\n        \"\"\"\n            на фронте изначально график на не правильный параметр был подвязан\n            'chart_volume_data': chart_weight_data,\n        \"\"\"\n        summary = {\n            'trips': self.total_trips,\n            'volume': math.floor(self.total_volume_round),\n            'weight': math.floor(self.total_weight_round),\n            # Объем, пока оставим, мб потом понадобится\n            # 'chart_volume_data': chart_volume_data,\n            'chart_volume_data': chart_weight_data,  # TODO: согласовать изменения с фронтом\n            'chart_trip_data': chart_trip_data,\n            'trucks_count': len(self.unique_truck_ids),\n            'shovels_count': len(self.unique_shovel_ids),\n            'trips_table': self.trips_table\n        }\n\n        return summary\n\n    def print_summary(self):\n        logger.debug(\n            f\"\\u2705 Завершено. Рейсов: {self.total_trips}, Объем: {self.total_volume:.1f} м3; Масса: {self.total_weight:.1f} т\")\n        for h in sorted(self.hourly_volume):\n            logger.debug(f\"  Час {h:02d}: {self.hourly_volume[h]:.1f} м3\")\n\n    def __finish_actual_trip(self, trip_data: TripData) -> ActualTrip:\n        truck_id = trip_data.truck_id\n\n        if truck_id not in self.__actual_trips:\n            raise RuntimeError(f\"Trip {truck_id} is not pending\")\n\n        current_time_value = sim_current_time()\n\n        actual_trip = self.__actual_trips[truck_id]\n        actual_trip.weight = trip_data.truck_weight\n        actual_trip.volume = trip_data.truck_volume\n        actual_trip.end_object = QuarryObject(\n            id=trip_data.unload_id,\n            type=ObjectType.UNLOAD,\n        )\n        actual_trip.end_time = current_time_value\n        actual_trip.end_trip_data = trip_data\n\n        self.__finished_trips[truck_id].append(actual_trip)\n        del self.__actual_trips[truck_id]\n\n        return actual_trip\n\n    def __update_summary_metrics(self, finished_trip: ActualTrip) -> None:\n        end_trip_data = finished_trip.end_trip_data\n\n        volume = end_trip_data.truck_volume\n        weight = end_trip_data.truck_weight\n\n        round_volume = int(volume)\n        round_weight = int(weight)\n\n        self.total_trips += 1\n        self.total_volume += volume\n        self.total_weight += weight\n        self.total_volume_round += round_volume\n        self.total_weight_round += round_weight\n\n        hour = finished_trip.end_time.hour\n        # self.hourly_volume[hour] += volume\n        # self.hourly_weight[hour] += weight\n\n        # при округлении немного теряем в точности для сходимости с конечным результатом\n        self.hourly_volume[hour] = int(self.hourly_volume[hour] + round_volume)\n        self.hourly_weight[hour] = int(self.hourly_weight[hour] + round_weight)\n        self.hourly_trip[hour] += 1\n\n        self.unique_shovel_ids.add(end_trip_data.shovel_id)\n        self.unique_truck_ids.add(end_trip_data.truck_id)",
      "imports": [],
      "calls": [
        "range",
        "logger",
        "__update_summary_metrics",
        "sim_current_time",
        "chart_volume_data",
        "floor",
        "add",
        "RuntimeError",
        "list",
        "ActualTrip",
        "self",
        "chart_weight_data",
        "QuarryObject",
        "math",
        "debug",
        "sim_start_time",
        "chart_trip_data",
        "defaultdict",
        "len",
        "sorted",
        "append",
        "int",
        "to_telemetry",
        "actual_trip",
        "get",
        "set",
        "__finish_actual_trip"
      ]
    },
    {
      "id": "class:CPSolver@app/sim_engine/core/planner/solvers/cp.py",
      "name": "CPSolver",
      "type": "class",
      "layer": "Планировщик",
      "file_path": "app/sim_engine/core/planner/solvers/cp.py",
      "docstring": "",
      "methods": [
        "compute_Kmax_i",
        "build_cp_model",
        "run"
      ],
      "source_code": "class CPSolver:\n    msg_out: bool\n    time_limit: int\n    workers: int\n\n    @staticmethod\n    def compute_Kmax_i(inst: InputPlanningData, i: int) -> int:\n        \"\"\"Грубая верхняя граница числа рейсов для самосвала i\"\"\"\n        js = {j for (ti, j) in inst.T_start.keys() if ti == i}\n        zs = {z for (ti, z) in inst.T_end.keys() if ti == i}\n        min_start = min(inst.T_start[i, j] for j in js)\n        min_end = min(inst.T_end[i, z] for z in zs)\n        min_d = min(\n            inst.T_haul[i, j, z] + inst.T_return[i, z, j] + inst.T_load[i, j] + inst.T_unload[i, z]\n            for j in js for z in zs\n        )\n        available = inst.D_work - min_start - min_end\n        return max(0, floor(available / max(1, min_d)))\n\n    @classmethod\n    def build_cp_model(cls, inst: InputPlanningData, use_individual_kmax: bool = True):\n        model = cp_model.CpModel()\n\n        I = inst.truck_ids\n        J = inst.shovel_ids  # экскаваторы\n        Zs = inst.unload_ids  # площадки разгрузки\n\n        # Горизонт (безопасная верхняя граница)\n        H = 2 * inst.D_work\n\n        # Индивидуальные горизонты рейсов\n        if inst.Kmax_by_truck:\n            Kmax_i = dict(inst.Kmax_by_truck)\n        else:\n            Kmax_i = {i: cls.compute_Kmax_i(inst, i) for i in I}\n        if not use_individual_kmax:\n            K = max(Kmax_i.values() or [0])\n            Kmax_i = {i: K for i in I}\n\n        # Переменные и структуры\n        load_itv = {}  # (i,k,j) -> optional interval\n        unload_itv = {}  # (i,k,z) -> optional interval\n        load_pres = {}  # presence literals\n        unload_pres = {}\n        s_load = {}\n        e_load = {}\n        s_unload = {}\n        e_unload = {}\n\n        shovel_to_intervals = {j: [] for j in J}\n        dump_to_intervals = {z: [] for z in Zs}\n\n        choose_shovel = {}  # (i,k,j) -> Bool\n        choose_dump = {}  # (i,k,z) -> Bool\n\n        # Создание интервалов\n        for i in I:\n            for k in range(1, Kmax_i[i] + 1):\n                # Погрузка — выбор экскаватора\n                for j in J:\n                    dur = inst.T_load[i, j]\n                    pres = model.NewBoolVar(f\"pres_load_{i}_{k}_E{j}\")\n                    start = model.NewIntVar(0, H, f\"s_load_{i}_{k}_E{j}\")\n                    end = model.NewIntVar(0, H, f\"e_load_{i}_{k}_E{j}\")\n                    itv = model.NewOptionalIntervalVar(start, dur, end, pres, f\"itv_load_{i}_{k}_E{j}\")\n                    load_itv[i, k, j] = itv\n                    load_pres[i, k, j] = pres\n                    s_load[i, k, j] = start\n                    e_load[i, k, j] = end\n                    shovel_to_intervals[j].append(itv)\n                    choose_shovel[i, k, j] = pres\n\n                # Разгрузка — выбор площадки\n                for z in Zs:\n                    dur = inst.T_unload[i, z]\n                    pres = model.NewBoolVar(f\"pres_unload_{i}_{k}_Z{z}\")\n                    start = model.NewIntVar(0, H, f\"s_unload_{i}_{k}_Z{z}\")\n                    end = model.NewIntVar(0, H, f\"e_unload_{i}_{k}_Z{z}\")\n                    itv = model.NewOptionalIntervalVar(start, dur, end, pres, f\"itv_unload_{i}_{k}_Z{z}\")\n                    unload_itv[i, k, z] = itv\n                    unload_pres[i, k, z] = pres\n                    s_unload[i, k, z] = start\n                    e_unload[i, k, z] = end\n                    dump_to_intervals[z].append(itv)\n                    choose_dump[i, k, z] = pres\n\n                # Ровно один экскаватор и ровно одна ПР на рейс k (или рейс отсутствует)\n                model.Add(sum(choose_shovel[i, k, j] for j in J) <= 1)\n                model.Add(sum(choose_dump[i, k, z] for z in Zs) <= 1)\n                # Требуем парность: если есть погрузка, должна быть и разгрузка (и наоборот)\n                model.Add(sum(choose_shovel[i, k, j] for j in J) == sum(choose_dump[i, k, z] for z in Zs))\n\n                # Монотонность наличия рейсов: если выбран k, то (k-1) тоже выбран\n                if k > 1:\n                    model.Add(sum(choose_shovel[i, k, j] for j in J) <= sum(choose_shovel[i, k - 1, j] for j in J))\n\n        # Очереди: NoOverlap\n        for j in J:\n            model.AddNoOverlap(shovel_to_intervals[j])\n        for z in Zs:\n            model.AddNoOverlap(dump_to_intervals[z])\n\n        # Связки «погрузка -> разгрузка -> след. погрузка»\n        for i in I:\n            for k in range(1, Kmax_i[i] + 1):\n                # haul: load(i,k,j) -> unload(i,k,z)\n                for j in J:\n                    for z in Zs:\n                        b = model.NewBoolVar(f\"pair_{i}_{k}_E{j}_Z{z}\")\n                        # b активна только когда выбраны и экскаватор, и ПР\n                        model.Add(choose_shovel[i, k, j] == 1).OnlyEnforceIf(b)\n                        model.Add(choose_dump[i, k, z] == 1).OnlyEnforceIf(b)\n                        model.AddBoolOr([choose_shovel[i, k, j].Not(), choose_dump[i, k, z].Not(), b])\n                        t_h = inst.T_haul[i, j, z]\n                        model.Add(s_unload[i, k, z] >= e_load[i, k, j] + t_h).OnlyEnforceIf(b)\n\n                # return: unload(i,k,z) -> load(i,k+1,j')\n                if k < Kmax_i[i]:\n                    for z in Zs:\n                        for j2 in J:\n                            b2 = model.NewBoolVar(f\"ret_{i}_{k}_Z{z}_E{j2}\")\n                            model.Add(choose_dump[i, k, z] == 1).OnlyEnforceIf(b2)\n                            model.Add(choose_shovel[i, k + 1, j2] == 1).OnlyEnforceIf(b2)\n                            model.AddBoolOr([choose_dump[i, k, z].Not(), choose_shovel[i, k + 1, j2].Not(), b2])\n                            t_r = inst.T_return[i, z, j2]\n                            model.Add(s_load[i, k + 1, j2] >= e_unload[i, k, z] + t_r).OnlyEnforceIf(b2)\n\n                # Начало смены для первой погрузки\n                for j in J:\n                    model.Add(s_load[i, 1, j] >= inst.T_start[i, j]).OnlyEnforceIf(choose_shovel[i, 1, j])\n                # Конец смены для любой выбранной разгрузки k\n                for z in Zs:\n                    model.Add(e_unload[i, k, z] + inst.T_end[i, z] <= inst.D_work).OnlyEnforceIf(choose_dump[i, k, z])\n\n        # Целевая функция — суммарные тонны (по выбранным погрузкам)\n        terms = []\n        for i in I:\n            for k in range(1, Kmax_i[i] + 1):\n                for j in J:\n                    ton = int(round(inst.m_tons[i, j]))\n                    terms.append(ton * choose_shovel[i, k, j])\n        model.Maximize(sum(terms))\n\n        # Пакуем ссылки для извлечения результатов\n        V = dict(\n            choose_shovel=choose_shovel, choose_dump=choose_dump,\n            s_load=s_load, s_unload=s_unload,\n            Kmax_i=Kmax_i,\n        )\n        return model, V\n\n    @classmethod\n    def run(cls, inst: InputPlanningData):\n        \"\"\"Решение CP‑SAT и извлечение расписания в прежнем формате.\"\"\"\n\n        if cls.msg_out:\n            logger.info(\"Start builing cp model\")\n        model, V = cls.build_cp_model(inst, use_individual_kmax=True)\n\n        if cls.msg_out:\n            logger.info(\"End builing cp model\")\n\n        solver = cp_model.CpSolver()\n        if cls.time_limit is not None:\n            solver.parameters.max_time_in_seconds = float(cls.time_limit)\n        solver.parameters.num_search_workers = cls.workers\n        solver.parameters.log_search_progress = cls.msg_out\n        solver.parameters.cp_model_presolve = True\n\n        if cls.msg_out:\n            logger.info(\"Start solve\")\n\n        status_code = solver.Solve(model)\n\n        if cls.msg_out:\n            logger.info(\"End solve\")\n\n        # Маппинг статусов к строкам как в MILP-версии\n        status_map = {\n            cp_model.OPTIMAL: \"Optimal\",\n            cp_model.FEASIBLE: \"Feasible\",\n            cp_model.INFEASIBLE: \"Infeasible\",\n            cp_model.MODEL_INVALID: \"Model Invalid\",\n            cp_model.UNKNOWN: \"Not Solved\",\n        }\n        status_str = status_map.get(status_code, \"Not Solved\")\n\n        result = {\n            \"status\": status_str,\n            \"objective\": solver.ObjectiveValue() if status_code in (cp_model.OPTIMAL, cp_model.FEASIBLE) else 0.0,\n            \"trips\": [],\n        }\n\n        if status_code not in (cp_model.OPTIMAL, cp_model.FEASIBLE):\n            return result\n\n        choose_shovel = V[\"choose_shovel\"]\n        choose_dump = V[\"choose_dump\"]\n        s_load = V[\"s_load\"]\n        s_unload = V[\"s_unload\"]\n        Kmax_i = V[\"Kmax_i\"]\n\n        I = inst.truck_ids\n        J = inst.shovel_ids\n        Zs = inst.unload_ids\n\n        # Извлекаем поездки, сохраняя прежний формат\n        for i in I:\n            kn = 1  # номер рейса для самосвала i\n            for k in range(1, Kmax_i[i] + 1):\n                # выбранный экскаватор и ПР (если рейс существует)\n                chosen_j = None\n                chosen_z = None\n                for j in J:\n                    if solver.BooleanValue(choose_shovel[i, k, j]):\n                        chosen_j = j\n                        break\n                for z in Zs:\n                    if solver.BooleanValue(choose_dump[i, k, z]):\n                        chosen_z = z\n                        break\n                if chosen_j is None or chosen_z is None:\n                    # дальше рейсов не будет из-за монотонности\n                    break\n\n                start_load = solver.Value(s_load[i, k, chosen_j])\n                start_unload = solver.Value(s_unload[i, k, chosen_z])\n                result[\"trips\"].append({\n                    \"truck_id\": i,\n                    \"order\": kn,\n                    \"shovel_id\": chosen_j,\n                    \"unload_id\": chosen_z,\n                    \"start_load\": int(start_load),\n                    \"start_unload\": int(start_unload),\n                    \"volume, t\": inst.m_tons[i, chosen_j],\n                })\n                kn += 1\n\n        # Сортировка как в исходнике\n        result[\"trips\"].sort(key=lambda r: (r[\"truck_id\"], r[\"order\"]))\n        return result",
      "imports": [],
      "calls": [
        "range",
        "logger",
        "BooleanValue",
        "OnlyEnforceIf",
        "AddBoolOr",
        "floor",
        "cls",
        "float",
        "Not",
        "sort",
        "compute_Kmax_i",
        "sum",
        "terms",
        "min",
        "Kmax_i",
        "Add",
        "NewIntVar",
        "NewOptionalIntervalVar",
        "ObjectiveValue",
        "CpSolver",
        "CpModel",
        "info",
        "status_map",
        "model",
        "Value",
        "Maximize",
        "AddNoOverlap",
        "dict",
        "cp_model",
        "append",
        "int",
        "round",
        "NewBoolVar",
        "Solve",
        "build_cp_model",
        "values",
        "solver",
        "get",
        "keys",
        "max"
      ]
    },
    {
      "id": "class:GreedySolver@app/sim_engine/core/planner/solvers/greedy.py",
      "name": "GreedySolver",
      "type": "class",
      "layer": "Планировщик",
      "file_path": "app/sim_engine/core/planner/solvers/greedy.py",
      "docstring": "",
      "methods": [
        "__init__",
        "planning_data",
        "_included_object",
        "_excluded_object",
        "_included_objects",
        "_excluded_objects",
        "_update_trucks_position",
        "_reset_cycle",
        "rebuild_planning_data",
        "rebuild_planning_data_cascade",
        "find_trucks_to_shovel",
        "choose_next_trip",
        "assign_trip"
      ],
      "source_code": "class GreedySolver:\n\n    def __init__(self, planning_data: InputPlanningData = None):\n        env = DR.env()\n\n        self.sim_context = env.sim_context\n        self.sim_data = deepcopy(env.sim_data)\n        self._planning_data = planning_data\n\n        self.exclude_objects: dict[ObjectType, list] = {\n            ObjectType.TRUCK: [],\n            ObjectType.SHOVEL: [],\n            ObjectType.UNLOAD: []\n        }\n\n    @property\n    def planning_data(self):\n        if not self._planning_data:\n            self._planning_data = get_planning_data(self.sim_data)\n        return self._planning_data\n\n    def _included_object(self, object_type: ObjectType, object_id: int):\n        self.exclude_objects[object_type].remove(object_id)\n\n    def _excluded_object(self, object_type: ObjectType, object_id: int):\n        self.exclude_objects[object_type].append(object_id)\n\n    def _included_objects(self, objects: list[tuple[int, ObjectType]]):\n        for obj in objects:\n            self._included_object(object_type=obj[1], object_id=obj[0])\n\n    def _excluded_objects(self, objects: list[tuple[int, ObjectType]]):\n        for obj in objects:\n            self._excluded_object(object_type=obj[1], object_id=obj[0])\n\n    def _update_trucks_position(self, truck_id, sim_truck):\n        truck = self.sim_data.trucks[truck_id]\n        truck.initial_lat = sim_truck.position.lat\n        truck.initial_lon = sim_truck.position.lon\n        truck.initial_edge_id = sim_truck.edge.index if sim_truck.edge else None\n\n    @staticmethod\n    def _reset_cycle(sim_truck):\n        if sim_truck.state in [\n            TruckState.MOVING_EMPTY,\n            TruckState.WAITING,\n        ]:\n            sim_truck.process.interrupt()\n\n    def rebuild_planning_data(\n            self,\n            start_time=None,\n            end_time=None,\n            excluded_object: tuple[int, ObjectType] = None,\n            included_object: tuple[int, ObjectType] = None\n    ):\n        self._planning_data = None\n\n        if start_time:\n            self.sim_data.start_time = start_time\n        if end_time:\n            self.sim_data.end_time = end_time\n\n        if excluded_object:\n            self._excluded_object(object_type=excluded_object[1], object_id=excluded_object[0])\n\n        elif included_object:\n            self._included_object(object_type=included_object[1], object_id=included_object[0])\n\n        for truck_id, sim_truck in self.sim_context.trucks.items():\n            logger.debug(f\"rebuild truck: {sim_truck.name}\")\n            self._update_trucks_position(truck_id, sim_truck)\n            self._reset_cycle(sim_truck)\n\n    def rebuild_planning_data_cascade(\n            self,\n            start_time: datetime | None = None,\n            end_time: datetime | None = None,\n            excluded_objects: List[tuple[int, ObjectType]] | None = None,\n            included_objects: List[tuple[int, ObjectType]] | None = None\n    ):\n        self._planning_data = None\n\n        if start_time:\n            self.sim_data.start_time = start_time\n        if end_time:\n            self.sim_data.end_time = end_time\n\n        if excluded_objects:\n            self._excluded_objects(excluded_objects)\n        elif included_objects:\n            self._included_objects(included_objects)\n\n        for truck_id, sim_truck in self.sim_context.trucks.items():\n            logger.debug(f\"rebuild truck: {sim_truck.name}\")\n            self._update_trucks_position(truck_id, sim_truck)\n            self._reset_cycle(sim_truck)\n\n    @staticmethod\n    def find_trucks_to_shovel(shovel):\n        trucks = []\n        for truck in shovel.quarry.truck_map.values():\n            if truck.shovel and truck.shovel.id == shovel.id and truck.state == TruckState.MOVING_EMPTY:\n                trucks.append(truck)\n        return trucks\n\n    def choose_next_trip(self, truck, now: int):\n        \"\"\"Выбирает лучшую связку (shovel, unload) для данного самосвала\"\"\"\n        best_score, best_choice = -1, None\n\n        choices = []\n\n        for shovel in truck.quarry.shovel_map.values():\n\n            if shovel.broken:\n                continue\n\n            moving_trucks = self.find_trucks_to_shovel(shovel)\n            trucks_count = len(shovel.trucks_queue) + len(moving_trucks)\n            wait_shovel = trucks_count * self.planning_data.T_load[(truck.id, shovel.id)]\n\n            for unld in truck.quarry.unload_map.values():\n\n                if unld.broken:\n                    continue\n\n                wait_unl = len(unld.trucks_queue) * self.planning_data.T_unload[(truck.id, unld.id)]\n\n                cycle_time = (\n                        self.planning_data.T_start[(truck.id, shovel.id)] +\n                        wait_shovel +\n                        self.planning_data.T_load[(truck.id, shovel.id)] +\n                        self.planning_data.T_haul[(truck.id, shovel.id, unld.id)] +\n                        wait_unl +\n                        self.planning_data.T_unload[(truck.id, unld.id)] +\n                        self.planning_data.T_return[(truck.id, unld.id, shovel.id)]\n                )\n                tons = self.planning_data.m_tons[(truck.id, shovel.id)]\n                score = tons / cycle_time\n\n                choices.append((shovel.name, unld.name, cycle_time, score))\n                if score > best_score:\n                    best_score = score\n                    best_choice = (shovel, unld, cycle_time, score)\n\n        logger.debug(f\"Choose trip for Track:{truck.name}; time: {truck.current_time}\")\n        logger.debug(f\"Choices:{choices}\")\n        return best_choice\n\n    def assign_trip(self, truck: Truck, now: int) -> PlannedTrip | None:\n        \"\"\"Формирует новый PlannedTrip и обновляет маршруты для самосвала\"\"\"\n        choice = self.choose_next_trip(truck, now)\n        if not choice:\n            return None\n\n        shovel, unld, cycle_time, score = choice\n\n        trip = PlannedTrip(\n            truck_id=truck.id,\n            shovel_id=shovel.id,\n            unload_id=unld.id,\n            order=1\n        )\n        return trip",
      "imports": [],
      "calls": [
        "logger",
        "_update_trucks_position",
        "find_trucks_to_shovel",
        "self",
        "get_planning_data",
        "_excluded_objects",
        "deepcopy",
        "trucks",
        "debug",
        "_excluded_object",
        "choose_next_trip",
        "len",
        "remove",
        "interrupt",
        "append",
        "_included_objects",
        "_reset_cycle",
        "PlannedTrip",
        "DR",
        "items",
        "values",
        "choices",
        "_included_object",
        "env"
      ]
    },
    {
      "id": "class:MILPSolver@app/sim_engine/core/planner/solvers/milp.py",
      "name": "MILPSolver",
      "type": "class",
      "layer": "Планировщик",
      "file_path": "app/sim_engine/core/planner/solvers/milp.py",
      "docstring": "",
      "methods": [
        "compute_Kmax_i",
        "default_Kmax",
        "build_model",
        "run"
      ],
      "source_code": "class MILPSolver:\n    solver_type: str\n    msg_out: bool\n    time_limit: int\n    workers: int\n\n    @staticmethod\n    def compute_Kmax_i(inst: InputPlanningData, i: int) -> int:\n        \"\"\"Грубая верхняя граница числа рейсов для самосвала i\"\"\"\n        js = {j for (ti, j) in inst.T_start.keys() if ti == i}\n        zs = {z for (ti, z) in inst.T_end.keys() if ti == i}\n        min_start = min(inst.T_start[i, j] for j in js)\n        min_end = min(inst.T_end[i, z] for z in zs)\n        min_d = min(\n            inst.T_haul[i, j, z] + inst.T_return[i, z, j] + inst.T_load[i, j] + inst.T_unload[i, z]\n            for j in js for z in zs\n        )\n        available = inst.D_work - min_start - min_end\n        return max(0, floor(available / max(1, min_d)))\n\n    @classmethod\n    def default_Kmax(cls, inst: InputPlanningData) -> Dict[int, int]:\n        \"\"\"Если Kmax не задан, вычислить его для каждого самосвала\"\"\"\n        return {i: cls.compute_Kmax_i(inst, i) for i in inst.truck_ids}\n\n    @classmethod\n    def build_model(cls, inst: InputPlanningData, shovel_queue: bool = True):\n        \"\"\"Собираем все ограничения и условия поиска решения\"\"\"\n        I = inst.truck_ids\n        J = inst.shovel_ids\n        Z = inst.unload_ids\n\n        # Верхние границы числа рейсов по самосвалам\n        Kmax = inst.Kmax_by_truck or cls.default_Kmax(inst)\n\n        # Полный список потенциальных рейсов\n        P: List[Tuple[int, int]] = [(i, k) for i in I for k in range(1, Kmax[i] + 1)]\n\n        # Оптимизационная задача: максимизация добычи\n        model = LpProblem(\"MaxVolume\", LpMaximize)\n\n        # Константы Big‑M и эпсилон:\n        #   Mbig — должна быть достаточной верхней границей времени (тут — длительность смены)\n        #   eps  — минимальный «зазор» для строгого порядка выполнения погрузки (1 единица времени)\n        Mbig = inst.D_work\n        eps = 1\n\n        # Переменные\n        x = {(i, k, j, z): LpVariable(f\"x_{i}_{k}_{j}_{z}\", 0, 1, LpBinary)\n             for (i, k) in P for j in J for z in Z}\n\n        # y[i,k] ∈ {0,1} — k-ый рейс i-ого самосвала существует\n        y = {(i, k): LpVariable(f\"y_{i}_{k}\", 0, 1, LpBinary) for (i, k) in P}\n\n        # Временные переменные (целочисленные):\n        #   s_load   — старт погрузки\n        #   s_unload — старт разгрузки\n        #   a_arr    — прибытие к экскаватору перед погрузкой\n        s_load = {(i, k): LpVariable(f\"sLoad_{i}_{k}\", lowBound=0, cat=LpInteger) for (i, k) in P}\n        s_unload = {(i, k): LpVariable(f\"sUnload_{i}_{k}\", lowBound=0, cat=LpInteger) for (i, k) in P}\n        a_arr = {(i, k): LpVariable(f\"aArr_{i}_{k}\", lowBound=0, cat=LpInteger) for (i, k) in P}\n        q = {(i, k, j, z): LpVariable(f\"q_{i}_{k}_{j}_{z}\", 0, 1, LpBinary)\n             for i in I for k in range(1, Kmax[i]) for j in J for z in Z}\n        ell = {(i, k): LpVariable(f\"ell_{i}_{k}\", 0, 1, LpBinary) for (i, k) in P}\n\n        # w[p,q,j] ∈ {0,1} — порядок обслуживания очереди экскаватора для пар рейсов p<q на экскаваторе j\n        w = {}\n        if shovel_queue:\n            for j in J:\n                for idx_p in range(len(P)):\n                    for idx_q in range(idx_p + 1, len(P)):\n                        p = P[idx_p]\n                        q_ = P[idx_q]\n                        w[p, q_, j] = LpVariable(\n                            f\"w_{p[0]}_{p[1]}__{q_[0]}_{q_[1]}__j{j}\", 0, 1, LpBinary\n                        )\n\n        # Вспомогательные суммы\n        def a_use(i, k, j):\n            return lpSum(x[i, k, j, z] for z in Z)\n\n        def b_use(i, k, z):\n            return lpSum(x[i, k, j, z] for j in J)\n\n        # Ограничения\n        for (i, k) in P:\n            model += lpSum(x[i, k, j, z] for j in J for z in Z) == y[i, k]\n\n        # (A2) Непрерывность по k\n        for i in I:\n            for k in range(1, Kmax[i]):\n                model += y[i, k + 1] <= y[i, k]\n\n        # (A3) Для первого рейса прибытие в начале смены и запрет начинать раньше\n        for i in I:\n            if Kmax[i] == 0:\n                continue\n            k = 1\n            # s_load[i,1] ≥ a_arr[i,1]\n            model += s_load[i, k] >= a_arr[i, k]\n            # a_arr[i,1] = Σ_j T_start[i,j] * a_use(i,1,j)\n            model += a_arr[i, k] == lpSum(inst.T_start[i, j] * a_use(i, k, j) for j in J)\n\n        # (A4) Начало разгрузки не раньше завершения погрузки + гружёного хода\n        for (i, k) in P:\n            model += s_unload[i, k] >= s_load[i, k] + lpSum(\n                x[i, k, j, z] * (inst.T_load[i, j] + inst.T_haul[i, j, z])\n                for j in J for z in Z\n            )\n\n        # (A5) Прибытие к экскаватору на (k+1) после разгрузки (k) и порожнего хода\n        for i in I:\n            for k in range(1, Kmax[i]):\n                model += a_arr[i, k + 1] >= s_unload[i, k] + \\\n                         lpSum(b_use(i, k, z) * inst.T_unload[i, z] for z in Z) + \\\n                         lpSum(q[i, k, j, z] * inst.T_return[i, z, j] for j in J for z in Z)\n                # Связки для q: выбранная пара (z пред., j след.) должна существовать\n                model += lpSum(q[i, k, j, z] for j in J for z in Z) == y[i, k + 1]\n                for z in Z:\n                    model += lpSum(q[i, k, j, z] for j in J) <= b_use(i, k, z)\n                for j in J:\n                    model += lpSum(q[i, k, j, z] for z in Z) <= a_use(i, k + 1, j)\n\n        # (A6) Погрузка не раньше прибытия (для всех рейсов)\n        for (i, k) in P:\n            model += s_load[i, k] >= a_arr[i, k]\n\n        # (A7) Последний рейс и возврат до конца смены\n        for i in I:\n            for k in range(1, Kmax[i] + 1):\n                # согласование ell с y и y на следующем k\n                model += ell[i, k] <= y[i, k]\n                if k < Kmax[i]:\n                    model += ell[i, k] <= 1 - y[i, k + 1]\n                    model += ell[i, k] >= y[i, k] - y[i, k + 1]\n                else:\n                    model += ell[i, k] == y[i, k]\n                # если это последний рейс, успеваем разгрузиться и вернуться до D_work\n                model += s_unload[i, k] + \\\n                         lpSum(b_use(i, k, z) * (inst.T_unload[i, z] + inst.T_end[i, z]) for z in Z) \\\n                         <= inst.D_work + Mbig * (1 - ell[i, k])\n            # ровно один «последний» при наличии хотя бы одного рейса\n            if Kmax[i] >= 1:\n                model += lpSum(ell[i, k] for k in range(1, Kmax[i] + 1)) == y[i, 1]\n\n        # --- (A8) Каждый самосвал должен выполнить хотя бы один рейс ---\n        # for i in I:\n        #     model += lpSum(y[i, k] for k in range(1, Kmax[i] + 1)) >= 1\n\n        # Учёт очередей\n        if shovel_queue and len(P) >= 2:\n            for j in J:\n                for idx_p in range(len(P)):\n                    for idx_q in range(idx_p + 1, len(P)):\n                        p = P[idx_p]\n                        q_ = P[idx_q]\n                        wvar = w[p, q_, j]\n\n                        #  Связь порядка с временами прибытия (ровно один порядок)\n                        #  a_p − a_q ≤ M(1 − w)\n                        #  a_q − a_p ≤ M w − eps\n                        model += a_arr[p] - a_arr[q_] <= Mbig * (1 - wvar)\n                        model += a_arr[q_] - a_arr[p] <= Mbig * wvar - eps\n\n                        xpj = a_use(p[0], p[1], j)\n                        xqj = a_use(q_[0], q_[1], j)\n\n                        # Время погрузки от количество грузящихся на время погрузки\n                        load_p = lpSum(x[p[0], p[1], j, z] * inst.T_load[p[0], j] for z in Z)\n                        load_q = lpSum(x[q_[0], q_[1], j, z] * inst.T_load[q_[0], j] for z in Z)\n\n                        # Если p раньше q (w=1): s_q ≥ s_p + load_p\n                        # Если q раньше p (w=0): s_p ≥ s_q + load_q\n\n                        model += s_load[q_] >= s_load[p] + load_p - Mbig * (1 - wvar) - Mbig * (2 - xpj - xqj)\n                        model += s_load[p] >= s_load[q_] + load_q - Mbig * wvar - Mbig * (2 - xpj - xqj)\n\n        # ЦЕЛЕВАЯ ФУНКЦИЯ\n        # Максимизируем тоннаж\n        obj_tons = lpSum(inst.m_tons[i, j] * x[i, k, j, z] for (i, k) in P for j in J for z in Z)\n        obj_trips = lpSum(x[i, k, j, z] for (i, k) in P for j in J for z in Z)\n        model += obj_tons\n\n        vars_pack = dict(x=x, y=y, s_load=s_load, s_unload=s_unload, a_arr=a_arr,\n                         q=q, ell=ell, w=w, Kmax=Kmax, P=P)\n        return model, vars_pack\n\n    @classmethod\n    def run(cls, inst: InputPlanningData):\n        \"\"\"Решить модель и получить расписание\n        \"\"\"\n\n        if cls.msg_out:\n            logger.info(\"Start builing model\")\n\n        model, V = cls.build_model(inst)\n\n        if cls.msg_out:\n            logger.info(\"End builing model\")\n\n        if cls.solver_type == \"CBC\":\n            logger.info(\"CBC\")\n            cmd = PULP_CBC_CMD(\n                msg=cls.msg_out,\n                timeLimit=cls.time_limit\n            )\n\n        elif cls.solver_type == \"HIGHS\":\n            logger.info(\"HIGHS\")\n            cmd = HiGHS_CMD(\n                msg=cls.msg_out,\n                timeLimit=cls.time_limit,\n                threads=cls.workers,\n            )\n\n        else:\n            sim_conf = DR.sim_conf()\n            raise ValueError(f\"Неизвестный солвер: {sim_conf[\"solver\"]}\")\n\n        if cls.msg_out:\n            logger.info(\"Start solve\")\n\n        status = model.solve(cmd)\n\n        if cls.msg_out:\n            logger.info(\"End solve\")\n\n        result = {\n            \"status\": LpStatus[model.status],\n            \"objective\": value(model.objective),\n            \"trips\": [],\n        }\n\n        # Если решения нет (Infeasible и т.п.), вернём «пусто»\n        if LpStatus[model.status] not in (\"Optimal\", \"Optimal_Infeasible\", \"Not Solved\", \"Feasible\"):\n            return result\n\n        # Извлекаем расписание, находим активные рейсы (y=1) и их (j,z)\n        x = V[\"x\"]\n        y = V[\"y\"]\n        sL = V[\"s_load\"]\n        sU = V[\"s_unload\"]\n        Kmax = V[\"Kmax\"]\n        I = inst.truck_ids\n        J = inst.shovel_ids\n        Z = inst.unload_ids\n\n        for i in I:\n            for k in range(1, Kmax[i] + 1):\n                if y[i, k].value() is None or y[i, k].value() < 0.5:\n                    continue\n                # выбранные (j, z)\n                chosen = [(j, z) for j in J for z in Z if x[i, k, j, z].value() and x[i, k, j, z].value() > 0.5]\n                if not chosen:\n                    continue\n                j, z = chosen[0]\n                result[\"trips\"].append({\n                    \"truck_id\": i,\n                    \"order\": k,\n                    \"shovel_id\": j,\n                    \"unload_id\": z,\n                    \"start_load\": int(round(sL[i, k].value() or 0)),\n                    \"start_unload\": int(round(sU[i, k].value() or 0)),\n                    \"volume, t\": inst.m_tons[i, j],\n                })\n\n        # Для удобства — сортировка по самосвалу и номеру рейса\n        result[\"trips\"].sort(key=lambda r: (r[\"truck_id\"], r[\"order\"]))\n        return result",
      "imports": [],
      "calls": [
        "range",
        "logger",
        "ValueError",
        "floor",
        "cls",
        "LpProblem",
        "HiGHS_CMD",
        "value",
        "sort",
        "compute_Kmax_i",
        "sim_conf",
        "PULP_CBC_CMD",
        "min",
        "solve",
        "b_use",
        "lpSum",
        "info",
        "len",
        "model",
        "LpVariable",
        "build_model",
        "append",
        "dict",
        "int",
        "round",
        "a_use",
        "default_Kmax",
        "DR",
        "keys",
        "max"
      ]
    }
  ],
  "relationships": [
    {
      "id": "class:DXFConverter@app/dxf_converter.py->function:local_to_global@app/geo_utils.py",
      "source": "class:DXFConverter@app/dxf_converter.py",
      "target": "function:local_to_global@app/geo_utils.py",
      "type": "calls",
      "description": "Вызывает local_to_global"
    },
    {
      "id": "class:TemplateRefMixin@app/forms.py->function:collect_model_field_names@app/forms.py",
      "source": "class:TemplateRefMixin@app/forms.py",
      "target": "function:collect_model_field_names@app/forms.py",
      "type": "calls",
      "description": "Вызывает collect_model_field_names"
    },
    {
      "id": "class:TemplateMixin@app/forms.py->function:collect_model_field_names@app/forms.py",
      "source": "class:TemplateMixin@app/forms.py",
      "target": "function:collect_model_field_names@app/forms.py",
      "type": "calls",
      "description": "Вызывает collect_model_field_names"
    },
    {
      "id": "class:ScheduleMixin@app/forms.py->class:ShiftLogic@app/shift.py",
      "source": "class:ScheduleMixin@app/forms.py",
      "target": "class:ShiftLogic@app/shift.py",
      "type": "calls",
      "description": "Вызывает ShiftLogic"
    },
    {
      "id": "class:QuarrySchema@app/forms.py->class:ShiftLogic@app/shift.py",
      "source": "class:QuarrySchema@app/forms.py",
      "target": "class:ShiftLogic@app/shift.py",
      "type": "calls",
      "description": "Вызывает ShiftLogic"
    },
    {
      "id": "class:RoadNetSchema@app/forms.py->class:RoadNetCleaner@app/road_net.py",
      "source": "class:RoadNetSchema@app/forms.py",
      "target": "class:RoadNetCleaner@app/road_net.py",
      "type": "calls",
      "description": "Вызывает RoadNetCleaner"
    },
    {
      "id": "class:MapOverlaySchema@app/forms.py->class:DXFConverter@app/dxf_converter.py",
      "source": "class:MapOverlaySchema@app/forms.py",
      "target": "class:DXFConverter@app/dxf_converter.py",
      "type": "calls",
      "description": "Вызывает DXFConverter"
    },
    {
      "id": "function:read_root@app/main.py->function:create_app@app/__init__.py",
      "source": "function:read_root@app/main.py",
      "target": "function:create_app@app/__init__.py",
      "type": "calls",
      "description": "Вызывает create_app"
    },
    {
      "id": "class:ShiftLogic@app/shift.py->class:ShiftDTO@app/shift.py",
      "source": "class:ShiftLogic@app/shift.py",
      "target": "class:ShiftDTO@app/shift.py",
      "type": "calls",
      "description": "Вызывает ShiftDTO"
    },
    {
      "id": "class:ShiftLogic@app/shift.py->class:ShiftConfigParseException@app/shift.py",
      "source": "class:ShiftLogic@app/shift.py",
      "target": "class:ShiftConfigParseException@app/shift.py",
      "type": "calls",
      "description": "Вызывает ShiftConfigParseException"
    },
    {
      "id": "class:ShiftLogic@app/shift.py->class:ShiftConfigSchemaException@app/shift.py",
      "source": "class:ShiftLogic@app/shift.py",
      "target": "class:ShiftConfigSchemaException@app/shift.py",
      "type": "calls",
      "description": "Вызывает ShiftConfigSchemaException"
    },
    {
      "id": "class:ShiftLogic@app/shift.py->class:ShiftConfigDataException@app/shift.py",
      "source": "class:ShiftLogic@app/shift.py",
      "target": "class:ShiftConfigDataException@app/shift.py",
      "type": "calls",
      "description": "Вызывает ShiftConfigDataException"
    },
    {
      "id": "class:ShiftLogic@app/shift.py->class:ShiftOffsetsDTO@app/shift.py",
      "source": "class:ShiftLogic@app/shift.py",
      "target": "class:ShiftOffsetsDTO@app/shift.py",
      "type": "calls",
      "description": "Вызывает ShiftOffsetsDTO"
    },
    {
      "id": "class:StartEndTimeGenerateService@app/services/date_time_service.py->class:StartEndTimeDTO@app/services/date_time_service.py",
      "source": "class:StartEndTimeGenerateService@app/services/date_time_service.py",
      "target": "class:StartEndTimeDTO@app/services/date_time_service.py",
      "type": "calls",
      "description": "Вызывает StartEndTimeDTO"
    },
    {
      "id": "class:ObjectDAO@app/services/object_service.py->class:TrailTruckAssociation@app/models.py",
      "source": "class:ObjectDAO@app/services/object_service.py",
      "target": "class:TrailTruckAssociation@app/models.py",
      "type": "calls",
      "description": "Вызывает TrailTruckAssociation"
    },
    {
      "id": "class:ObjectService@app/services/object_service.py->function:validate_object_type@app/models.py",
      "source": "class:ObjectService@app/services/object_service.py",
      "target": "function:validate_object_type@app/models.py",
      "type": "calls",
      "description": "Вызывает validate_object_type"
    },
    {
      "id": "class:ObjectService@app/services/object_service.py->class:ScheduleObjectService@app/services/object_service.py",
      "source": "class:ObjectService@app/services/object_service.py",
      "target": "class:ScheduleObjectService@app/services/object_service.py",
      "type": "calls",
      "description": "Вызывает ScheduleObjectService"
    },
    {
      "id": "class:ObjectService@app/services/object_service.py->class:GenericObjectService@app/services/object_service.py",
      "source": "class:ObjectService@app/services/object_service.py",
      "target": "class:GenericObjectService@app/services/object_service.py",
      "type": "calls",
      "description": "Вызывает GenericObjectService"
    },
    {
      "id": "class:ObjectService@app/services/object_service.py->class:ObjectDAO@app/services/object_service.py",
      "source": "class:ObjectService@app/services/object_service.py",
      "target": "class:ObjectDAO@app/services/object_service.py",
      "type": "calls",
      "description": "Вызывает ObjectDAO"
    },
    {
      "id": "class:ObjectService@app/services/object_service.py->class:ScenarioObjectService@app/services/object_service.py",
      "source": "class:ObjectService@app/services/object_service.py",
      "target": "class:ScenarioObjectService@app/services/object_service.py",
      "type": "calls",
      "description": "Вызывает ScenarioObjectService"
    },
    {
      "id": "class:QuarryDataService@app/services/quarry_data_service.py->class:QuarryDAO@app/services/quarry_data_service.py",
      "source": "class:QuarryDataService@app/services/quarry_data_service.py",
      "target": "class:QuarryDAO@app/services/quarry_data_service.py",
      "type": "calls",
      "description": "Вызывает QuarryDAO"
    },
    {
      "id": "class:QuarryDataService@app/services/quarry_data_service.py->class:QuarryDataDTO@app/services/quarry_data_service.py",
      "source": "class:QuarryDataService@app/services/quarry_data_service.py",
      "target": "class:QuarryDataDTO@app/services/quarry_data_service.py",
      "type": "calls",
      "description": "Вызывает QuarryDataDTO"
    },
    {
      "id": "class:ScenarioService@app/services/scenario_service.py->class:ScenarioDAO@app/services/scenario_service.py",
      "source": "class:ScenarioService@app/services/scenario_service.py",
      "target": "class:ScenarioDAO@app/services/scenario_service.py",
      "type": "calls",
      "description": "Вызывает ScenarioDAO"
    },
    {
      "id": "class:ScenarioService@app/services/scenario_service.py->class:TrailDTO@app/services/scenario_service.py",
      "source": "class:ScenarioService@app/services/scenario_service.py",
      "target": "class:TrailDTO@app/services/scenario_service.py",
      "type": "calls",
      "description": "Вызывает TrailDTO"
    },
    {
      "id": "class:ScenarioService@app/services/scenario_service.py->class:ScenarioDTO@app/services/scenario_service.py",
      "source": "class:ScenarioService@app/services/scenario_service.py",
      "target": "class:ScenarioDTO@app/services/scenario_service.py",
      "type": "calls",
      "description": "Вызывает ScenarioDTO"
    },
    {
      "id": "class:ScheduleDAO@app/services/schedule_data_service.py->class:ScheduleItemDTO@app/services/schedule_data_service.py",
      "source": "class:ScheduleDAO@app/services/schedule_data_service.py",
      "target": "class:ScheduleItemDTO@app/services/schedule_data_service.py",
      "type": "calls",
      "description": "Вызывает ScheduleItemDTO"
    },
    {
      "id": "class:ScheduleDataService@app/services/schedule_data_service.py->class:ShiftLogic@app/shift.py",
      "source": "class:ScheduleDataService@app/services/schedule_data_service.py",
      "target": "class:ShiftLogic@app/shift.py",
      "type": "calls",
      "description": "Вызывает ShiftLogic"
    },
    {
      "id": "class:ScheduleDataService@app/services/schedule_data_service.py->class:ScheduleDAO@app/services/schedule_data_service.py",
      "source": "class:ScheduleDataService@app/services/schedule_data_service.py",
      "target": "class:ScheduleDAO@app/services/schedule_data_service.py",
      "type": "calls",
      "description": "Вызывает ScheduleDAO"
    },
    {
      "id": "class:ScheduleDataService@app/services/schedule_data_service.py->class:ShiftConfigParseException@app/shift.py",
      "source": "class:ScheduleDataService@app/services/schedule_data_service.py",
      "target": "class:ShiftConfigParseException@app/shift.py",
      "type": "calls",
      "description": "Вызывает ShiftConfigParseException"
    },
    {
      "id": "class:ScheduleDataService@app/services/schedule_data_service.py->class:ScheduleDataResponseDTO@app/services/schedule_data_service.py",
      "source": "class:ScheduleDataService@app/services/schedule_data_service.py",
      "target": "class:ScheduleDataResponseDTO@app/services/schedule_data_service.py",
      "type": "calls",
      "description": "Вызывает ScheduleDataResponseDTO"
    },
    {
      "id": "class:ScheduleDataService@app/services/schedule_data_service.py->class:ShiftConfigDataException@app/shift.py",
      "source": "class:ScheduleDataService@app/services/schedule_data_service.py",
      "target": "class:ShiftConfigDataException@app/shift.py",
      "type": "calls",
      "description": "Вызывает ShiftConfigDataException"
    },
    {
      "id": "class:ScheduleDataService@app/services/schedule_data_service.py->class:ShiftDetailsDTO@app/services/schedule_data_service.py",
      "source": "class:ScheduleDataService@app/services/schedule_data_service.py",
      "target": "class:ShiftDetailsDTO@app/services/schedule_data_service.py",
      "type": "calls",
      "description": "Вызывает ShiftDetailsDTO"
    },
    {
      "id": "class:GetSimIdService@app/services/simulation_id_service.py->class:SimulationDAO@app/services/simulation_id_service.py",
      "source": "class:GetSimIdService@app/services/simulation_id_service.py",
      "target": "class:SimulationDAO@app/services/simulation_id_service.py",
      "type": "calls",
      "description": "Вызывает SimulationDAO"
    },
    {
      "id": "class:GetSimIdService@app/services/simulation_id_service.py->class:SimulationManager@app/sim_engine/simulation_manager.py",
      "source": "class:GetSimIdService@app/services/simulation_id_service.py",
      "target": "class:SimulationManager@app/sim_engine/simulation_manager.py",
      "type": "calls",
      "description": "Вызывает SimulationManager"
    },
    {
      "id": "class:GetSimIdService@app/services/simulation_id_service.py->class:BatchWriter@app/sim_engine/writer.py",
      "source": "class:GetSimIdService@app/services/simulation_id_service.py",
      "target": "class:BatchWriter@app/sim_engine/writer.py",
      "type": "calls",
      "description": "Вызывает BatchWriter"
    },
    {
      "id": "class:AllTemplatesListService@app/services/template_service.py->class:TemplateDAO@app/services/template_service.py",
      "source": "class:AllTemplatesListService@app/services/template_service.py",
      "target": "class:TemplateDAO@app/services/template_service.py",
      "type": "calls",
      "description": "Вызывает TemplateDAO"
    },
    {
      "id": "class:AllTemplatesListService@app/services/template_service.py->class:AllTemplatesDTO@app/services/template_service.py",
      "source": "class:AllTemplatesListService@app/services/template_service.py",
      "target": "class:AllTemplatesDTO@app/services/template_service.py",
      "type": "calls",
      "description": "Вызывает AllTemplatesDTO"
    },
    {
      "id": "function:default_Kmax@app/sim_engine/planner.py->function:compute_Kmax_i@app/sim_engine/planner.py",
      "source": "function:default_Kmax@app/sim_engine/planner.py",
      "target": "function:compute_Kmax_i@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает compute_Kmax_i"
    },
    {
      "id": "function:build_model@app/sim_engine/planner.py->function:default_Kmax@app/sim_engine/planner.py",
      "source": "function:build_model@app/sim_engine/planner.py",
      "target": "function:default_Kmax@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает default_Kmax"
    },
    {
      "id": "function:solve_and_extract@app/sim_engine/planner.py->function:build_model@app/sim_engine/planner.py",
      "source": "function:solve_and_extract@app/sim_engine/planner.py",
      "target": "function:build_model@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает build_model"
    },
    {
      "id": "function:build_cp_model@app/sim_engine/planner.py->function:compute_Kmax_i@app/sim_engine/planner.py",
      "source": "function:build_cp_model@app/sim_engine/planner.py",
      "target": "function:compute_Kmax_i@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает compute_Kmax_i"
    },
    {
      "id": "function:solve_and_extract_cp@app/sim_engine/planner.py->function:build_cp_model@app/sim_engine/planner.py",
      "source": "function:solve_and_extract_cp@app/sim_engine/planner.py",
      "target": "function:build_cp_model@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает build_cp_model"
    },
    {
      "id": "function:make_example@app/sim_engine/planner.py->class:InputPlanningData@app/sim_engine/planner.py",
      "source": "function:make_example@app/sim_engine/planner.py",
      "target": "class:InputPlanningData@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает InputPlanningData"
    },
    {
      "id": "function:make_example@app/sim_engine/planner.py->class:InputPlanningData@app/sim_engine/core/planner/entities.py",
      "source": "function:make_example@app/sim_engine/planner.py",
      "target": "class:InputPlanningData@app/sim_engine/core/planner/entities.py",
      "type": "calls",
      "description": "Вызывает InputPlanningData"
    },
    {
      "id": "function:get_planning_data@app/sim_engine/planner.py->class:TruckCalc@app/sim_engine/core/calculations/truck.py",
      "source": "function:get_planning_data@app/sim_engine/planner.py",
      "target": "class:TruckCalc@app/sim_engine/core/calculations/truck.py",
      "type": "calls",
      "description": "Вызывает TruckCalc"
    },
    {
      "id": "function:get_planning_data@app/sim_engine/planner.py->class:UnloadCalc@app/sim_engine/core/calculations/unload.py",
      "source": "function:get_planning_data@app/sim_engine/planner.py",
      "target": "class:UnloadCalc@app/sim_engine/core/calculations/unload.py",
      "type": "calls",
      "description": "Вызывает UnloadCalc"
    },
    {
      "id": "function:get_planning_data@app/sim_engine/planner.py->class:InputPlanningData@app/sim_engine/planner.py",
      "source": "function:get_planning_data@app/sim_engine/planner.py",
      "target": "class:InputPlanningData@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает InputPlanningData"
    },
    {
      "id": "function:get_planning_data@app/sim_engine/planner.py->class:InputPlanningData@app/sim_engine/core/planner/entities.py",
      "source": "function:get_planning_data@app/sim_engine/planner.py",
      "target": "class:InputPlanningData@app/sim_engine/core/planner/entities.py",
      "type": "calls",
      "description": "Вызывает InputPlanningData"
    },
    {
      "id": "function:get_planning_data@app/sim_engine/planner.py->class:ShovelCalc@app/sim_engine/core/calculations/shovel.py",
      "source": "function:get_planning_data@app/sim_engine/planner.py",
      "target": "class:ShovelCalc@app/sim_engine/core/calculations/shovel.py",
      "type": "calls",
      "description": "Вызывает ShovelCalc"
    },
    {
      "id": "function:get_planning_data@app/sim_engine/planner.py->function:build_route_edges_by_road_net_from_position@app/sim_engine/core/geometry.py",
      "source": "function:get_planning_data@app/sim_engine/planner.py",
      "target": "function:build_route_edges_by_road_net_from_position@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает build_route_edges_by_road_net_from_position"
    },
    {
      "id": "function:get_planning_data@app/sim_engine/planner.py->function:build_route_edges_by_road_net@app/sim_engine/core/geometry.py",
      "source": "function:get_planning_data@app/sim_engine/planner.py",
      "target": "function:build_route_edges_by_road_net@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает build_route_edges_by_road_net"
    },
    {
      "id": "function:run_planning@app/sim_engine/planner.py->function:get_planning_data@app/sim_engine/planner.py",
      "source": "function:run_planning@app/sim_engine/planner.py",
      "target": "function:get_planning_data@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает get_planning_data"
    },
    {
      "id": "function:run_planning@app/sim_engine/planner.py->function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py",
      "source": "function:run_planning@app/sim_engine/planner.py",
      "target": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py",
      "type": "calls",
      "description": "Вызывает get_planning_data"
    },
    {
      "id": "function:run_planning@app/sim_engine/planner.py->function:solve_and_extract_cp@app/sim_engine/planner.py",
      "source": "function:run_planning@app/sim_engine/planner.py",
      "target": "function:solve_and_extract_cp@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает solve_and_extract_cp"
    },
    {
      "id": "function:run_planning_trips@app/sim_engine/planner.py->function:run_planning@app/sim_engine/planner.py",
      "source": "function:run_planning_trips@app/sim_engine/planner.py",
      "target": "function:run_planning@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает run_planning"
    },
    {
      "id": "function:run_planning_trips@app/sim_engine/planner.py->class:PlannedTrip@app/sim_engine/core/props.py",
      "source": "function:run_planning_trips@app/sim_engine/planner.py",
      "target": "class:PlannedTrip@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает PlannedTrip"
    },
    {
      "id": "function:lognormal_pi@app/sim_engine/reliability.py->function:predictive_interval_t@app/sim_engine/reliability.py",
      "source": "function:lognormal_pi@app/sim_engine/reliability.py",
      "target": "function:predictive_interval_t@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает predictive_interval_t"
    },
    {
      "id": "function:jackknife_plus_pi@app/sim_engine/reliability.py->function:predictive_interval_t@app/sim_engine/reliability.py",
      "source": "function:jackknife_plus_pi@app/sim_engine/reliability.py",
      "target": "function:predictive_interval_t@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает predictive_interval_t"
    },
    {
      "id": "function:yeojohnson_pi@app/sim_engine/reliability.py->function:predictive_interval_t@app/sim_engine/reliability.py",
      "source": "function:yeojohnson_pi@app/sim_engine/reliability.py",
      "target": "function:predictive_interval_t@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает predictive_interval_t"
    },
    {
      "id": "function:select_best_interval@app/sim_engine/reliability.py->function:interval_width@app/sim_engine/reliability.py",
      "source": "function:select_best_interval@app/sim_engine/reliability.py",
      "target": "function:interval_width@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает interval_width"
    },
    {
      "id": "function:assess_stability@app/sim_engine/reliability.py->function:extract_metric@app/sim_engine/reliability.py",
      "source": "function:assess_stability@app/sim_engine/reliability.py",
      "target": "function:extract_metric@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает extract_metric"
    },
    {
      "id": "function:assess_stability@app/sim_engine/reliability.py->function:predictive_interval_t@app/sim_engine/reliability.py",
      "source": "function:assess_stability@app/sim_engine/reliability.py",
      "target": "function:predictive_interval_t@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает predictive_interval_t"
    },
    {
      "id": "function:calc_reliability@app/sim_engine/reliability.py->function:loo_coverage@app/sim_engine/reliability.py",
      "source": "function:calc_reliability@app/sim_engine/reliability.py",
      "target": "function:loo_coverage@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает loo_coverage"
    },
    {
      "id": "function:calc_reliability@app/sim_engine/reliability.py->function:pit_values_t_predictive@app/sim_engine/reliability.py",
      "source": "function:calc_reliability@app/sim_engine/reliability.py",
      "target": "function:pit_values_t_predictive@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает pit_values_t_predictive"
    },
    {
      "id": "function:calc_reliability@app/sim_engine/reliability.py->function:split_conformal_pi@app/sim_engine/reliability.py",
      "source": "function:calc_reliability@app/sim_engine/reliability.py",
      "target": "function:split_conformal_pi@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает split_conformal_pi"
    },
    {
      "id": "function:calc_reliability@app/sim_engine/reliability.py->function:bootstrap_pi@app/sim_engine/reliability.py",
      "source": "function:calc_reliability@app/sim_engine/reliability.py",
      "target": "function:bootstrap_pi@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает bootstrap_pi"
    },
    {
      "id": "function:calc_reliability@app/sim_engine/reliability.py->function:split_conformal_asymmetric@app/sim_engine/reliability.py",
      "source": "function:calc_reliability@app/sim_engine/reliability.py",
      "target": "function:split_conformal_asymmetric@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает split_conformal_asymmetric"
    },
    {
      "id": "function:calc_reliability@app/sim_engine/reliability.py->function:lognormal_pi@app/sim_engine/reliability.py",
      "source": "function:calc_reliability@app/sim_engine/reliability.py",
      "target": "function:lognormal_pi@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает lognormal_pi"
    },
    {
      "id": "function:calc_reliability@app/sim_engine/reliability.py->function:interval_width@app/sim_engine/reliability.py",
      "source": "function:calc_reliability@app/sim_engine/reliability.py",
      "target": "function:interval_width@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает interval_width"
    },
    {
      "id": "function:calc_reliability@app/sim_engine/reliability.py->function:kde_hdi@app/sim_engine/reliability.py",
      "source": "function:calc_reliability@app/sim_engine/reliability.py",
      "target": "function:kde_hdi@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает kde_hdi"
    },
    {
      "id": "function:calc_reliability@app/sim_engine/reliability.py->function:predictive_interval_t@app/sim_engine/reliability.py",
      "source": "function:calc_reliability@app/sim_engine/reliability.py",
      "target": "function:predictive_interval_t@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает predictive_interval_t"
    },
    {
      "id": "function:calc_reliability@app/sim_engine/reliability.py->function:yeojohnson_pi@app/sim_engine/reliability.py",
      "source": "function:calc_reliability@app/sim_engine/reliability.py",
      "target": "function:yeojohnson_pi@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает yeojohnson_pi"
    },
    {
      "id": "function:calc_reliability@app/sim_engine/reliability.py->function:descriptive_stats@app/sim_engine/reliability.py",
      "source": "function:calc_reliability@app/sim_engine/reliability.py",
      "target": "function:descriptive_stats@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает descriptive_stats"
    },
    {
      "id": "function:calc_reliability@app/sim_engine/reliability.py->function:select_best_interval@app/sim_engine/reliability.py",
      "source": "function:calc_reliability@app/sim_engine/reliability.py",
      "target": "function:select_best_interval@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает select_best_interval"
    },
    {
      "id": "function:calc_reliability@app/sim_engine/reliability.py->function:kde_mode@app/sim_engine/reliability.py",
      "source": "function:calc_reliability@app/sim_engine/reliability.py",
      "target": "function:kde_mode@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает kde_mode"
    },
    {
      "id": "function:calc_reliability@app/sim_engine/reliability.py->function:robust_pi_quantiles@app/sim_engine/reliability.py",
      "source": "function:calc_reliability@app/sim_engine/reliability.py",
      "target": "function:robust_pi_quantiles@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает robust_pi_quantiles"
    },
    {
      "id": "function:calc_reliability@app/sim_engine/reliability.py->function:jackknife_plus_pi@app/sim_engine/reliability.py",
      "source": "function:calc_reliability@app/sim_engine/reliability.py",
      "target": "function:jackknife_plus_pi@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает jackknife_plus_pi"
    },
    {
      "id": "function:calc_reliability@app/sim_engine/reliability.py->function:half_sample_mode@app/sim_engine/reliability.py",
      "source": "function:calc_reliability@app/sim_engine/reliability.py",
      "target": "function:half_sample_mode@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает half_sample_mode"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:Truck@app/models.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:Truck@app/models.py",
      "type": "calls",
      "description": "Вызывает Truck"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:Truck@app/sim_engine/core/props.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:Truck@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Truck"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:Truck@app/sim_engine/core/simulations/truck.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "type": "calls",
      "description": "Вызывает Truck"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->function:utc_to_enterprise@app/utils.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "function:utc_to_enterprise@app/utils.py",
      "type": "calls",
      "description": "Вызывает utc_to_enterprise"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:UnlProperties@app/sim_engine/core/props.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:UnlProperties@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает UnlProperties"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:IdleArea@app/models.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:IdleArea@app/models.py",
      "type": "calls",
      "description": "Вызывает IdleArea"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:IdleArea@app/sim_engine/core/props.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:IdleArea@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает IdleArea"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->function:collect_planned_idles@app/sim_engine/serializer.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "function:collect_planned_idles@app/sim_engine/serializer.py",
      "type": "calls",
      "description": "Вызывает collect_planned_idles"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->function:calculate_lunch_breaks@app/sim_engine/serializer.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "function:calculate_lunch_breaks@app/sim_engine/serializer.py",
      "type": "calls",
      "description": "Вызывает calculate_lunch_breaks"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:Segment@app/sim_engine/core/props.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:Segment@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Segment"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:FuelStationProperties@app/sim_engine/core/props.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:FuelStationProperties@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает FuelStationProperties"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:Shovel@app/models.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:Shovel@app/models.py",
      "type": "calls",
      "description": "Вызывает Shovel"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:Shovel@app/sim_engine/core/props.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:Shovel@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Shovel"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:Shovel@app/sim_engine/core/simulations/shovel.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:Shovel@app/sim_engine/core/simulations/shovel.py",
      "type": "calls",
      "description": "Вызывает Shovel"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:Unload@app/models.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:Unload@app/models.py",
      "type": "calls",
      "description": "Вызывает Unload"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:Unload@app/sim_engine/core/props.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:Unload@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Unload"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:Unload@app/sim_engine/core/simulations/unload.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:Unload@app/sim_engine/core/simulations/unload.py",
      "type": "calls",
      "description": "Вызывает Unload"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->function:create_blasting_list@app/sim_engine/serializer.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "function:create_blasting_list@app/sim_engine/serializer.py",
      "type": "calls",
      "description": "Вызывает create_blasting_list"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:TruckProperties@app/sim_engine/core/props.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:TruckProperties@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает TruckProperties"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:ShovelProperties@app/sim_engine/core/props.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:ShovelProperties@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает ShovelProperties"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:IdleAreaStorage@app/sim_engine/core/props.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:IdleAreaStorage@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает IdleAreaStorage"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:Point@app/sim_engine/core/geometry.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:Point@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает Point"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:Point@app/sim_engine/core/props.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:Point@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Point"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:FuelStation@app/models.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:FuelStation@app/models.py",
      "type": "calls",
      "description": "Вызывает FuelStation"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:FuelStation@app/sim_engine/core/props.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:FuelStation@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает FuelStation"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:FuelStation@app/sim_engine/core/simulations/fuel_station.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:FuelStation@app/sim_engine/core/simulations/fuel_station.py",
      "type": "calls",
      "description": "Вызывает FuelStation"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:Route@app/sim_engine/core/geometry.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:Route@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает Route"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:Route@app/sim_engine/core/props.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:Route@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Route"
    },
    {
      "id": "class:SimDataSerializer@app/sim_engine/serializer.py->class:SimData@app/sim_engine/core/props.py",
      "source": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "target": "class:SimData@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает SimData"
    },
    {
      "id": "function:collect_planned_idles@app/sim_engine/serializer.py->class:PlannedIdle@app/models.py",
      "source": "function:collect_planned_idles@app/sim_engine/serializer.py",
      "target": "class:PlannedIdle@app/models.py",
      "type": "calls",
      "description": "Вызывает PlannedIdle"
    },
    {
      "id": "function:collect_planned_idles@app/sim_engine/serializer.py->class:PlannedIdle@app/sim_engine/core/props.py",
      "source": "function:collect_planned_idles@app/sim_engine/serializer.py",
      "target": "class:PlannedIdle@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает PlannedIdle"
    },
    {
      "id": "function:collect_planned_idles@app/sim_engine/serializer.py->function:utc_to_enterprise@app/utils.py",
      "source": "function:collect_planned_idles@app/sim_engine/serializer.py",
      "target": "function:utc_to_enterprise@app/utils.py",
      "type": "calls",
      "description": "Вызывает utc_to_enterprise"
    },
    {
      "id": "function:create_blasting_list@app/sim_engine/serializer.py->function:utc_to_enterprise@app/utils.py",
      "source": "function:create_blasting_list@app/sim_engine/serializer.py",
      "target": "function:utc_to_enterprise@app/utils.py",
      "type": "calls",
      "description": "Вызывает utc_to_enterprise"
    },
    {
      "id": "function:create_blasting_list@app/sim_engine/serializer.py->class:Blasting@app/models.py",
      "source": "function:create_blasting_list@app/sim_engine/serializer.py",
      "target": "class:Blasting@app/models.py",
      "type": "calls",
      "description": "Вызывает Blasting"
    },
    {
      "id": "function:create_blasting_list@app/sim_engine/serializer.py->class:Blasting@app/sim_engine/core/props.py",
      "source": "function:create_blasting_list@app/sim_engine/serializer.py",
      "target": "class:Blasting@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Blasting"
    },
    {
      "id": "function:sim_data_validate@app/sim_engine/simulate.py->class:DataValidateError@app/sim_engine/simulate.py",
      "source": "function:sim_data_validate@app/sim_engine/simulate.py",
      "target": "class:DataValidateError@app/sim_engine/simulate.py",
      "type": "calls",
      "description": "Вызывает DataValidateError"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:Truck@app/models.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:Truck@app/models.py",
      "type": "calls",
      "description": "Вызывает Truck"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:Truck@app/sim_engine/core/props.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:Truck@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Truck"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:Truck@app/sim_engine/core/simulations/truck.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "type": "calls",
      "description": "Вызывает Truck"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->function:build_route_by_road_net@app/sim_engine/core/geometry.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "function:build_route_by_road_net@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает build_route_by_road_net"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:Shovel@app/models.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:Shovel@app/models.py",
      "type": "calls",
      "description": "Вызывает Shovel"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:Shovel@app/sim_engine/core/props.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:Shovel@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Shovel"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:Shovel@app/sim_engine/core/simulations/shovel.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:Shovel@app/sim_engine/core/simulations/shovel.py",
      "type": "calls",
      "description": "Вызывает Shovel"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:Quarry@app/models.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:Quarry@app/models.py",
      "type": "calls",
      "description": "Вызывает Quarry"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:Quarry@app/sim_engine/core/simulations/quarry.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:Quarry@app/sim_engine/core/simulations/quarry.py",
      "type": "calls",
      "description": "Вызывает Quarry"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:Unload@app/models.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:Unload@app/models.py",
      "type": "calls",
      "description": "Вызывает Unload"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:Unload@app/sim_engine/core/props.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:Unload@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Unload"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:Unload@app/sim_engine/core/simulations/unload.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:Unload@app/sim_engine/core/simulations/unload.py",
      "type": "calls",
      "description": "Вызывает Unload"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:PlannedTrip@app/sim_engine/core/props.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:PlannedTrip@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает PlannedTrip"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->function:build_route_edges_by_road_net@app/sim_engine/core/geometry.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "function:build_route_edges_by_road_net@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает build_route_edges_by_road_net"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:FuelStation@app/models.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:FuelStation@app/models.py",
      "type": "calls",
      "description": "Вызывает FuelStation"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:FuelStation@app/sim_engine/core/props.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:FuelStation@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает FuelStation"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:FuelStation@app/sim_engine/core/simulations/fuel_station.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:FuelStation@app/sim_engine/core/simulations/fuel_station.py",
      "type": "calls",
      "description": "Вызывает FuelStation"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:Point@app/sim_engine/core/geometry.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:Point@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает Point"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:Point@app/sim_engine/core/props.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:Point@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Point"
    },
    {
      "id": "function:run_simulation@app/sim_engine/simulate.py->class:QSimEnvironment@app/sim_engine/core/environment.py",
      "source": "function:run_simulation@app/sim_engine/simulate.py",
      "target": "class:QSimEnvironment@app/sim_engine/core/environment.py",
      "type": "calls",
      "description": "Вызывает QSimEnvironment"
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py->class:Truck@app/models.py",
      "source": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "target": "class:Truck@app/models.py",
      "type": "calls",
      "description": "Вызывает Truck"
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py->class:Truck@app/sim_engine/core/props.py",
      "source": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "target": "class:Truck@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Truck"
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py->class:Truck@app/sim_engine/core/simulations/truck.py",
      "source": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "target": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "type": "calls",
      "description": "Вызывает Truck"
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py->class:Shovel@app/models.py",
      "source": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "target": "class:Shovel@app/models.py",
      "type": "calls",
      "description": "Вызывает Shovel"
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py->class:Shovel@app/sim_engine/core/props.py",
      "source": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "target": "class:Shovel@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Shovel"
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py->class:Shovel@app/sim_engine/core/simulations/shovel.py",
      "source": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "target": "class:Shovel@app/sim_engine/core/simulations/shovel.py",
      "type": "calls",
      "description": "Вызывает Shovel"
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py->class:Quarry@app/models.py",
      "source": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "target": "class:Quarry@app/models.py",
      "type": "calls",
      "description": "Вызывает Quarry"
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py->class:Quarry@app/sim_engine/core/simulations/quarry.py",
      "source": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "target": "class:Quarry@app/sim_engine/core/simulations/quarry.py",
      "type": "calls",
      "description": "Вызывает Quarry"
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py->class:Unload@app/models.py",
      "source": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "target": "class:Unload@app/models.py",
      "type": "calls",
      "description": "Вызывает Unload"
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py->class:Unload@app/sim_engine/core/props.py",
      "source": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "target": "class:Unload@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Unload"
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py->class:Unload@app/sim_engine/core/simulations/unload.py",
      "source": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "target": "class:Unload@app/sim_engine/core/simulations/unload.py",
      "type": "calls",
      "description": "Вызывает Unload"
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py->class:FuelStation@app/models.py",
      "source": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "target": "class:FuelStation@app/models.py",
      "type": "calls",
      "description": "Вызывает FuelStation"
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py->class:FuelStation@app/sim_engine/core/props.py",
      "source": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "target": "class:FuelStation@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает FuelStation"
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py->class:FuelStation@app/sim_engine/core/simulations/fuel_station.py",
      "source": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "target": "class:FuelStation@app/sim_engine/core/simulations/fuel_station.py",
      "type": "calls",
      "description": "Вызывает FuelStation"
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py->class:Point@app/sim_engine/core/geometry.py",
      "source": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "target": "class:Point@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает Point"
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py->class:Point@app/sim_engine/core/props.py",
      "source": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "target": "class:Point@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Point"
    },
    {
      "id": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py->class:QSimEnvironment@app/sim_engine/core/environment.py",
      "source": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "target": "class:QSimEnvironment@app/sim_engine/core/environment.py",
      "type": "calls",
      "description": "Вызывает QSimEnvironment"
    },
    {
      "id": "function:run_reliability@app/sim_engine/simulate.py->function:find_closest_result@app/sim_engine/reliability.py",
      "source": "function:run_reliability@app/sim_engine/simulate.py",
      "target": "function:find_closest_result@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает find_closest_result"
    },
    {
      "id": "function:run_reliability@app/sim_engine/simulate.py->function:calc_reliability@app/sim_engine/reliability.py",
      "source": "function:run_reliability@app/sim_engine/simulate.py",
      "target": "function:calc_reliability@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает calc_reliability"
    },
    {
      "id": "function:run_reliability@app/sim_engine/simulate.py->function:assess_stability@app/sim_engine/reliability.py",
      "source": "function:run_reliability@app/sim_engine/simulate.py",
      "target": "function:assess_stability@app/sim_engine/reliability.py",
      "type": "calls",
      "description": "Вызывает assess_stability"
    },
    {
      "id": "function:run_reliability@app/sim_engine/simulate.py->class:DictReliabilityWriter@app/sim_engine/writer.py",
      "source": "function:run_reliability@app/sim_engine/simulate.py",
      "target": "class:DictReliabilityWriter@app/sim_engine/writer.py",
      "type": "calls",
      "description": "Вызывает DictReliabilityWriter"
    },
    {
      "id": "class:RawSimDataValidator@app/sim_engine/simulation_manager.py->class:SimDataValidationError@app/sim_engine/simulation_manager.py",
      "source": "class:RawSimDataValidator@app/sim_engine/simulation_manager.py",
      "target": "class:SimDataValidationError@app/sim_engine/simulation_manager.py",
      "type": "calls",
      "description": "Вызывает SimDataValidationError"
    },
    {
      "id": "class:SimConfigOptionsValidator@app/sim_engine/simulation_manager.py->class:SimConfigValidationError@app/sim_engine/simulation_manager.py",
      "source": "class:SimConfigOptionsValidator@app/sim_engine/simulation_manager.py",
      "target": "class:SimConfigValidationError@app/sim_engine/simulation_manager.py",
      "type": "calls",
      "description": "Вызывает SimConfigValidationError"
    },
    {
      "id": "class:SimulationManager@app/sim_engine/simulation_manager.py->class:SimWriterValidationError@app/sim_engine/simulation_manager.py",
      "source": "class:SimulationManager@app/sim_engine/simulation_manager.py",
      "target": "class:SimWriterValidationError@app/sim_engine/simulation_manager.py",
      "type": "calls",
      "description": "Вызывает SimWriterValidationError"
    },
    {
      "id": "class:SimulationManager@app/sim_engine/simulation_manager.py->function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "source": "class:SimulationManager@app/sim_engine/simulation_manager.py",
      "target": "function:run_simulation_for_planned_trips@app/sim_engine/simulate.py",
      "type": "calls",
      "description": "Вызывает run_simulation_for_planned_trips"
    },
    {
      "id": "class:SimulationManager@app/sim_engine/simulation_manager.py->function:run_simulation@app/sim_engine/simulate.py",
      "source": "class:SimulationManager@app/sim_engine/simulation_manager.py",
      "target": "function:run_simulation@app/sim_engine/simulate.py",
      "type": "calls",
      "description": "Вызывает run_simulation"
    },
    {
      "id": "class:SimulationManager@app/sim_engine/simulation_manager.py->class:ValidatorValidationError@app/sim_engine/simulation_manager.py",
      "source": "class:SimulationManager@app/sim_engine/simulation_manager.py",
      "target": "class:ValidatorValidationError@app/sim_engine/simulation_manager.py",
      "type": "calls",
      "description": "Вызывает ValidatorValidationError"
    },
    {
      "id": "class:SimulationManager@app/sim_engine/simulation_manager.py->class:SimDataSerializer@app/sim_engine/serializer.py",
      "source": "class:SimulationManager@app/sim_engine/simulation_manager.py",
      "target": "class:SimDataSerializer@app/sim_engine/serializer.py",
      "type": "calls",
      "description": "Вызывает SimDataSerializer"
    },
    {
      "id": "class:SimulationManager@app/sim_engine/simulation_manager.py->class:PlannedTrip@app/sim_engine/core/props.py",
      "source": "class:SimulationManager@app/sim_engine/simulation_manager.py",
      "target": "class:PlannedTrip@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает PlannedTrip"
    },
    {
      "id": "class:SimulationManager@app/sim_engine/simulation_manager.py->class:Planner@app/sim_engine/core/planner/manage.py",
      "source": "class:SimulationManager@app/sim_engine/simulation_manager.py",
      "target": "class:Planner@app/sim_engine/core/planner/manage.py",
      "type": "calls",
      "description": "Вызывает Planner"
    },
    {
      "id": "class:SimulationManager@app/sim_engine/simulation_manager.py->function:run_reliability@app/sim_engine/simulate.py",
      "source": "class:SimulationManager@app/sim_engine/simulation_manager.py",
      "target": "function:run_reliability@app/sim_engine/simulate.py",
      "type": "calls",
      "description": "Вызывает run_reliability"
    },
    {
      "id": "class:QSimEnvironment@app/sim_engine/core/environment.py->class:GreedySolver@app/sim_engine/core/planner/solvers/greedy.py",
      "source": "class:QSimEnvironment@app/sim_engine/core/environment.py",
      "target": "class:GreedySolver@app/sim_engine/core/planner/solvers/greedy.py",
      "type": "calls",
      "description": "Вызывает GreedySolver"
    },
    {
      "id": "class:QSimEnvironment@app/sim_engine/core/environment.py->class:SimContext@app/sim_engine/core/simulations/entities.py",
      "source": "class:QSimEnvironment@app/sim_engine/core/environment.py",
      "target": "class:SimContext@app/sim_engine/core/simulations/entities.py",
      "type": "calls",
      "description": "Вызывает SimContext"
    },
    {
      "id": "class:QSimEnvironment@app/sim_engine/core/environment.py->class:IdleAreaService@app/sim_engine/core/simulations/utils/idle_area_service.py",
      "source": "class:QSimEnvironment@app/sim_engine/core/environment.py",
      "target": "class:IdleAreaService@app/sim_engine/core/simulations/utils/idle_area_service.py",
      "type": "calls",
      "description": "Вызывает IdleAreaService"
    },
    {
      "id": "class:QSimEnvironment@app/sim_engine/core/environment.py->class:ServiceLocator@app/sim_engine/core/simulations/utils/service_locator.py",
      "source": "class:QSimEnvironment@app/sim_engine/core/environment.py",
      "target": "class:ServiceLocator@app/sim_engine/core/simulations/utils/service_locator.py",
      "type": "calls",
      "description": "Вызывает ServiceLocator"
    },
    {
      "id": "class:QSimEnvironment@app/sim_engine/core/environment.py->class:TripService@app/sim_engine/core/simulations/utils/trip_service.py",
      "source": "class:QSimEnvironment@app/sim_engine/core/environment.py",
      "target": "class:TripService@app/sim_engine/core/simulations/utils/trip_service.py",
      "type": "calls",
      "description": "Вызывает TripService"
    },
    {
      "id": "function:segments_intersect@app/sim_engine/core/geometry.py->function:cross_product@app/sim_engine/core/geometry.py",
      "source": "function:segments_intersect@app/sim_engine/core/geometry.py",
      "target": "function:cross_product@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает cross_product"
    },
    {
      "id": "function:path_intersects_polygons@app/sim_engine/core/geometry.py->function:segments_intersect@app/sim_engine/core/geometry.py",
      "source": "function:path_intersects_polygons@app/sim_engine/core/geometry.py",
      "target": "function:segments_intersect@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает segments_intersect"
    },
    {
      "id": "function:build_route_sim@app/sim_engine/core/geometry.py->class:Point@app/sim_engine/core/geometry.py",
      "source": "function:build_route_sim@app/sim_engine/core/geometry.py",
      "target": "class:Point@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает Point"
    },
    {
      "id": "function:build_route_sim@app/sim_engine/core/geometry.py->class:Point@app/sim_engine/core/props.py",
      "source": "function:build_route_sim@app/sim_engine/core/geometry.py",
      "target": "class:Point@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Point"
    },
    {
      "id": "function:build_route_sim@app/sim_engine/core/geometry.py->class:Route@app/sim_engine/core/geometry.py",
      "source": "function:build_route_sim@app/sim_engine/core/geometry.py",
      "target": "class:Route@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает Route"
    },
    {
      "id": "function:build_route_sim@app/sim_engine/core/geometry.py->class:Route@app/sim_engine/core/props.py",
      "source": "function:build_route_sim@app/sim_engine/core/geometry.py",
      "target": "class:Route@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Route"
    },
    {
      "id": "function:build_route_by_road_net@app/sim_engine/core/geometry.py->class:Point@app/sim_engine/core/geometry.py",
      "source": "function:build_route_by_road_net@app/sim_engine/core/geometry.py",
      "target": "class:Point@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает Point"
    },
    {
      "id": "function:build_route_by_road_net@app/sim_engine/core/geometry.py->class:Point@app/sim_engine/core/props.py",
      "source": "function:build_route_by_road_net@app/sim_engine/core/geometry.py",
      "target": "class:Point@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Point"
    },
    {
      "id": "function:build_route_by_road_net@app/sim_engine/core/geometry.py->class:Route@app/sim_engine/core/geometry.py",
      "source": "function:build_route_by_road_net@app/sim_engine/core/geometry.py",
      "target": "class:Route@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает Route"
    },
    {
      "id": "function:build_route_by_road_net@app/sim_engine/core/geometry.py->class:Route@app/sim_engine/core/props.py",
      "source": "function:build_route_by_road_net@app/sim_engine/core/geometry.py",
      "target": "class:Route@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Route"
    },
    {
      "id": "function:build_route_edges_by_road_net@app/sim_engine/core/geometry.py->class:RouteEdge@app/sim_engine/core/geometry.py",
      "source": "function:build_route_edges_by_road_net@app/sim_engine/core/geometry.py",
      "target": "class:RouteEdge@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает RouteEdge"
    },
    {
      "id": "function:build_route_edges_by_road_net_from_position@app/sim_engine/core/geometry.py->class:RouteEdge@app/sim_engine/core/geometry.py",
      "source": "function:build_route_edges_by_road_net_from_position@app/sim_engine/core/geometry.py",
      "target": "class:RouteEdge@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает RouteEdge"
    },
    {
      "id": "function:build_route_edges_by_road_net_from_position_to_position@app/sim_engine/core/geometry.py->class:RouteEdge@app/sim_engine/core/geometry.py",
      "source": "function:build_route_edges_by_road_net_from_position_to_position@app/sim_engine/core/geometry.py",
      "target": "class:RouteEdge@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает RouteEdge"
    },
    {
      "id": "function:find_all_route_edges_by_road_net_from_position_to_position@app/sim_engine/core/geometry.py->class:RouteEdge@app/sim_engine/core/geometry.py",
      "source": "function:find_all_route_edges_by_road_net_from_position_to_position@app/sim_engine/core/geometry.py",
      "target": "class:RouteEdge@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает RouteEdge"
    },
    {
      "id": "function:find_all_route_edges_by_road_net_from_position@app/sim_engine/core/geometry.py->class:RouteEdge@app/sim_engine/core/geometry.py",
      "source": "function:find_all_route_edges_by_road_net_from_position@app/sim_engine/core/geometry.py",
      "target": "class:RouteEdge@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает RouteEdge"
    },
    {
      "id": "function:find_all_route_edges_by_road_net_from_object_to_object@app/sim_engine/core/geometry.py->class:RouteEdge@app/sim_engine/core/geometry.py",
      "source": "function:find_all_route_edges_by_road_net_from_object_to_object@app/sim_engine/core/geometry.py",
      "target": "class:RouteEdge@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает RouteEdge"
    },
    {
      "id": "function:interpolate_position@app/sim_engine/core/geometry.py->class:Point@app/sim_engine/core/geometry.py",
      "source": "function:interpolate_position@app/sim_engine/core/geometry.py",
      "target": "class:Point@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает Point"
    },
    {
      "id": "function:interpolate_position@app/sim_engine/core/geometry.py->class:Point@app/sim_engine/core/props.py",
      "source": "function:interpolate_position@app/sim_engine/core/geometry.py",
      "target": "class:Point@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает Point"
    },
    {
      "id": "function:find_nearest_point@app/sim_engine/core/geometry.py->function:haversine_km@app/sim_engine/core/geometry.py",
      "source": "function:find_nearest_point@app/sim_engine/core/geometry.py",
      "target": "function:haversine_km@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает haversine_km"
    },
    {
      "id": "function:find_route_edges_around_restricted_zones_from_base_route@app/sim_engine/core/geometry.py->function:find_all_route_edges_by_road_net_from_position_to_position@app/sim_engine/core/geometry.py",
      "source": "function:find_route_edges_around_restricted_zones_from_base_route@app/sim_engine/core/geometry.py",
      "target": "function:find_all_route_edges_by_road_net_from_position_to_position@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает find_all_route_edges_by_road_net_from_position_to_position"
    },
    {
      "id": "function:find_route_edges_around_restricted_zones_from_base_route@app/sim_engine/core/geometry.py->function:path_intersects_polygons@app/sim_engine/core/geometry.py",
      "source": "function:find_route_edges_around_restricted_zones_from_base_route@app/sim_engine/core/geometry.py",
      "target": "function:path_intersects_polygons@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает path_intersects_polygons"
    },
    {
      "id": "function:find_route_edges_around_restricted_zones_from_position_to_object@app/sim_engine/core/geometry.py->function:find_all_route_edges_by_road_net_from_position@app/sim_engine/core/geometry.py",
      "source": "function:find_route_edges_around_restricted_zones_from_position_to_object@app/sim_engine/core/geometry.py",
      "target": "function:find_all_route_edges_by_road_net_from_position@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает find_all_route_edges_by_road_net_from_position"
    },
    {
      "id": "function:find_route_edges_around_restricted_zones_from_position_to_object@app/sim_engine/core/geometry.py->function:path_intersects_polygons@app/sim_engine/core/geometry.py",
      "source": "function:find_route_edges_around_restricted_zones_from_position_to_object@app/sim_engine/core/geometry.py",
      "target": "function:path_intersects_polygons@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает path_intersects_polygons"
    },
    {
      "id": "function:catch_errors@app/sim_engine/infra/exception_traceback.py->class:RunSimulationError@app/sim_engine/infra/exception_traceback.py",
      "source": "function:catch_errors@app/sim_engine/infra/exception_traceback.py",
      "target": "class:RunSimulationError@app/sim_engine/infra/exception_traceback.py",
      "type": "calls",
      "description": "Вызывает RunSimulationError"
    },
    {
      "id": "class:ShovelCalc@app/sim_engine/core/calculations/shovel.py->function:koef_vlazhnosti@app/sim_engine/core/coefficients.py",
      "source": "class:ShovelCalc@app/sim_engine/core/calculations/shovel.py",
      "target": "function:koef_vlazhnosti@app/sim_engine/core/coefficients.py",
      "type": "calls",
      "description": "Вызывает koef_vlazhnosti"
    },
    {
      "id": "class:TruckCalc@app/sim_engine/core/calculations/truck.py->function:interpolate_position@app/sim_engine/core/geometry.py",
      "source": "class:TruckCalc@app/sim_engine/core/calculations/truck.py",
      "target": "function:interpolate_position@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает interpolate_position"
    },
    {
      "id": "class:TruckCalc@app/sim_engine/core/calculations/truck.py->function:haversine_km@app/sim_engine/core/geometry.py",
      "source": "class:TruckCalc@app/sim_engine/core/calculations/truck.py",
      "target": "function:haversine_km@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает haversine_km"
    },
    {
      "id": "class:Planner@app/sim_engine/core/planner/manage.py->class:UnloadCalc@app/sim_engine/core/calculations/unload.py",
      "source": "class:Planner@app/sim_engine/core/planner/manage.py",
      "target": "class:UnloadCalc@app/sim_engine/core/calculations/unload.py",
      "type": "calls",
      "description": "Вызывает UnloadCalc"
    },
    {
      "id": "class:Planner@app/sim_engine/core/planner/manage.py->class:TruckCalc@app/sim_engine/core/calculations/truck.py",
      "source": "class:Planner@app/sim_engine/core/planner/manage.py",
      "target": "class:TruckCalc@app/sim_engine/core/calculations/truck.py",
      "type": "calls",
      "description": "Вызывает TruckCalc"
    },
    {
      "id": "class:Planner@app/sim_engine/core/planner/manage.py->function:get_planning_data@app/sim_engine/planner.py",
      "source": "class:Planner@app/sim_engine/core/planner/manage.py",
      "target": "function:get_planning_data@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает get_planning_data"
    },
    {
      "id": "class:Planner@app/sim_engine/core/planner/manage.py->function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py",
      "source": "class:Planner@app/sim_engine/core/planner/manage.py",
      "target": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py",
      "type": "calls",
      "description": "Вызывает get_planning_data"
    },
    {
      "id": "class:Planner@app/sim_engine/core/planner/manage.py->function:build_route_edges_by_road_net_from_position@app/sim_engine/core/geometry.py",
      "source": "class:Planner@app/sim_engine/core/planner/manage.py",
      "target": "function:build_route_edges_by_road_net_from_position@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает build_route_edges_by_road_net_from_position"
    },
    {
      "id": "class:Planner@app/sim_engine/core/planner/manage.py->class:PlannedTrip@app/sim_engine/core/props.py",
      "source": "class:Planner@app/sim_engine/core/planner/manage.py",
      "target": "class:PlannedTrip@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает PlannedTrip"
    },
    {
      "id": "class:Planner@app/sim_engine/core/planner/manage.py->function:build_route_edges_by_road_net@app/sim_engine/core/geometry.py",
      "source": "class:Planner@app/sim_engine/core/planner/manage.py",
      "target": "function:build_route_edges_by_road_net@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает build_route_edges_by_road_net"
    },
    {
      "id": "class:Planner@app/sim_engine/core/planner/manage.py->class:ShovelCalc@app/sim_engine/core/calculations/shovel.py",
      "source": "class:Planner@app/sim_engine/core/planner/manage.py",
      "target": "class:ShovelCalc@app/sim_engine/core/calculations/shovel.py",
      "type": "calls",
      "description": "Вызывает ShovelCalc"
    },
    {
      "id": "class:Planner@app/sim_engine/core/planner/manage.py->class:InputPlanningData@app/sim_engine/planner.py",
      "source": "class:Planner@app/sim_engine/core/planner/manage.py",
      "target": "class:InputPlanningData@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает InputPlanningData"
    },
    {
      "id": "class:Planner@app/sim_engine/core/planner/manage.py->class:InputPlanningData@app/sim_engine/core/planner/entities.py",
      "source": "class:Planner@app/sim_engine/core/planner/manage.py",
      "target": "class:InputPlanningData@app/sim_engine/core/planner/entities.py",
      "type": "calls",
      "description": "Вызывает InputPlanningData"
    },
    {
      "id": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py->class:TruckCalc@app/sim_engine/core/calculations/truck.py",
      "source": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py",
      "target": "class:TruckCalc@app/sim_engine/core/calculations/truck.py",
      "type": "calls",
      "description": "Вызывает TruckCalc"
    },
    {
      "id": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py->class:UnloadCalc@app/sim_engine/core/calculations/unload.py",
      "source": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py",
      "target": "class:UnloadCalc@app/sim_engine/core/calculations/unload.py",
      "type": "calls",
      "description": "Вызывает UnloadCalc"
    },
    {
      "id": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py->class:InputPlanningData@app/sim_engine/planner.py",
      "source": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py",
      "target": "class:InputPlanningData@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает InputPlanningData"
    },
    {
      "id": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py->class:InputPlanningData@app/sim_engine/core/planner/entities.py",
      "source": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py",
      "target": "class:InputPlanningData@app/sim_engine/core/planner/entities.py",
      "type": "calls",
      "description": "Вызывает InputPlanningData"
    },
    {
      "id": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py->class:ShovelCalc@app/sim_engine/core/calculations/shovel.py",
      "source": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py",
      "target": "class:ShovelCalc@app/sim_engine/core/calculations/shovel.py",
      "type": "calls",
      "description": "Вызывает ShovelCalc"
    },
    {
      "id": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py->function:build_route_edges_by_road_net_from_position@app/sim_engine/core/geometry.py",
      "source": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py",
      "target": "function:build_route_edges_by_road_net_from_position@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает build_route_edges_by_road_net_from_position"
    },
    {
      "id": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py->function:build_route_edges_by_road_net@app/sim_engine/core/geometry.py",
      "source": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py",
      "target": "function:build_route_edges_by_road_net@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает build_route_edges_by_road_net"
    },
    {
      "id": "class:FuelStation@app/sim_engine/core/simulations/fuel_station.py->class:BaseTickBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "source": "class:FuelStation@app/sim_engine/core/simulations/fuel_station.py",
      "target": "class:BaseTickBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "type": "calls",
      "description": "Вызывает BaseTickBehavior"
    },
    {
      "id": "class:FuelStation@app/sim_engine/core/simulations/fuel_station.py->class:FuelStationEvent@app/sim_engine/events.py",
      "source": "class:FuelStation@app/sim_engine/core/simulations/fuel_station.py",
      "target": "class:FuelStationEvent@app/sim_engine/events.py",
      "type": "calls",
      "description": "Вызывает FuelStationEvent"
    },
    {
      "id": "class:Quarry@app/sim_engine/core/simulations/quarry.py->class:QuarryBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py",
      "source": "class:Quarry@app/sim_engine/core/simulations/quarry.py",
      "target": "class:QuarryBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py",
      "type": "calls",
      "description": "Вызывает QuarryBlastingWatcher"
    },
    {
      "id": "class:Quarry@app/sim_engine/core/simulations/quarry.py->class:Event@app/sim_engine/events.py",
      "source": "class:Quarry@app/sim_engine/core/simulations/quarry.py",
      "target": "class:Event@app/sim_engine/events.py",
      "type": "calls",
      "description": "Вызывает Event"
    },
    {
      "id": "class:Quarry@app/sim_engine/core/simulations/quarry.py->class:Planner@app/sim_engine/core/planner/manage.py",
      "source": "class:Quarry@app/sim_engine/core/simulations/quarry.py",
      "target": "class:Planner@app/sim_engine/core/planner/manage.py",
      "type": "calls",
      "description": "Вызывает Planner"
    },
    {
      "id": "class:Shovel@app/sim_engine/core/simulations/shovel.py->class:PlannedIdleBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "source": "class:Shovel@app/sim_engine/core/simulations/shovel.py",
      "target": "class:PlannedIdleBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "type": "calls",
      "description": "Вызывает PlannedIdleBehavior"
    },
    {
      "id": "class:Shovel@app/sim_engine/core/simulations/shovel.py->class:BaseTickBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "source": "class:Shovel@app/sim_engine/core/simulations/shovel.py",
      "target": "class:BaseTickBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "type": "calls",
      "description": "Вызывает BaseTickBehavior"
    },
    {
      "id": "class:Shovel@app/sim_engine/core/simulations/shovel.py->class:BreakdownBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "source": "class:Shovel@app/sim_engine/core/simulations/shovel.py",
      "target": "class:BreakdownBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "type": "calls",
      "description": "Вызывает BreakdownBehavior"
    },
    {
      "id": "class:Shovel@app/sim_engine/core/simulations/shovel.py->class:Event@app/sim_engine/events.py",
      "source": "class:Shovel@app/sim_engine/core/simulations/shovel.py",
      "target": "class:Event@app/sim_engine/events.py",
      "type": "calls",
      "description": "Вызывает Event"
    },
    {
      "id": "class:Shovel@app/sim_engine/core/simulations/shovel.py->class:ShovelBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py",
      "source": "class:Shovel@app/sim_engine/core/simulations/shovel.py",
      "target": "class:ShovelBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py",
      "type": "calls",
      "description": "Вызывает ShovelBlastingWatcher"
    },
    {
      "id": "class:Shovel@app/sim_engine/core/simulations/shovel.py->class:ShovelCalc@app/sim_engine/core/calculations/shovel.py",
      "source": "class:Shovel@app/sim_engine/core/simulations/shovel.py",
      "target": "class:ShovelCalc@app/sim_engine/core/calculations/shovel.py",
      "type": "calls",
      "description": "Вызывает ShovelCalc"
    },
    {
      "id": "class:Truck@app/sim_engine/core/simulations/truck.py->class:PlannedIdleBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "source": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "target": "class:PlannedIdleBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "type": "calls",
      "description": "Вызывает PlannedIdleBehavior"
    },
    {
      "id": "class:Truck@app/sim_engine/core/simulations/truck.py->class:BaseTickBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "source": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "target": "class:BaseTickBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "type": "calls",
      "description": "Вызывает BaseTickBehavior"
    },
    {
      "id": "class:Truck@app/sim_engine/core/simulations/truck.py->class:TruckBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py",
      "source": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "target": "class:TruckBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py",
      "type": "calls",
      "description": "Вызывает TruckBlastingWatcher"
    },
    {
      "id": "class:Truck@app/sim_engine/core/simulations/truck.py->class:LunchBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "source": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "target": "class:LunchBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "type": "calls",
      "description": "Вызывает LunchBehavior"
    },
    {
      "id": "class:Truck@app/sim_engine/core/simulations/truck.py->function:build_route_edges_by_road_net_from_position@app/sim_engine/core/geometry.py",
      "source": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "target": "function:build_route_edges_by_road_net_from_position@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает build_route_edges_by_road_net_from_position"
    },
    {
      "id": "class:Truck@app/sim_engine/core/simulations/truck.py->class:BreakdownBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "source": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "target": "class:BreakdownBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "type": "calls",
      "description": "Вызывает BreakdownBehavior"
    },
    {
      "id": "class:Truck@app/sim_engine/core/simulations/truck.py->class:Event@app/sim_engine/events.py",
      "source": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "target": "class:Event@app/sim_engine/events.py",
      "type": "calls",
      "description": "Вызывает Event"
    },
    {
      "id": "class:Truck@app/sim_engine/core/simulations/truck.py->function:build_route_edges_by_road_net@app/sim_engine/core/geometry.py",
      "source": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "target": "function:build_route_edges_by_road_net@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает build_route_edges_by_road_net"
    },
    {
      "id": "class:Truck@app/sim_engine/core/simulations/truck.py->function:find_route_edges_around_restricted_zones_from_base_route@app/sim_engine/core/geometry.py",
      "source": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "target": "function:find_route_edges_around_restricted_zones_from_base_route@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает find_route_edges_around_restricted_zones_from_base_route"
    },
    {
      "id": "class:Truck@app/sim_engine/core/simulations/truck.py->function:haversine_km@app/sim_engine/core/geometry.py",
      "source": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "target": "function:haversine_km@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает haversine_km"
    },
    {
      "id": "class:Truck@app/sim_engine/core/simulations/truck.py->function:path_intersects_polygons@app/sim_engine/core/geometry.py",
      "source": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "target": "function:path_intersects_polygons@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает path_intersects_polygons"
    },
    {
      "id": "class:Truck@app/sim_engine/core/simulations/truck.py->function:build_route_edges_by_road_net_from_position_to_position@app/sim_engine/core/geometry.py",
      "source": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "target": "function:build_route_edges_by_road_net_from_position_to_position@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает build_route_edges_by_road_net_from_position_to_position"
    },
    {
      "id": "class:Truck@app/sim_engine/core/simulations/truck.py->class:FuelBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "source": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "target": "class:FuelBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "type": "calls",
      "description": "Вызывает FuelBehavior"
    },
    {
      "id": "class:Truck@app/sim_engine/core/simulations/truck.py->class:TripData@app/sim_engine/core/props.py",
      "source": "class:Truck@app/sim_engine/core/simulations/truck.py",
      "target": "class:TripData@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает TripData"
    },
    {
      "id": "class:Unload@app/sim_engine/core/simulations/unload.py->class:UnloadCalc@app/sim_engine/core/calculations/unload.py",
      "source": "class:Unload@app/sim_engine/core/simulations/unload.py",
      "target": "class:UnloadCalc@app/sim_engine/core/calculations/unload.py",
      "type": "calls",
      "description": "Вызывает UnloadCalc"
    },
    {
      "id": "class:Unload@app/sim_engine/core/simulations/unload.py->class:BaseTickBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "source": "class:Unload@app/sim_engine/core/simulations/unload.py",
      "target": "class:BaseTickBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "type": "calls",
      "description": "Вызывает BaseTickBehavior"
    },
    {
      "id": "class:Unload@app/sim_engine/core/simulations/unload.py->class:UnloadBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py",
      "source": "class:Unload@app/sim_engine/core/simulations/unload.py",
      "target": "class:UnloadBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py",
      "type": "calls",
      "description": "Вызывает UnloadBlastingWatcher"
    },
    {
      "id": "class:Unload@app/sim_engine/core/simulations/unload.py->class:BreakdownBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "source": "class:Unload@app/sim_engine/core/simulations/unload.py",
      "target": "class:BreakdownBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "type": "calls",
      "description": "Вызывает BreakdownBehavior"
    },
    {
      "id": "class:Unload@app/sim_engine/core/simulations/unload.py->class:Event@app/sim_engine/events.py",
      "source": "class:Unload@app/sim_engine/core/simulations/unload.py",
      "target": "class:Event@app/sim_engine/events.py",
      "type": "calls",
      "description": "Вызывает Event"
    },
    {
      "id": "class:BreakdownBehavior@app/sim_engine/core/simulations/behaviors/base.py->class:BreakdownCalc@app/sim_engine/core/calculations/base.py",
      "source": "class:BreakdownBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "target": "class:BreakdownCalc@app/sim_engine/core/calculations/base.py",
      "type": "calls",
      "description": "Вызывает BreakdownCalc"
    },
    {
      "id": "class:FuelBehavior@app/sim_engine/core/simulations/behaviors/base.py->class:FuelCalc@app/sim_engine/core/calculations/base.py",
      "source": "class:FuelBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "target": "class:FuelCalc@app/sim_engine/core/calculations/base.py",
      "type": "calls",
      "description": "Вызывает FuelCalc"
    },
    {
      "id": "class:LunchBehavior@app/sim_engine/core/simulations/behaviors/base.py->class:LunchCalc@app/sim_engine/core/calculations/base.py",
      "source": "class:LunchBehavior@app/sim_engine/core/simulations/behaviors/base.py",
      "target": "class:LunchCalc@app/sim_engine/core/calculations/base.py",
      "type": "calls",
      "description": "Вызывает LunchCalc"
    },
    {
      "id": "class:ShovelBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py->function:find_all_route_edges_by_road_net_from_object_to_object@app/sim_engine/core/geometry.py",
      "source": "class:ShovelBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py",
      "target": "function:find_all_route_edges_by_road_net_from_object_to_object@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает find_all_route_edges_by_road_net_from_object_to_object"
    },
    {
      "id": "class:ShovelBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py->function:path_intersects_polygons@app/sim_engine/core/geometry.py",
      "source": "class:ShovelBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py",
      "target": "function:path_intersects_polygons@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает path_intersects_polygons"
    },
    {
      "id": "class:UnloadBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py->function:find_all_route_edges_by_road_net_from_object_to_object@app/sim_engine/core/geometry.py",
      "source": "class:UnloadBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py",
      "target": "function:find_all_route_edges_by_road_net_from_object_to_object@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает find_all_route_edges_by_road_net_from_object_to_object"
    },
    {
      "id": "class:UnloadBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py->function:path_intersects_polygons@app/sim_engine/core/geometry.py",
      "source": "class:UnloadBlastingWatcher@app/sim_engine/core/simulations/behaviors/blasting.py",
      "target": "function:path_intersects_polygons@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает path_intersects_polygons"
    },
    {
      "id": "class:DependencyResolver@app/sim_engine/core/simulations/utils/dependency_resolver.py->class:ServiceLocator@app/sim_engine/core/simulations/utils/service_locator.py",
      "source": "class:DependencyResolver@app/sim_engine/core/simulations/utils/dependency_resolver.py",
      "target": "class:ServiceLocator@app/sim_engine/core/simulations/utils/service_locator.py",
      "type": "calls",
      "description": "Вызывает ServiceLocator"
    },
    {
      "id": "function:sim_current_timestamp@app/sim_engine/core/simulations/utils/helpers.py->function:sim_current_time@app/sim_engine/core/simulations/utils/helpers.py",
      "source": "function:sim_current_timestamp@app/sim_engine/core/simulations/utils/helpers.py",
      "target": "function:sim_current_time@app/sim_engine/core/simulations/utils/helpers.py",
      "type": "calls",
      "description": "Вызывает sim_current_time"
    },
    {
      "id": "class:IdleAreaService@app/sim_engine/core/simulations/utils/idle_area_service.py->function:find_route_edges_around_restricted_zones_from_position_to_object@app/sim_engine/core/geometry.py",
      "source": "class:IdleAreaService@app/sim_engine/core/simulations/utils/idle_area_service.py",
      "target": "function:find_route_edges_around_restricted_zones_from_position_to_object@app/sim_engine/core/geometry.py",
      "type": "calls",
      "description": "Вызывает find_route_edges_around_restricted_zones_from_position_to_object"
    },
    {
      "id": "class:TripService@app/sim_engine/core/simulations/utils/trip_service.py->function:sim_current_time@app/sim_engine/core/simulations/utils/helpers.py",
      "source": "class:TripService@app/sim_engine/core/simulations/utils/trip_service.py",
      "target": "function:sim_current_time@app/sim_engine/core/simulations/utils/helpers.py",
      "type": "calls",
      "description": "Вызывает sim_current_time"
    },
    {
      "id": "class:TripService@app/sim_engine/core/simulations/utils/trip_service.py->class:ActualTrip@app/sim_engine/core/props.py",
      "source": "class:TripService@app/sim_engine/core/simulations/utils/trip_service.py",
      "target": "class:ActualTrip@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает ActualTrip"
    },
    {
      "id": "class:TripService@app/sim_engine/core/simulations/utils/trip_service.py->class:QuarryObject@app/sim_engine/core/props.py",
      "source": "class:TripService@app/sim_engine/core/simulations/utils/trip_service.py",
      "target": "class:QuarryObject@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает QuarryObject"
    },
    {
      "id": "class:TripService@app/sim_engine/core/simulations/utils/trip_service.py->function:sim_start_time@app/sim_engine/core/simulations/utils/helpers.py",
      "source": "class:TripService@app/sim_engine/core/simulations/utils/trip_service.py",
      "target": "function:sim_start_time@app/sim_engine/core/simulations/utils/helpers.py",
      "type": "calls",
      "description": "Вызывает sim_start_time"
    },
    {
      "id": "class:CPSolver@app/sim_engine/core/planner/solvers/cp.py->function:compute_Kmax_i@app/sim_engine/planner.py",
      "source": "class:CPSolver@app/sim_engine/core/planner/solvers/cp.py",
      "target": "function:compute_Kmax_i@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает compute_Kmax_i"
    },
    {
      "id": "class:CPSolver@app/sim_engine/core/planner/solvers/cp.py->function:build_cp_model@app/sim_engine/planner.py",
      "source": "class:CPSolver@app/sim_engine/core/planner/solvers/cp.py",
      "target": "function:build_cp_model@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает build_cp_model"
    },
    {
      "id": "class:GreedySolver@app/sim_engine/core/planner/solvers/greedy.py->function:get_planning_data@app/sim_engine/planner.py",
      "source": "class:GreedySolver@app/sim_engine/core/planner/solvers/greedy.py",
      "target": "function:get_planning_data@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает get_planning_data"
    },
    {
      "id": "class:GreedySolver@app/sim_engine/core/planner/solvers/greedy.py->function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py",
      "source": "class:GreedySolver@app/sim_engine/core/planner/solvers/greedy.py",
      "target": "function:get_planning_data@app/sim_engine/core/planner/planning_matrix.py",
      "type": "calls",
      "description": "Вызывает get_planning_data"
    },
    {
      "id": "class:GreedySolver@app/sim_engine/core/planner/solvers/greedy.py->class:PlannedTrip@app/sim_engine/core/props.py",
      "source": "class:GreedySolver@app/sim_engine/core/planner/solvers/greedy.py",
      "target": "class:PlannedTrip@app/sim_engine/core/props.py",
      "type": "calls",
      "description": "Вызывает PlannedTrip"
    },
    {
      "id": "class:MILPSolver@app/sim_engine/core/planner/solvers/milp.py->function:compute_Kmax_i@app/sim_engine/planner.py",
      "source": "class:MILPSolver@app/sim_engine/core/planner/solvers/milp.py",
      "target": "function:compute_Kmax_i@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает compute_Kmax_i"
    },
    {
      "id": "class:MILPSolver@app/sim_engine/core/planner/solvers/milp.py->function:build_model@app/sim_engine/planner.py",
      "source": "class:MILPSolver@app/sim_engine/core/planner/solvers/milp.py",
      "target": "function:build_model@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает build_model"
    },
    {
      "id": "class:MILPSolver@app/sim_engine/core/planner/solvers/milp.py->function:default_Kmax@app/sim_engine/planner.py",
      "source": "class:MILPSolver@app/sim_engine/core/planner/solvers/milp.py",
      "target": "function:default_Kmax@app/sim_engine/planner.py",
      "type": "calls",
      "description": "Вызывает default_Kmax"
    }
  ]
}